<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/12/20/web%E5%89%8D%E7%AB%AF/note/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACES%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2022/12/20/web%E5%89%8D%E7%AB%AF/note/%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACES%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>本文汇总了 ES6 至 ES11 使用十分常用的特性，包括正在规划的 ES12，仅涵盖了全部的 ES 特性。详细介绍将使用到 ES6 至 ES11 最新版的可用特性。</p><h3 id="新特性-ES6（2015）"><a href="#新特性-ES6（2015）" class="headerlink" title="新特性 ES6（2015）"></a><strong>新特性 ES6（2015）</strong></h3><p><strong>1、类（类）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Man &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name =  有课前端网;</span><br><span class="line">  &#125;</span><br><span class="line">  console() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const man = new Man( 有课前端网);</span><br><span class="line">man.console(); //  有课前端网</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、智能（ES 模块）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 模块 A 导出一个方法</span><br><span class="line">export const sub = (a, b) = a + b;</span><br><span class="line">// 模块 B 导入使用</span><br><span class="line">import &#123; sub &#125; from ./A;</span><br><span class="line">console.log(sub(1, 2)); // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3、箭头（箭头）函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const func = (a, b) = a + b;</span><br><span class="line">func(1, 2); // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4、函数参数默认值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo(age = 25,)&#123; // ...&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5、 模板字符串</strong>​​​​​​​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const name =  有课前端网;</span><br><span class="line">const str = `Your name is $&#123;name&#125;`;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>6、解构架构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 1, b= 2;</span><br><span class="line">[a, b] = [b, a]; // a 2  b 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>7、延展符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = [...hello world]; // [h, e, l, l, o,  , w, o, r, l, d]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>8、对象属性简写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const name= fly63前端,</span><br><span class="line">const obj = &#123; name &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>9、承诺</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(() = &#123; console.log(2); &#125;);</span><br><span class="line">console.log(1);</span><br><span class="line">// 先打印 1 ，再打印 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>10、让和常量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let name =  有课前端网；</span><br><span class="line">const arr = [];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ES7（2016）"><a href="#ES7（2016）" class="headerlink" title="ES7（2016）"></a><strong>ES7（2016）</strong></h3><p><strong>1、 Array.prototype.includes()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1].includes(1); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、指数操作符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2**10; // 1024</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ES8（2017）"><a href="#ES8（2017）" class="headerlink" title="ES8（2017）"></a><strong>ES8（2017）</strong></h3><p><strong>1、异步 / 等待</strong></p><p>终极终极解决方案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async getData()&#123;</span><br><span class="line">    const res = await api.getTableData(); // await 异步任务</span><br><span class="line">    // do something    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、Object.values()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.values(&#123;a: 1, b: 2, c: 3&#125;); // [1, 2, 3]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3、 Object.entries()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.entries(&#123;a: 1, b: 2, c: 3&#125;); // [[a, 1], [b, 2], [c, 3]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4、字符串填充</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// padStart</span><br><span class="line">hello.padStart(10); //      hello</span><br><span class="line">// padEnd</span><br><span class="line">hello.padEnd(10) hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5、函数参数列表允许结尾</strong></p><p>规定也一样，职能规定与规则和结尾的逗号，保持一致。</p><p><strong>6、Object.getOwnPropertyDescriptors()</strong></p><p>如果对象的所有自身属性获取一个空，则如果没有返回对象。</p><p><strong>7、SharedArrayBuffer 对象</strong></p><p>SharedArray 对象使用表示一个通用的长度的密封缓冲区，密封，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;*&#125; length 所创建的数组缓冲区的大小，以字节(byte)为单位。</span><br><span class="line"> * @returns &#123;SharedArrayBuffer&#125; 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。</span><br><span class="line"> */</span><br><span class="line">new SharedArrayBuffer(10)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>8、原子对象</strong></p><p>Atomics 对象提供了一组静态方法，用于对 SharedArrayBuffer 对象进行<a href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020">原子操作</a>。</p><h3 id="ES9（2018）"><a href="#ES9（2018）" class="headerlink" title="ES9（2018）"></a><strong>ES9（2018）</strong></h3><p><strong>1、徒劳</strong></p><p>await 可以和 for… 的循环使用，以某种方式运行异步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function process(array) &#123;</span><br><span class="line">  for await (let i of array) &#123;</span><br><span class="line">    // doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、 Promise.finally()</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then().catch(e = e).finally();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3、Rest/Spread 属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const values = [1, 2, 3, 5, 6];</span><br><span class="line">console.log( Math.max(...values) ); // 6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4、正则导演组</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const reg = /(year[0-9]&#123;4&#125;)-(month[0-9]&#123;2&#125;)-(day[0-9]&#123;2&#125;)/;</span><br><span class="line">const match = reg.exec(2021-02-23);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5、正则表达式相反声明</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(=p)、(=p)  p 前面(位置)、p 后面(位置)</span><br><span class="line">(!p)、(!p) 除了 p 前面(位置)、除了 p 后面(位置)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>6、正则表达式 dotAll 模式</strong></p><p>正则表达式中点。除匹配回车外的任何单字符，标记改变这种行为，允许行终止符的出现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/hello.world/.test(hello\nworld); // false</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ES10（2019）"><a href="#ES10（2019）" class="headerlink" title="ES10（2019）"></a><strong>ES10（2019）</strong></h3><p><strong>1、Array.flat() 和 Array.flatMap()</strong></p><p>平坦的（）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, 4]].flat(Infinity); // [1, 2, 3, 4]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>平面图（）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4].flatMap(a = [a**2]); // [1, 4, 9, 16]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、String.trimStart() 和 String.trimEnd()</strong></p><p>去除字符串首尾字符</p><p><strong>3、String.prototype.matchAll</strong></p><p>matchAll（）为所有匹配的匹配对象返回一个重复器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const raw_arr = test1  test2  test3.matchAll((/t(e)(st(\d))/g));</span><br><span class="line">const arr = [...raw_arr];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4、Symbol.prototype.description</strong></p><p>只读属性，返回 Symbol 对象的任选描述的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Symbol(description).description; // description</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5、 Object.fromEntries()</strong></p><p>返回一个给定对象本人可枚举属性值的关键值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过 Object.fromEntries， 可以将 Map 转化为 Object:</span><br><span class="line">const map = new Map([ [foo, bar], [baz, 42] ]);</span><br><span class="line">console.log(Object.fromEntries(map)); // &#123; foo: bar, baz: 42 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>6、任选捕获</strong></p><p>在 ES10 之前，我们是这样异常的监护人：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try &#123;// tryCode</span><br><span class="line">&#125; catch (err) &#123;// catchCode</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的 err 是必须的参数，在 ES10 可以省略这个参数。</p><h3 id="ES11（2020）"><a href="#ES11（2020）" class="headerlink" title="ES11（2020）"></a><strong>ES11（2020）</strong></h3><p><strong>1、空值合并操作符（空值处理）</strong></p><p>表达式在的左边求价值，未定义或返回其性质。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">    u1: 0,</span><br><span class="line">    u2: false,</span><br><span class="line">    u3: null,</span><br><span class="line">    u4: undefined</span><br><span class="line">    u5: ,</span><br><span class="line">&#125;</span><br><span class="line">let u2 = user.u2  用户2  // false</span><br><span class="line">let u3 = user.u3  用户3  // 用户3</span><br><span class="line">let u4 = user.u4  用户4  // 用户4</span><br><span class="line">let u5 = user.u5  用户5  //</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、可选链（任选链）</strong></p><p>用户检测宝宝的孩子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;&#125;</span><br><span class="line">let u1 = user.childer.name // TypeError: Cannot read property name of undefined</span><br><span class="line">let u1 = user.childer.name // undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3、Promise.allSettled</strong></p><p>返回在所有给定的承诺中，已被拒绝或被拒绝后的亲，并以一个对象的承诺，每个对象表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = Promise.resolve(3);</span><br><span class="line">const promise2 = 42;</span><br><span class="line">const promise3 = new Promise((resolve, reject) = reject(我是失败的Promise_1));</span><br><span class="line">const promise4 = new Promise((resolve, reject) = reject(我是失败的Promise_2));</span><br><span class="line">const promiseList = [promise1,promise2,promise3, promise4]</span><br><span class="line">Promise.allSettled(promiseList)</span><br><span class="line">.then(values=&#123;</span><br><span class="line">  console.log(values)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4、进口（）</strong></p><p>导入导入</p><p><strong>5、新基本数据类型 BigInt</strong></p><p>任意匹配的概率</p><p><strong>6、globalThis</strong></p><ul><li>浏览器：window</li><li>工人：自己</li><li>节点：全局</li></ul><h3 id="ES12（2021）"><a href="#ES12（2021）" class="headerlink" title="ES12（2021）"></a><strong>ES12（2021）</strong></h3><p><strong>1、全部替换</strong></p><p>返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const str = hello world;</span><br><span class="line">str.replaceAll(l, ); // heo word</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2、Promise.any</strong></p><p>Promise.any() 接收到一个 Promise 就可以没有拒绝，只要其中的一个 promise 成功，就返回那个 promise 。如果已经可以让对象中返回一个 promise 成功（所有的 promise 都失败 /），失败的承诺。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = new Promise((resolve, reject) = reject(我是失败的Promise_1));</span><br><span class="line">const promise2 = new Promise((resolve, reject) = reject(我是失败的Promise_2));</span><br><span class="line">const promiseList = [promise1, promise2];</span><br><span class="line">Promise.any(promiseList)</span><br><span class="line">.then(values=&#123;</span><br><span class="line">  console.log(values);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(e=&#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3、弱引用</strong></p><p>使用 WeakRefs 的 Class 类创建对对象的弱引用（对对象的弱引用是指当该对象应该被 GC 回收时不会阻止 GC 的回收行为）</p><p><strong>4、逻辑和形式表现</strong></p><p>之间的关系和表现，以及性能结合了之间的关系（和表现）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a ||= b</span><br><span class="line">//等价于</span><br><span class="line">a = a || (a = b)</span><br><span class="line">a = b</span><br><span class="line">//等价于</span><br><span class="line">a = a  (a = b)</span><br><span class="line">a = b</span><br><span class="line">//等价于</span><br><span class="line">a = a  (a = b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5、数字字符</strong></p><p>数字间隔性符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字化可计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const money = 1_000_000_000;</span><br><span class="line">//等价于</span><br><span class="line">const money = 1000000000;</span><br><span class="line">1_000_000_000 === 1000000000; // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/20/web%E5%89%8D%E7%AB%AF/Typescript/TypeScript%20%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/20/web%E5%89%8D%E7%AB%AF/Typescript/TypeScript%20%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-TypeScript-中的基本类型"><a href="#1-TypeScript-中的基本类型" class="headerlink" title="1.TypeScript 中的基本类型"></a>1.<strong>TypeScript 中的基本类型</strong></h2><p>TypeScript 中的基本类型：</p><h3 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h3><ul><li>类型声明是 TS 非常重要的一个特点；</li><li>通过类型声明可以指定 TS 中变量（参数、形参）的类型；</li><li>指定类型后，当为变量赋值时，TS 编译器会自动检查值是否符合类型声明，符合则赋值，否则报错；</li><li>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值；</li><li>语法：<ul><li>```typescript<br>  let 变量: 类型;  let 变量: 类型 = 值;  function fn(参数: 类型, 参数: 类型): 类型{<pre><code>  ...</code></pre>  }  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   自动类型判断</span><br><span class="line">    </span><br><span class="line">    *   TS 拥有自动的类型判断机制</span><br><span class="line">    *   当对变量的声明和赋值是同时进行的，TS 编译器会自动判断变量的类型</span><br><span class="line">    *   所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</span><br><span class="line">    </span><br><span class="line">*   类型：</span><br><span class="line">    </span><br><span class="line">    &lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;number&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;1, -33, 2.5&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;任意数字&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;string&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;‘hi’, “hi”, &lt;code&gt;hi&lt;/code&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;任意字符串&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;boolean&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;true、false&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;布尔值 true 或 false&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;字面量&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;其本身&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;限制变量的值就是该字面量的值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;any&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;*&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;任意类型&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;unknown&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;*&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;类型安全的 any&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;void&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;空值（undefined）&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;没有值（或 undefined）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;never&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;没有值&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;不能是任何值&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;object&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&#123;name:‘孙悟空’&#125;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;任意的 JS 对象&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;array&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;[1,2,3]&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;任意 JS 数组&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;tuple&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;[4,5]&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;元素，TS 新增类型，固定长度数组&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;enum&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;enum&#123;A, B&#125;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;枚举，TS 中新增类型&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</span><br><span class="line">    </span><br><span class="line">*   number</span><br><span class="line">    </span><br><span class="line">    *   ```</span><br><span class="line">        let decimal: number = 6;</span><br><span class="line">        let hex: number = 0xf00d;</span><br><span class="line">        let binary: number = 0b1010;</span><br><span class="line">        let octal: number = 0o744;</span><br><span class="line">        let big: bigint = 100n;</span><br></pre></td></tr></table></figure></li></ul></li><li>boolean<ul><li>```<br>  let isDone: boolean = false;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   string</span><br><span class="line">    </span><br><span class="line">    *   ```</span><br><span class="line">        let color: string = &quot;blue&quot;;</span><br><span class="line">        color = &#x27;red&#x27;;</span><br><span class="line">        </span><br><span class="line">        let fullName: string = `Bob Bobbington`;</span><br><span class="line">        let age: number = 37;</span><br><span class="line">        let sentence: string = `Hello, my name is $&#123;fullName&#125;.</span><br><span class="line">        </span><br><span class="line">        I&#x27;ll be $&#123;age + 1&#125; years old next month.`;</span><br><span class="line">        </span><br></pre></td></tr></table></figure></li></ul></li><li>字面量<ul><li>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</li><li>```<br>  let color: ‘red’ | ‘blue’ | ‘black’;<br>  let num: 1 | 2 | 3 | 4 | 5;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   any</span><br><span class="line">    </span><br><span class="line">    *   ```</span><br><span class="line">        let d: any = 4;</span><br><span class="line">        d = &#x27;hello&#x27;;</span><br><span class="line">        d = true;</span><br></pre></td></tr></table></figure>  <strong>any 表示的是任意类型，一个变量设置类型为any后相当于对该变量关闭了TS的类型检测</strong>  <strong>声明变量如果不指定类型，则TS解析器会自动判断变量的类型为any（隐式的any）</strong>  d的类型是any，它可以赋值给任意变量</li></ul></li><li>unknown  <code>unknown</code> 表示未知类型的值  <code>unknown</code>实际上就是一个类型安全的any  <code>unknown</code>类型的变量不能直接赋值给其他变量<ul><li>```<br>  let notSure: unknown = 4;<br>  notSure = ‘hello’;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   void</span><br><span class="line">    </span><br><span class="line">    void用来表示空，以函数为例，就表示没有返回值的函数</span><br><span class="line">    </span><br><span class="line">    *   ```</span><br><span class="line">        let unusable: void = undefined;</span><br></pre></td></tr></table></figure></li></ul></li><li>never  never 表示永远不会返回结果（用于报错）<ul><li>```<br>  function error(message: string): never {<pre><code>throw new Error(message);</code></pre>  }  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   object（没啥用）</span><br><span class="line">    </span><br><span class="line">    object表示一个js对象</span><br><span class="line">    </span><br><span class="line">    在开发中是不去使用的</span><br><span class="line">    </span><br><span class="line">    *   ```</span><br><span class="line">        let obj: object = &#123;&#125;;</span><br></pre></td></tr></table></figure>  常用  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125;用来指定对象中可以包含那些属性</span></span><br><span class="line"><span class="comment">// 语法 &#123;属性名: 属性值&#125;</span></span><br><span class="line"><span class="comment">//在属性名后面加上? ,表示属性是可选的</span></span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">name</span>: <span class="built_in">string</span>, age?: <span class="built_in">number</span>&#125;; <span class="comment">// 一模一样</span></span><br><span class="line">b = &#123;<span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [propName: string]: any 表示任意类型的属性</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125;;</span><br><span class="line">c = &#123;<span class="attr">name</span>: <span class="string">&#x27;猪八戒&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li>array<ul><li>```<br>  let list: number[] = [1, 2, 3];<br>  let list: Array<number> = [1, 2, 3];  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   tuple</span><br><span class="line">    </span><br><span class="line">    *   ```</span><br><span class="line">        /*</span><br><span class="line">        *   元组，元组就是固定长度的数组</span><br><span class="line">        *       语法：[类型, 类型, 类型]</span><br><span class="line">        * */</span><br><span class="line">        let x: [string, number];</span><br><span class="line">        x = [&quot;hello&quot;, 10]; </span><br></pre></td></tr></table></figure></li></ul></li><li>enum<ul><li>```typescript<br>  enum Color {<pre><code>Red,Green,Blue,</code></pre>  }<br>  let c: Color = Color.Green;  enum Color {<pre><code>Red = 1,Green,Blue,</code></pre>  }<br>  let c: Color = Color.Green;  enum Color {<pre><code>Red = 1,Green = 2,Blue = 4,</code></pre>  }<br>  let c: Color = Color.Green;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   类型断言</span><br><span class="line">    </span><br><span class="line">    可以告诉解析器变量的实际类型</span><br><span class="line">    </span><br><span class="line">    *   有些情况下，变量的类型对于我们来说是很明确，但是 TS 编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</span><br><span class="line">        </span><br><span class="line">        *   第一种</span><br><span class="line">            </span><br><span class="line">            *   ```typescript</span><br><span class="line">                let someValue: unknown = &quot;this is a string&quot;;</span><br><span class="line">                let strLength: number = (someValue as string).length;</span><br><span class="line">                //变量 as 类型</span><br></pre></td></tr></table></figure><ul><li>第二种<ul><li>```typescript<br>  let someValue: unknown = “this is a string”;<br>  let strLength: number = (<string>someValue).length;<br>  //&lt;类型&gt;变量  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                </span><br><span class="line"></span><br><span class="line">2. 编译选项</span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">### 自动编译文件</span><br><span class="line"></span><br><span class="line">编译文件时，使用 -w 指令后，TS 编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>tsc xxx.ts -w<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 自动编译整个项目</span><br><span class="line"></span><br><span class="line">如果直接使用 tsc 指令，则可以自动将当前项目下的所有 ts 文件编译为 js 文件。</span><br><span class="line"></span><br><span class="line">**但是能直接使用 tsc 命令的前提时，要先在项目根目录下创建一个 ts 的配置文件 tsconfig.json**</span><br><span class="line"></span><br><span class="line">tsconfig.json 是一个 JSON 文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</span><br><span class="line"></span><br><span class="line">配置选项：</span><br><span class="line"></span><br><span class="line">#### **include**</span><br><span class="line"></span><br><span class="line">*   定义希望被编译文件所在的目录</span><br><span class="line">*   默认值：[&quot;**/*&quot;]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>“include”:[“src/<strong>/*”, “tests/</strong>/*”]</li></ul></li></ul></li></ul></li><li><ul><li>表示任意目录</li></ul></li><li>表示任意文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述示例中，所有 src 目录和 tests 目录下的文件都会被编译</span><br><span class="line"></span><br><span class="line">#### **exclude**</span><br><span class="line"></span><br><span class="line">*   定义需要排除在外的目录</span><br><span class="line">*   默认值：[“node_modules”, “bower_components”, “jspm_packages”]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>“exclude”: [“./src/hello/**/*”]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述示例中，src 下 hello 目录下的文件都不会被编译</span><br><span class="line"></span><br><span class="line">#### **extends**</span><br><span class="line"></span><br><span class="line">*   定义被继承的配置文件</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>“extends”: “./configs/base”<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述示例中，当前配置文件中会自动包含 config 目录下 base.json 中的所有配置信息</span><br><span class="line"></span><br><span class="line">#### **files**</span><br><span class="line"></span><br><span class="line">*   指定被编译文件的列表，**只有需要编译的文件少时才会用到**</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>“files”: [<br>“core.ts”,<br>“sys.ts”,<br>“types.ts”,<br>“scanner.ts”,<br>“parser.ts”,<br>“utilities.ts”,<br>“binder.ts”,<br>“checker.ts”,<br>“tsc.ts”<br>]</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*   列表中的文件都会被 TS 编译器所编译</span><br><span class="line"></span><br><span class="line">#### compilerOptions</span><br><span class="line"></span><br><span class="line">*   编译选项是配置文件中非常重要也比较复杂的配置选项</span><br><span class="line">*   在 compilerOptions 中包含多个子选项，用来完成对编译的配置</span><br><span class="line"></span><br><span class="line">项目选项：</span><br><span class="line"></span><br><span class="line">*   target</span><br><span class="line">    </span><br><span class="line">    *   **设置 ts 代码编译的目标版本**（一般是es2015）</span><br><span class="line">        </span><br><span class="line">    *   可选值：</span><br><span class="line">        </span><br><span class="line">        *   ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</span><br><span class="line">        *   </span><br><span class="line">    *   示例：</span><br><span class="line">        </span><br><span class="line">        *   ```</span><br><span class="line">            &quot;compilerOptions&quot;: &#123;</span><br><span class="line">                &quot;target&quot;: &quot;ES6&quot;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><pre><code>*   如上设置，我们所编写的 ts 代码将会被编译为 ES6 版本的 js 代码</code></pre><ul><li>lib<ul><li>指定代码运行时所包含的库（宿主环境）</li><li>可选值：（在前端代码中不需要设置lib，默认值是浏览器的运行环境）<ul><li>  ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost …</li></ul></li><li>示例：<ul><li>```<br>  “compilerOptions”: {<pre><code>  &quot;target&quot;: &quot;ES6&quot;,  &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],  &quot;outDir&quot;: &quot;dist&quot;,  &quot;outFile&quot;: &quot;dist/aa.js&quot;</code></pre>  }  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   module</span><br><span class="line">    </span><br><span class="line">    *   **设置编译后代码使用的模块化系统**（一般是es2015）</span><br><span class="line">        </span><br><span class="line">    *   可选值：</span><br><span class="line">        </span><br><span class="line">        *   CommonJS、UMD、AMD、System、ES2020、ESNext、None</span><br><span class="line">    *   示例：</span><br><span class="line">        </span><br><span class="line">        *   ```</span><br><span class="line">            &quot;compilerOptions&quot;: &#123;</span><br><span class="line">                &quot;module&quot;: &quot;CommonJS&quot;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>outDir<ul><li><strong>编译后文件的所在目录</strong></li><li>默认情况下，编译后的 js 文件会和 ts 文件位于相同的目录，设置 outDir 后可以改变编译后文件的位置</li><li>示例：<ul><li>```<br>  “compilerOptions”: {<pre><code>  &quot;outDir&quot;: &quot;./dist&quot;</code></pre>  }  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            </span><br><span class="line">        *   设置后编译后的 js 文件将会生成到 dist 目录</span><br><span class="line">    </span><br><span class="line">*   outFile</span><br><span class="line">    </span><br><span class="line">    *   将所有的文件编译为一个 js 文件</span><br><span class="line">        </span><br><span class="line">    *   **默认会将所有的编写在全局作用域中的代码合并为一个 js 文件**，如果 module 制定了 None、System 或 AMD 则会将模块一起合并到文件之中</span><br><span class="line">        </span><br><span class="line">    *   示例：</span><br><span class="line">        </span><br><span class="line">        *   ```</span><br><span class="line">            &quot;compilerOptions&quot;: &#123;</span><br><span class="line">                &quot;outFile&quot;: &quot;dist/app.js&quot;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>rootDir<ul><li>指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过 rootDir 可以手动指定根目录</li><li>示例：<ul><li>```<br>  “compilerOptions”: {<pre><code>  &quot;rootDir&quot;: &quot;./src&quot;</code></pre>  }  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   allowJs</span><br><span class="line">    </span><br><span class="line">    *   是否对 js 文件编译</span><br><span class="line">    </span><br><span class="line">*   checkJs</span><br><span class="line">    </span><br><span class="line">    *   是否对 js 文件进行检查</span><br><span class="line">        </span><br><span class="line">    *   示例：</span><br><span class="line">        </span><br><span class="line">        *   ```</span><br><span class="line">            &quot;compilerOptions&quot;: &#123;</span><br><span class="line">                &quot;allowJs&quot;: true,</span><br><span class="line">                &quot;checkJs&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>removeComments<ul><li>  是否删除注释</li><li>默认值：false</li></ul></li><li>noEmit<ul><li>  不对代码进行编译</li><li>默认值：false</li></ul></li><li>sourceMap<ul><li>  是否生成 sourceMap</li><li>默认值：false</li></ul></li><li>严格检查<ul><li>strict<ul><li>  启用所有的严格检查，默认值为 true，设置后相当于开启了所有的严格检查</li></ul></li><li><strong>alwaysStrict</strong>（默认为false）<ul><li>  总是以严格模式对代码进行编译，设置编译后的文件</li><li>  有export和import，自动进入严格模式</li></ul></li><li>noImplicitAny<ul><li>  禁止隐式的 any 类型</li></ul></li><li>noImplicitThis<ul><li>  禁止类型不明确的 this</li><li>  函数的this和函数的直接调用方式有关</li><li>  在函数中调用，this表示window</li><li>  在方法中调用，this表示调用方法的对象</li><li>  严格模式下，this有一些不一样</li></ul></li><li>strictBindCallApply<ul><li>  严格检查 bind、call 和 apply 的参数列表</li></ul></li><li>strictFunctionTypes<ul><li>  严格检查函数的类型</li></ul></li><li>strictNullChecks<ul><li>  严格的空值检查</li></ul></li><li>strictPropertyInitialization<ul><li>  严格检查属性是否初始化</li></ul></li></ul></li><li>额外检查<ul><li>noFallthroughCasesInSwitch<ul><li>  检查 switch 语句包含正确的 break</li></ul></li><li>noImplicitReturns<ul><li>  检查函数没有隐式的返回值</li></ul></li><li>noUnusedLocals<ul><li>  检查未使用的局部变量</li></ul></li><li>noUnusedParameters<ul><li>  检查未使用的参数</li></ul></li></ul></li><li>高级<ul><li>allowUnreachableCode<ul><li>  检查不可达代码</li><li>可选值：<ul><li>  true，忽略不可达代码</li><li>  false，不可达代码将引起错误</li></ul></li></ul></li><li>noEmitOnError<ul><li>  有错误的情况下不进行编译</li><li>  默认值：false</li></ul></li></ul></li></ul><ol start="3"><li>TypeScript 打包</li></ol><hr><h3 id="webpack-整合"><a href="#webpack-整合" class="headerlink" title="webpack 整合"></a>webpack 整合</h3><p>通常情况下，实际开发中我们都需要使用构建工具对代码进行打包；</p><p>TS 同样也可以结合构建工具一起使用，下边以 webpack 为例介绍一下如何结合构建工具使用 TS；</p><p>步骤如下：</p><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>进入项目根目录，执行命令 <code>npm init -y</code>，创建 package.json 文件</p><h4 id="下载构建工具"><a href="#下载构建工具" class="headerlink" title="下载构建工具"></a>下载构建工具</h4><p>命令如下：</p><p><code>npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin</code></p><p>共安装了 7 个包:</p><ul><li>  webpack：构建工具 webpack</li><li>  webpack-cli：webpack 的命令行工具</li><li>  webpack-dev-server：webpack 的开发服务器</li><li>  typescript：ts 编译器</li><li>  ts-loader：ts 加载器，用于在 webpack 中编译 ts 文件</li><li>  html-webpack-plugin：webpack 中 html 插件，用来自动创建 html 文件</li><li>  clean-webpack-plugin：webpack 中的清除插件，每次构建都会先清除目录</li></ul><h4 id="配置-webpack"><a href="#配置-webpack" class="headerlink" title="配置 webpack"></a>配置 webpack</h4><p>根目录下创建 webpack 的@配置文件<code>webpack.config.js</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">   optimization:&#123;</span><br><span class="line">       minimize: false // 关闭代码压缩，可选</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   entry: &quot;./src/index.ts&quot;,</span><br><span class="line"></span><br><span class="line">   devtool: &quot;inline-source-map&quot;,</span><br><span class="line"></span><br><span class="line">   devServer: &#123;</span><br><span class="line">       contentBase: &#x27;./dist&#x27;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   output: &#123;</span><br><span class="line">       path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">       filename: &quot;bundle.js&quot;,</span><br><span class="line">       environment: &#123;</span><br><span class="line">           arrowFunction: false // 关闭webpack的箭头函数，可选</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   resolve: &#123;</span><br><span class="line">       extensions: [&quot;.ts&quot;, &quot;.js&quot;]</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   module: &#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">               test: /\.ts$/,</span><br><span class="line">               use: &#123;</span><br><span class="line">                   loader: &quot;ts-loader&quot;     </span><br><span class="line">               &#125;,</span><br><span class="line">               exclude: /node_modules/</span><br><span class="line">           &#125;</span><br><span class="line">       ]</span><br><span class="line">   &#125;,</span><br><span class="line"></span><br><span class="line">   plugins: [</span><br><span class="line">       new CleanWebpackPlugin(),</span><br><span class="line">       new HtmlWebpackPlugin(&#123;</span><br><span class="line">           title:&#x27;TS测试&#x27;</span><br><span class="line">       &#125;),</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="配置-TS-编译选项"><a href="#配置-TS-编译选项" class="headerlink" title="配置 TS 编译选项"></a>配置 TS 编译选项</h4><p>根目录下创建 tsconfig.json，配置可以根据自己需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;compilerOptions&quot;: &#123;</span><br><span class="line">       &quot;target&quot;: &quot;ES2015&quot;,</span><br><span class="line">       &quot;module&quot;: &quot;ES2015&quot;,</span><br><span class="line">       &quot;strict&quot;: true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修改-package-json-配置"><a href="#修改-package-json-配置" class="headerlink" title="修改 package.json 配置"></a>修改 package.json 配置</h4><p>修改 package.json 添加如下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   &quot;scripts&quot;: &#123;</span><br><span class="line">       &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">       &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">       &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="项目使用"><a href="#项目使用" class="headerlink" title="项目使用"></a>项目使用</h4><p>在 src 下创建 ts 文件，并在并命令行执行<code>npm run build</code>对代码进行编译；</p><p>或者执行<code>npm start</code>来启动开发服务器；</p><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>除了 webpack，开发中还经常需要结合 babel 来对代码进行转换；</p><p>以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将 babel 引入到项目中；</p><blockquote><p>虽然 TS 在编译时也支持代码转换，但是只支持简单的代码转换；</p><p>对于例如：Promise 等 ES6 特性，TS 无法直接转换，这时还要用到 babel 来做转换；</p></blockquote><p>安装依赖包：</p><p><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></p><p>共安装了 4 个包，分别是：</p><ul><li>@babel/core：babel 的核心工具</li><li>@babel/preset-env：babel 的预定义环境</li><li>@babel-loader：babel 在 webpack 中的加载器</li><li>core-js：core-js 用来使老版本的浏览器支持新版 ES 语法</li></ul><p>修改 webpack.config.js 配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.ts$/,</span><br><span class="line">            use: [</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;,</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        presets: [</span><br><span class="line">                            [</span><br><span class="line">                                &quot;@babel/preset-env&quot;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;targets&quot;:&#123;</span><br><span class="line">                                        &quot;chrome&quot;: &quot;58&quot;,</span><br><span class="line">                                        &quot;ie&quot;: &quot;11&quot;</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    &quot;corejs&quot;:&quot;3&quot;,</span><br><span class="line">                                    &quot;useBuiltIns&quot;: &quot;usage&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    loader: &quot;ts-loader&quot;,</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如此一来，使用 ts 编译后的文件将会再次被 babel 处理；</p><p>使得代码可以在大部分浏览器中直接使用；</p><p>同时可以在配置选项的 targets 中指定要兼容的浏览器版本；</p><ol start="4"><li>面向对象</li></ol><hr><p>要想面向对象，操作对象，首先便要拥有对象；</p><p>要创建对象，必须要先定义类，所谓的类可以理解为对象的模型；</p><p>程序中可以根据类创建指定类型的对象；</p><p>举例来说：</p><p>可以通过 Person 类来创建人的对象，通过 Dog 类创建狗的对象，不同的类可以用来创建不同的对象；</p><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &#123;</span><br><span class="line">    属性名: 类型;</span><br><span class="line">    </span><br><span class="line">    constructor(参数: 类型)&#123;</span><br><span class="line">        this.属性名 = 参数;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    方法名()&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        console.log(`大家好，我是$&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const p = new Person(&#x27;孙悟空&#x27;, 18);</span><br><span class="line">p.sayHello();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>可以使用<code>constructor</code>定义一个构造器方法；</p><blockquote><p><strong>注 1：在 TS 中只能有一个构造器方法！</strong></p></blockquote><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class C&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时也可以直接将属性定义在构造函数中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    constructor(public name: string, public age: number) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面两种定义方法是完全相同的！</p><p><strong>注 2：子类继承父类时，必须调用父类的构造方法（如果子类中也定义了构造方法）！</strong></p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    protected num: number;</span><br><span class="line">    constructor(num: number) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class X extends A &#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    constructor(num: number, name: string) &#123;</span><br><span class="line">        super(num);</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果在 X 类中不调用<code>super</code>将会报错！</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p><p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在 TS 中可以对属性的权限进行设置</p><ul><li>静态属性（static）：<ul><li>  声明为 static 的属性或方法不再属于实例，而是属于类的属性；</li></ul></li><li>只读属性（readonly）：<ul><li>  如果在声明属性时添加一个 readonly，则属性便成了只读属性无法修改</li></ul></li><li>TS 中属性具有三种修饰符：<ul><li>  public（默认值），可以在类、子类和对象中修改</li><li>  protected ，可以在类、子类中修改</li><li>  private ，可以在类中修改</li></ul></li></ul><p>示例：</p><p>public：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    public name: string; // 写或什么都不写都是public</span><br><span class="line">    public age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name; // 可以在类中修改</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        console.log(`大家好，我是$&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.name = name; //子类中可以修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Person(&#x27;孙悟空&#x27;, 18);</span><br><span class="line">p.name = &#x27;猪八戒&#x27;;// 可以通过对象修改</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>protected：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    protected name: string;</span><br><span class="line">    protected age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name; // 可以修改</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        console.log(`大家好，我是$&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.name = name; //子类中可以修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Person(&#x27;孙悟空&#x27;, 18);</span><br><span class="line">p.name = &#x27;猪八戒&#x27;;// 不能修改</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>private：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    private age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name; // 可以修改</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayHello()&#123;</span><br><span class="line">        console.log(`大家好，我是$&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Person&#123;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.name = name; //子类中不能修改</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Person(&#x27;孙悟空&#x27;, 18);</span><br><span class="line">p.name = &#x27;猪八戒&#x27;;// 不能修改</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="属性存取器"><a href="#属性存取器" class="headerlink" title="属性存取器"></a>属性存取器</h3><p>对于一些不希望被任意修改的属性，可以将其设置为 private</p><p>直接将其设置为 private 将导致无法再通过对象修改其中的属性</p><p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p><p>读取属性的方法叫做 setter 方法，设置属性的方法叫做 getter 方法</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private _name: string;</span><br><span class="line"></span><br><span class="line">    constructor(name: string)&#123;</span><br><span class="line">        this._name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get name()&#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set name(name: string)&#123;</span><br><span class="line">        this._name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p1 = new Person(&#x27;孙悟空&#x27;);</span><br><span class="line">// 实际通过调用getter方法读取name属性</span><br><span class="line">console.log(p1.name);</span><br><span class="line">// 实际通过调用setter方法修改name属性 </span><br><span class="line">p1.name = &#x27;猪八戒&#x27;; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p><p>静态属性（方法）使用 static 开头</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Tools&#123;</span><br><span class="line">    static PI = 3.1415926;</span><br><span class="line">    </span><br><span class="line">    static sum(num1: number, num2: number)&#123;</span><br><span class="line">        return num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Tools.PI);</span><br><span class="line">console.log(Tools.sum(123, 456));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在类中，使用 this 表示当前对象</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承时面向对象中的又一个特性</p><p>通过继承可以将其他类中的属性和方法引入到当前类中</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    bark()&#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125;在汪汪叫！`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog(&#x27;旺财&#x27;, 4);</span><br><span class="line">dog.bark();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过继承可以在不修改类的情况下完成对类的扩展</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run()&#123;</span><br><span class="line">        console.log(`父类中的run方法！`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    bark()&#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125;在汪汪叫！`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run()&#123;</span><br><span class="line">        console.log(`子类中的run方法，会重写父类中的run方法！`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog(&#x27;旺财&#x27;, 4);</span><br><span class="line">dog.bark();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在子类中可以使用 super 来完成对父类的引用</strong></p><h3 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h3><p>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal&#123;</span><br><span class="line">  abstract run(): void;</span><br><span class="line">  bark()&#123;</span><br><span class="line">      console.log(&#x27;动物在叫~&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animals&#123;</span><br><span class="line">  run()&#123;</span><br><span class="line">      console.log(&#x27;狗在跑~&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 abstract 开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现;</p><h3 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h3><p>接口的作用类似于抽象类，不同点在于：接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法；</p><p>接口主要负责定义一个类的结构，接口可以去限制一个对象的接口：对象只有包含接口中定义的所有属性和方法时才能匹配接口；</p><p>同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性；</p><p>示例（检查对象类型）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    sayHello():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn(per: Person)&#123;</span><br><span class="line">    per.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(&#123;name:&#x27;孙悟空&#x27;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例（实现）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">   name: string;</span><br><span class="line">   sayHello():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student implements Person&#123;</span><br><span class="line">   constructor(public name: string) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   sayHello() &#123;</span><br><span class="line">       console.log(&#x27;大家好，我是&#x27;+this.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>泛型（Generic）</li></ol><hr><p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定）；</p><p>此时泛型便能够发挥作用；</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test(arg: any): any&#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上例中，test 函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的；</p><p>由于类型不确定所以参数和返回值均使用了 any，但是很明显这样做是不合适的：</p><p>首先使用 any 会关闭 TS 的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型；</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><h4 id="创建泛型函数"><a href="#创建泛型函数" class="headerlink" title="创建泛型函数"></a>创建泛型函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test&lt;T&gt;(arg: T): T&#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的<code>&lt;T&gt;</code>就是泛型；</p><p>T 是我们给这个类型起的名字（不一定非叫 T），设置泛型后即可在函数中使用 T 来表示该类型；</p><p>所以泛型其实很好理解，就表示某个类型；</p><p>那么如何使用上边的函数呢？</p><h4 id="使用泛型函数"><a href="#使用泛型函数" class="headerlink" title="使用泛型函数"></a>使用泛型函数</h4><h5 id="方式一（直接使用）："><a href="#方式一（直接使用）：" class="headerlink" title="方式一（直接使用）："></a>方式一（直接使用）：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test(10)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用时可以直接传递参数使用，类型会由 TS 自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p><h5 id="方式二（指定类型）："><a href="#方式二（指定类型）：" class="headerlink" title="方式二（指定类型）："></a>方式二（指定类型）：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test&lt;number&gt;(10)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以在函数后手动指定泛型；</p><h4 id="函数中声明多个泛型"><a href="#函数中声明多个泛型" class="headerlink" title="函数中声明多个泛型"></a>函数中声明多个泛型</h4><p>可以同时指定多个泛型，泛型间使用逗号隔开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test&lt;T, K&gt;(a: T, b: K): K&#123;</span><br><span class="line">  return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test&lt;number, string&gt;(10, &quot;hello&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用泛型时，完全可以将泛型当成是一个普通的类去使用；</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类中同样可以使用泛型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyClass&lt;T&gt;&#123;</span><br><span class="line">  prop: T;</span><br><span class="line"></span><br><span class="line">  constructor(prop: T)&#123;</span><br><span class="line">      this.prop = prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>除此之外，也可以对泛型的范围进行约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface MyInter&#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test&lt;T extends MyInter&gt;(arg: T): number&#123;</span><br><span class="line">  return arg.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 T extends MyInter 表示泛型 T 必须是 MyInter 的子类，不一定非要使用接口类和抽象类同样适用；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/20/web%E5%89%8D%E7%AB%AF/Typescript/Typescript/"/>
      <url>/2022/12/20/web%E5%89%8D%E7%AB%AF/Typescript/Typescript/</url>
      
        <content type="html"><![CDATA[<h1 id="1-typescript介绍"><a href="#1-typescript介绍" class="headerlink" title="1. typescript介绍"></a>1. typescript介绍</h1><h2 id="1-1-什么是typescript？"><a href="#1-1-什么是typescript？" class="headerlink" title="1.1 什么是typescript？"></a>1.1 什么是typescript？</h2><p>TypeScript简称TS<br> TS和JS之间的关系其实就是Less/Sass和CSS之间的关系<br> 就像Less/Sass是对CSS进行扩展一样, TS也是对JS进行扩展<br> 就像Less/Sass最终会转换成CSS一样, 我们编写好的TS代码最终也会换成JS<br> TypeScript是JavaScript的超集，因为它扩展了JavaScript，有JavaScript没有的东西<br> 硬要以父子类关系来说的话，TypeScript是JavaScript子类，继承的基础上去扩展</p><h2 id="1-2-为什么需要TypeScript"><a href="#1-2-为什么需要TypeScript" class="headerlink" title="1.2 为什么需要TypeScript?"></a>1.2 为什么需要TypeScript?</h2><p>简单来说就是因为JavaScript是弱类型, 很多错误只有在运行时才会被发现<br>而TypeScript提供了一套静态检测机制, 可以帮助我们在编译时就发现错误</p><h2 id="1-3-TypeScript特点"><a href="#1-3-TypeScript特点" class="headerlink" title="1.3. TypeScript特点"></a>1.3. TypeScript特点</h2><p>支持最新的JavaScript新特性<br>支持代码静态检查<br>支持诸如C,C++,Java,Go等后端语言中的特性 (枚举、泛型、类型转换、命名空间、声明文件、类、接口等)</p><h2 id="2-搭建typescript学习环境"><a href="#2-搭建typescript学习环境" class="headerlink" title="2. 搭建typescript学习环境"></a>2. 搭建typescript学习环境</h2><h2 id="2-1-安装最新版typescript"><a href="#2-1-安装最新版typescript" class="headerlink" title="2.1. 安装最新版typescript"></a>2.1. 安装最新版typescript</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><p>参考文献：</p><p><a href="https://www.jianshu.com/p/4767d2cd77a9">1</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/19/Java%E6%A1%86%E6%9E%B6/%E4%BA%86%E8%A7%A3/"/>
      <url>/2022/12/19/Java%E6%A1%86%E6%9E%B6/%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVAEE与JAVA有何区别？"><a href="#JAVAEE与JAVA有何区别？" class="headerlink" title="JAVAEE与JAVA有何区别？"></a>JAVAEE与JAVA有何区别？</h2><p>Java分三个版本：Java SE(标准版)、Java EE(企业版)、Java ME(微型版)</p><p>其中SE就是大家学的Java基础，EE是公司最常用的用于网站开发(PC端)，ME用于移动端开发，现在熟悉的安卓系统就是用JAVAME开发的。乐字节。</p><p>Java既可以被编译，也可以被解释。通过编译器，可以把Java 程序翻译成一种中间代码 - 称为字节码 - 可以被Java解释器解释的独立于平台的代码。通过解释器，每条Java字节指令被分析，然后在计算机上运行。只需编译一次，程序运行时解释执行。</p><p>Java不同于一般的编译执行计算机语言和解释执行计算机语言。它首先将源代码编译成二进制字节码(bytecode)，然后依赖各种不同平台上的虚拟机来解释执行字节码，从而实现了“一次编译、到处执行”的跨平台特性。</p><p>或者用一种更总结性的话术来表达就是：java跨平台就是能在不同的环境(主要是操作系统)上运行java程序！</p><p>这也是Java为什么这么火，为什么这么多年依然屹立不倒且久盛而不衰的原因。一个无视于平台，跨平台的语言，必然有长久的生命力。而作为程序员来说，职业发展的长远规划，选择Java远比选择其他无法实现跨平台的语言，更有长远价值(包括现在非常流行的H5语言，也是一种跨平台语言，“一次设计，普遍适用。一次编写，随处部署”，这个后续会在其他文章中具体说一下)。</p><p>相似的JAVAEE、javase、javame可简单的总结为三点：</p><p>Java SE 是做电脑上运行的软件。</p><p>Java EE 是用来做网站的-(我们常见的JSP技术)</p><p>Java ME 是做手机软件的。</p><p>回顾过去十五年的成果，Java一直是数一数二的。Java已经占据了曾经C语言所拥有的地位，而C语言在Java开始流行之前一直是最受关注的语言。TIOBE指数也曾宣布今年是Java语言年，而十年之前，Java就已然获此殊荣。非常期待Java能够获得另一个十年当中的年度最佳编程语言。 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/19/Java%E6%A1%86%E6%9E%B6/Spring/"/>
      <url>/2022/12/19/Java%E6%A1%86%E6%9E%B6/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="1、什么是Spring"><a href="#1、什么是Spring" class="headerlink" title="1、什么是Spring?"></a>1、什么是Spring?</h2><blockquote><p>Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。 Spring最根本的使命是<strong>解决企业级应用开发的复杂性，即简化Java开发</strong>。 Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是<strong>依赖注入</strong>（dependency injection，DI）和<strong>面向切面编程</strong>（aspectorientedprogramming，AOP）。</p></blockquote><p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略：</p><ul><li>基于POJO的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/17/111/"/>
      <url>/2022/12/17/111/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字体</title>
      <link href="/2022/12/16/web%E5%89%8D%E7%AB%AF/2_CSS/%E5%AD%97%E4%BD%93/"/>
      <url>/2022/12/16/web%E5%89%8D%E7%AB%AF/2_CSS/%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h2 id="1-字体相关的样式"><a href="#1-字体相关的样式" class="headerlink" title="1. 字体相关的样式"></a>1. 字体相关的样式</h2><p>我们前面讲过的两个属性</p><ul><li><code>color</code>用来设置字体颜色</li><li><code>font-size</code>设置字体大小<ul><li><code>em</code>相当与当前元素的一个<code>font-size</code></li><li><code>rem</code>相对于根元素的一个<code>font-size</code></li></ul></li></ul><p>当然，字体的属性并不止这些</p><h2 id="2-font-family（字体格式）"><a href="#2-font-family（字体格式）" class="headerlink" title="2. font-family（字体格式）"></a>2. font-family（字体格式）</h2><p><code>font-family</code>字体族（字体的格式）</p><ul><li><code>serif</code>衬线字体</li><li><code>sans-serif</code>非衬线字体</li><li><code>monspace</code>等宽字体</li><li><code>cursive</code>手写体</li><li><code>fantasy</code>梦幻字体</li></ul><p>上述字体均不表示的某种字体，而是字体的分类</p><p>我们经常使用的一些字体，如<code>雅黑</code>，<code>黑体</code>，<code>楷体</code>，<code>宋体</code>，<code>Consolas</code>等，才是具体的某种字体</p><p>也就是说。<code>font-family</code>指定字体的类别，浏览器会自动使用该类别下的字体</p><p><code>font-family</code>可以同时指定多个字体，多个字体间使用<code>,</code>隔开</p><p>字体生效是优先选择第一个，第一个无法使用则使用第二个，以此类推</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: <span class="string">&quot;Courier New&quot;</span>,Courier,monspace;</span><br></pre></td></tr></table></figure><h2 id="3-几种字体"><a href="#3-几种字体" class="headerlink" title="3. 几种字体"></a>3. 几种字体</h2><p>随便看看就好</p><ul><li><p>手写体</p></li><li><p>艺术体</p></li><li><p>乱码字体</p></li><li><p>中文字体</p></li></ul><h2 id="4-font-face"><a href="#4-font-face" class="headerlink" title="4. @font-face"></a>4. @font-face</h2><p>我们除了可以使用系统自带的字体样式外，还可以在服务器自定义字体位置</p><p><code>@font-face</code>可以将服务器中的字体直接提供给用户去使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">  <span class="comment">/* 指定字体名字 */</span></span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;myFont1&quot;</span>;</span><br><span class="line">  <span class="comment">/* 服务器中字体路径 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;/font/ZCOOLKuaiLe-Regular.woff&quot;</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&quot;/font/ZCOOLKuaiLe-Regular.otf&quot;</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&quot;/font/ZCOOLKuaiLe-Regular.ttf&quot;</span>) <span class="built_in">format</span>(<span class="string">&quot;truetype&quot;</span>); <span class="comment">/* 指定字体格式，一般不写 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">color</span>: salmon;</span><br><span class="line">  <span class="attribute">font-family</span>: myFont1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><ol><li>加载速度：受网路速度影响，可能会出现字体闪烁一下变成最终的字体</li><li>版权：有些字体是商用收费的，需要注意</li><li>字体格式：字体格式也有很多种（woff，otf，ttf），未必兼容，可能需要指定多个</li></ol><h2 id="5-图标字体（iconfont）"><a href="#5-图标字体（iconfont）" class="headerlink" title="5. 图标字体（iconfont）"></a>5. 图标字体（iconfont）</h2><h2 id="6-行高"><a href="#6-行高" class="headerlink" title="6. 行高"></a>6. 行高</h2><p><strong>行高</strong><code>line height</code></p><p>文字占有的实际高度，可以通过<code>line-height</code>来设置行高</p><ul><li>可以直接指定一个大小<code>px</code>/<code>em</code></li><li>也可以直接为行高设置一个小数(字体大小的倍数)</li></ul><p>行高经常还用来设置文字的行间距：<code>行间距 = 行高 - 字体大小</code></p><p><strong>字体框</strong></p><p>字体框就是字体存在的格子，设置<code>font-size</code>实际上就是在设置字体框的高度</p><p>行高会在字体框的上下平均分配</p><p><strong>示例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> black solid;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="comment">/* line-height: 100px; */</span></span><br></pre></td></tr></table></figure><p>不指定行高时，<code>content</code>高度<code>131.556px</code>：说明<code>line-height</code>默认值大约时<code>1.31</code>~`1.32`（倍数）</p><p>当指定<code>context</code>高度<code>99.556px</code>：少了<code>0.444px</code>,并且字母<code>p</code>下面溢出</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    bordder: <span class="number">1px</span> black solid;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是字体设置了字体大小和行高相同导致的；</p><p><strong>字体的简写属性</strong></p><p><code>font</code>可以设置字体相关的所有属性：</p><p><code>font: font-style font-variant font-weight font-size/line-height font-family</code></p><p>其中某些值可以不写，会用默认值</p><p><strong>默认值</strong></p><table><thead><tr><th>属性</th><th>默认值</th><th>其他常用值</th></tr></thead><tbody><tr><td>font-style</td><td>normal</td><td>italic</td></tr><tr><td>font-variant</td><td>normal</td><td>small-caps</td></tr><tr><td>font-weight</td><td>normal</td><td>bold</td></tr><tr><td>font-size</td><td>medium</td><td>small、large</td></tr><tr><td>line-height</td><td>normal</td><td></td></tr><tr><td>font-family</td><td>取决于浏览器</td><td></td></tr></tbody></table><p><strong>示例1</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* font-size: 50px;</span></span><br><span class="line"><span class="comment">font-family: &#x27;Courier New&#x27;, Courier, monospace; */</span></span><br><span class="line"><span class="attribute">font</span>: <span class="number">50px</span> <span class="string">&quot;Courier New&quot;</span>, Courier, monospace;</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* small-caps值设置小型大写字母字体，所有小写变大写，同时字体尺寸更小（了解即可） */</span></span><br><span class="line"><span class="attribute">font</span>: bold small-caps italic <span class="number">50px</span> <span class="string">&quot;Courier New&quot;</span>, Courier, monospace;</span><br></pre></td></tr></table></figure><p>注意：简写属性省略的值会使用默认值，所以会覆盖前面的非简写属性（不仅仅对于字体而言）</p><h2 id="7-文本对齐方式"><a href="#7-文本对齐方式" class="headerlink" title="7. 文本对齐方式"></a>7. 文本对齐方式</h2><p><strong>水平对齐</strong></p><p><code>text-align</code>文本的水平对齐</p><table><thead><tr><th><code>text-align</code>属性值</th><th>对齐方式说明</th></tr></thead><tbody><tr><td>left</td><td>左侧对齐</td></tr><tr><td>right</td><td>右侧对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr><tr><td>justify</td><td>两端对齐</td></tr></tbody></table><p><code>left</code>左侧对齐（默认）</p><p><code>right</code>右侧对齐</p><p><code>center</code>居中对齐</p><p><code>justify</code>两端对齐</p><p><strong>垂直对齐</strong></p><p><code>vertical-align</code>设置元素垂直对齐的方式</p><table><thead><tr><th><code>vertical-align</code>属性值</th><th>对齐方式说明</th></tr></thead><tbody><tr><td>baseline</td><td>基线对齐</td></tr><tr><td>top</td><td>顶部对齐</td></tr><tr><td>bottom</td><td>底部对齐</td></tr><tr><td>middle</td><td>居中对齐</td></tr></tbody></table><p><code>baseline</code>基线对齐</p><p><code>top</code>顶部对齐</p><p><code>bottom</code>底部对齐</p><p><code>middle</code>居中对齐</p><p>这里的居中对齐高度 = 基线高度 + x的高度 / 2</p><p>这种居中对齐高度并非实际上的居中对齐，一般也不会用这种方式对文字进行垂直方向的对齐</p><p><code>vertical-align</code>还可以设置px值设置垂直对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vertical-align</span>: <span class="number">10px</span>;</span><br></pre></td></tr></table></figure><h2 id="8-其他的文本样式"><a href="#8-其他的文本样式" class="headerlink" title="8. 其他的文本样式"></a>8. 其他的文本样式</h2><p><strong>设置文本修饰</strong></p><p><code>text-decoration</code>设置文本修饰</p><table><thead><tr><th>text-decoration属性值</th><th>文本修饰方式说明</th></tr></thead><tbody><tr><td>none</td><td>什么都没有</td></tr><tr><td>underline</td><td>下划线</td></tr><tr><td>line-through</td><td>删除线</td></tr><tr><td>overline</td><td>上划线</td></tr></tbody></table><p><code>none</code>什么都没有</p><p><code>underline</code>下划线</p><p><code>line-through</code>删除线</p><p><code>overline</code>上划线</p><p><strong>示例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: 微软雅黑;</span><br><span class="line">    <span class="comment">/*text-decoration: overline;*/</span></span><br><span class="line">    <span class="attribute">text-decoration</span>: underline red dotted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置网页如何处理空白</strong></p><p><code>white-space</code>设置网页如何处理空白</p><table><thead><tr><th>white-space属性值</th><th>设置网页如何处理空白说明</th></tr></thead><tbody><tr><td>normal</td><td>正常</td></tr><tr><td>nowrap</td><td>不换行</td></tr><tr><td>pre</td><td>保留空白</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis; <span class="comment">/*溢出部分文本省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定位的简介</title>
      <link href="/2022/12/14/web%E5%89%8D%E7%AB%AF/2_CSS/%E5%AE%9A%E4%BD%8D%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/12/14/web%E5%89%8D%E7%AB%AF/2_CSS/%E5%AE%9A%E4%BD%8D%E7%9A%84%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="定位的简介"><a href="#定位的简介" class="headerlink" title="定位的简介"></a>定位的简介</h1><p>如果我们要将一个盒子向右上角移动，我们应该怎么实现呢？</p><p>按照我们之前所学知识，可以怎么实现呢？</p><p>应该来说不难，更容易实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="comment">/* 左外边距、上外边距 */</span></span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="comment">/* 上外边距 */</span></span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别给box2和box3添加外边距之后，就可以达到需求效果</p><p>当然也可以使用浮动来解决上述问题，但稍微麻烦一点</p><p>不管怎样，问题也是显而易见。我们实际开发中，页面上的元素可能很多，这样改必然是 牵一发而动全身</p><p>在此之前，我们学习了html和css中的一些内容</p><ol><li>html</li></ol><p>网页的基本结构</p><p>字符集</p><p>html5中的基本结构</p><p>字符实体</p><p>布局标签等</p><ol start="2"><li>css（层叠样式表）</li></ol><p>css的三种引用方法</p><ul><li><p>内联样式表</p></li><li><p>内部样式表</p></li><li><p>外部样式表</p></li></ul><ol start="3"><li><p>选择器</p></li><li><p>盒子模型</p></li><li><p>浮动</p></li><li><p>高度塌陷与BFC</p></li></ol><p>那么仅仅靠我们之前学习的布局知识，不足以轻松应对这种场景</p><p>那么就势必需要一个方便我们处理这种场景的方法，它就是定位</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>定位是一种更加高级的布局手段</p><p>通过定位可以将元素摆放在页面的任意位置</p><p>使<code>position</code> 属性来设置定位</p><table><thead><tr><th><strong>可选值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>static</td><td>不开启定位，元素是静止的，默认值</td></tr><tr><td>relative</td><td>开启元素的相对定位</td></tr><tr><td>absolute</td><td>开启元素的绝对定位</td></tr><tr><td>fixed</td><td>开启元素的固定定位</td></tr><tr><td>sticky</td><td>开启元素的粘滞定位</td></tr></tbody></table><h3 id="1-相对定位和偏移量（offset）"><a href="#1-相对定位和偏移量（offset）" class="headerlink" title="1.相对定位和偏移量（offset）"></a>1.相对定位和偏移量（offset）</h3><p><strong>相对定位</strong></p><p>当元素的position属性值为<code>relative</code>时，则开启了元素的相对定位</p><p><strong>偏移量（offset）</strong></p><p>当元素开启相对定位以后，可以通过偏移量来设置元素的位置</p><table><thead><tr><th><strong>offset属性</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>top</td><td>定位元素和定位位置的上边距离</td></tr><tr><td>bottom</td><td>定位元素和定位位置的下边距离</td></tr><tr><td>left</td><td>定位元素和定位位置的左侧距离</td></tr><tr><td>right</td><td>定位元素和定位位置的右侧距离</td></tr></tbody></table><p>定位元素垂直方向的位置由<code>top</code> 和<code>bottom</code>两个属性控制，通常情况下只会使用其中之一</p><ul><li><code>top</code>z值越大，定位元素越靠下</li><li><code>botton</code>值越大，定位元素靠上</li></ul><p>定位元素水平方向的位置由<code>left</code>和<code>right</code>两个属性控制，</p><p>通常情况下只会使用其中之一</p><ul><li><code>left</code>越大，定位元素越靠右</li><li><code>right</code>越大，定位元素越靠左</li></ul><p>在介绍完相对布局，我们的需求是不是变得so easy！</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="comment">/* 开启相对定位 */</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们给box2设置相对定位，就得到了我们想要的页面效果</p><p>从图中我们可以看出，使用了相对定位后，只会移动自身的布局位置，而不会对已存在的其他元素产生任何影响</p><p>现在我们所举的例子不是很明显，但当页面比较复杂，特别是页面元素很多的时候，其优越就可以大大体现出来。</p><blockquote><p>如果我们直接使用margin移动元素，可能会导致页面其他元素也跟着移动。而相对定位不脱离文档流，所以不会导致其他元素移动</p></blockquote><p><strong>相对定位特点</strong></p><ol><li>当元素开启相对定位以后，如果不设置偏移量元素，则元素不会发生任何改变（这里注意，不仅仅是位置）</li><li>相对定位是参照于元素在文档流中的位置进行定位的（可以理解为相对于自身原始位置）</li><li>相对定位提升元素的层级（表现为可以覆盖其他元素）</li><li>相对定位不会改变元素的性质：块还是块，行内还是行内。</li></ol><blockquote><p>浮动就会改变元素的性质</p></blockquote><p><strong>Q1：如果给 上述三个div都设置相对定位，那么它们的层级关系会是什么样的呢？或者说谁会被覆盖呢？</strong></p><p>A:百闻不如一见，光说不练假把式，我们直接进行验证</p><p>我们看到覆盖关系：box3 &gt;&gt; box2 &gt;&gt; box1</p><p>我们再稍微调整xiabox3和box2的前后位置</p><p>会发现覆盖关系变成了：box2 &gt;&gt; box3 &gt;&gt; box1</p><p>可以大概猜测：在页面文档流中，越靠下的元素开启相对定位后，其层级越高 （这里也只是我个人的揣测，待后续学习中验证）（在后续学习中已得到验证：没有设置层级或层级<code>z-index</code>设置相同值时，优先显示靠下的元素）</p><p><strong>Q2：相对定位的第三特点相对定位会提升元素的层级，是不是就类似于浮动一样脱离了文档流？</strong></p><p>A：我们可以对比下，浮动和相对定位的区别</p><ul><li>参考系不同：浮动的参考系是其父元素；相对定位是相对于自身</li><li>可移动方向不同：浮动只能左右移动；相对定位是上下左右移动</li><li>影响不同：浮动会影响页面布局（包括下方元素位置和高度塌陷问题）；相对定位不会影响页面布局</li><li>性质不同：浮动会改变元素的性质（不再独占一行，其宽高都会被内容撑开）；相对定位不会改变元素的性质</li><li>文字环绕：浮动不会覆盖文字；相对定位可以覆盖位置（这个可以自行验证）</li></ul><p>当然，浮动和相对定位也有相似之处</p><ul><li>浮动和相对定位都是移动位置</li><li>浮动和相对定位不会从父元素中移出（文档流）</li></ul><blockquote><p>它这里的移出指的是什么呢？文档流的移出还是元素本身的移出。但我测试了浮动不会导致元素本身的移出，而相对定位会从父元素中飘出。</p></blockquote><p>可以看出，浮动和相对定位的区别是更多的</p><p>最后回答一点：浮动脱离了文档流，不再占据页面位置；相对定位仍然占据页面位置（所以怎么能够叫脱离文档流呢？）</p><p><strong>Q3：相对定位的第四个特点相对定位不会改变元素的性质：块还是块，行内还是行内，但是上述例子中元素开启相对定位后好像不再独占一行了，这个怎么理解？</strong></p><p>A：相比与浮动元素的特点，相对定位不会改变元素的性质其实是一个相对不容易理解的问题。但其实也不难，可以把相对定位认为是元素的灵魂出窍。其位置发生改变之后，布局并没有产生影响，因为它的肉体（结构）仍然占据着原来的那一个位置。只是其灵魂（内容）发生了移动。</p><p><strong>相对定位的第四个特点中块还是块，行内还是行内，意味着行内元也可以使用相对定位吗？</strong></p><p>A：眼见为实，耳听为虚，直接看实例效果</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>八大排序</title>
      <link href="/2022/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分：排序算法"><a href="#第一部分：排序算法" class="headerlink" title="第一部分：排序算法"></a>第一部分：排序算法</h2><p>基于交换的排序：冒泡排序、快速排序</p><p>基于插入的排序：直接插入排序、希尔排序</p><p>基于选择的排序：简单选择排序、堆排序</p><h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/a5e3abf018e74af8a5c3ac1891fb393a.gif"></p><blockquote><p>冒泡排序的基本思想：</p><p>一趟过程中，前后两个数依次比较，将较大的数字往后推，下一次只需要比较剩下的n-1个数，如此往复 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] Pop(<span class="type">int</span>[] numbers)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numbers.length-<span class="number">1</span>;i++)<span class="comment">//控制轮数，共需要length-1次轮</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;numbers.length-<span class="number">1</span>-i;j++)<span class="comment">//控制每轮的交换次数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[j]&gt;numbers[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp=numbers[j];</span><br><span class="line">                numbers[j]=numbers[j+<span class="number">1</span>];</span><br><span class="line">                numbers[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<strong>最好O(n)、最坏O(n2)、平均O(n2)</strong> 分析：当序列已经是排好序时，则只需要n-1次比较，无需移动元素，当序列为逆序时，则需要n(n-1)/2次比较和移动</p><p>空间复杂度：O(1)</p><p>稳定性：两个相邻的相等元素并不会发生交换，所以<strong>稳定</strong></p><h2 id="二、快速排序"><a href="#二、快速排序" class="headerlink" title="二、快速排序"></a>二、快速排序</h2><h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><ol><li><p>hoare版本</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/2a79b950693e4a51ba7545e55f6a1b09.gif"></p></li><li><p>挖坑法</p></li><li><p>前后指针法（推荐这种写法）</p><blockquote><p>前后指针的思想：</p><ol><li><p>初始时选定prev为序列的开始，cur指针指向prev的后一个位置，同样选择最左边的第一个数字作为key</p></li><li><p>cur先走，找到小于key的值，找到就停下来</p></li><li><p>++prev</p></li><li><p>交换prev和cur为下标的值</p></li><li><p>一直循环重复2 3 4步，停下来后，最后交换key和prev为下标的值</p></li></ol><p>这样key同样到达了正确的位置</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归思想 传入参数，左边界，右边界及数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> leftIndex, <span class="type">int</span> rightIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftIndex &gt;= rightIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> leftIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> rightIndex;</span><br><span class="line">    <span class="comment">//待排序的第一个元素作为基准值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[left];</span><br><span class="line">    <span class="comment">//从左右两边交替扫描，直到left = right</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; left &amp;&amp; arr[right] &gt;= key) &#123;</span><br><span class="line">            <span class="comment">//从右往左扫描，找到第一个比基准值小的元素</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到这种元素将arr[right]放入arr[left]中</span></span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= key) &#123;</span><br><span class="line">            <span class="comment">//从左往右扫描，找到第一个比基准值大的元素</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到这种元素将arr[left]放入arr[right]中</span></span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基准值归位</span></span><br><span class="line">    arr[left] = key;</span><br><span class="line">    <span class="comment">//对基准值左边的元素进行递归排序</span></span><br><span class="line">    quickSort(arr, leftIndex, left - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//对基准值右边的元素进行递归排序。</span></span><br><span class="line">    quickSort(arr, right + <span class="number">1</span>, rightIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h3><ol><li>三数取中法</li><li>递归到小子区间</li></ol><h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><p>时间复杂度：最好O(nlogn) 、最坏O(n^2^) 平均O(<del>n</del>log^n^) 分析：当基准值选取得当，每次都能将序列均匀划分，则能到O(nlogn),这里要用到递归算法的时间复杂度公式：T[N]=2T[N/2]+f(n)。如果基准值每次都是最大或者最小，则会将所有序列划分到一侧，为O(n^2)。</p><p>空间复杂度：O(<del>n</del>log^n^)</p><p>稳定性：所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻</p><h2 id="三、直接插入排序"><a href="#三、直接插入排序" class="headerlink" title="三、直接插入排序"></a>三、直接插入排序</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/00b85e13a79f40a1b508e527b60f1f87.gif"></p><blockquote><p>基本思想：我们平时玩扑克牌时，摸牌阶段的排序就用到了插入排序的思想</p><ol><li><p>当插入第n个元素时，前面的n-1个数已经有序</p></li><li><p>用这第n个数与前面的n-1个数比较，找到要插入的位置，将其插入（原来位置上的数不会被覆盖，因为提前保存了）</p></li><li><p>原来位置上的数据，依次后移</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] InsertSort(<span class="type">int</span>[] a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp=a[i];</span><br><span class="line">        <span class="type">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将temp插入到合适位置</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<strong>最好为O(n)、最坏均为O(n^2) 平均O(n^2)</strong></p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><h2 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/444ef28aec974877aef0525aa7ea5ff3.gif"></p><blockquote><p>基本思想：</p><ol><li><p>先选定一个小于n的数字作为gap，所有距离为gap的数分为一组进行预排序（直接插入排序）</p></li><li><p>再选一个小于gap的数，重复①的操作</p></li><li><p>当gap=1时，相当于整个数组就是一组，再进行一次插入排序即可整体有序</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">int</span>[] ShellSort(<span class="type">int</span>[] a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> gap;</span><br><span class="line">    <span class="keyword">for</span>(gap=a.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap=gap/<span class="number">2</span>)<span class="comment">//最外层循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//以gap距离分组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gap;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+gap;j&lt;a.length;j+=gap)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp=a[j];</span><br><span class="line">                <span class="type">int</span> k=j-gap;</span><br><span class="line">                <span class="keyword">while</span>(k&gt;=<span class="number">0</span>&amp;&amp;temp&lt;a[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    a[k+gap]=a[k];</span><br><span class="line">                    k-=gap;</span><br><span class="line">                &#125;</span><br><span class="line">                a[k+gap]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解就是按不同的分组将数组进行多次排序。</p><p>时间复杂度：<strong>最好O(n) 最坏O(n^2) 平均O(n^1.3)</strong></p><p>空间复杂度：O(1)</p><p>稳定性：不稳定</p><h2 id="五、简单选择排序"><a href="#五、简单选择排序" class="headerlink" title="五、简单选择排序"></a>五、简单选择排序</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/8e90e3d6567746f7a88ec1b8c76129e2.gif"></p><blockquote><p>基本思想：</p><p>每次从数组中选出最大的或者最小的，存放在数组的最右边或者最左边，直到全部有序 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">simpleSelectionSort</span><span class="params">(<span class="type">int</span>[] a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> max=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[max]&gt;a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                max=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp=a[i];</span><br><span class="line">        a[i]=a[max];</span><br><span class="line">        a[max]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<strong>最好最坏平均都为O(n^2)</strong></p><p>空间复杂度：O(1)</p><p>稳定性：不稳定</p><h2 id="六、堆排序"><a href="#六、堆排序" class="headerlink" title="六、堆排序"></a>六、堆排序</h2><blockquote><p>基本思想：</p><p>1、将待排序的序列构造成一个大堆，根据大堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素；</p><p>2、将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大堆；</p><p>3、重复步骤2，如此反复，从第一次构建大堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大堆的尾部。最后，就得到一个有序的序列了。</p><p>小结论：</p><p>排升序，建大堆</p><p>排降序，建小堆</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**重要性质：对于大顶堆：arr[i] &gt;= arr[2i + 1] &amp;&amp; arr[i] &gt;= arr[2i + 2]</span></span><br><span class="line"><span class="comment">           对于小顶堆：arr[i] &lt;= arr[2i + 1] &amp;&amp; arr[i] &lt;= arr[2i + 2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       思路：先构造大顶堆，然后交换根节点和数组最后一个数，重复步骤，</span></span><br><span class="line"><span class="comment">            大顶堆的构造关键，由下往上遍历</span></span><br><span class="line"><span class="comment">     时间复杂度O(nlogn)**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">null</span> || a.length==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        heapify(a,<span class="number">0</span>,len);</span><br><span class="line">        swap(a,<span class="number">0</span>,i);</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建大顶堆</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// 先根据堆性质，找出它左右节点的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 默认当前节点（父节点）是最大值。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">largestIndex</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="comment">//这里注意两个条件书写的先后顺序，若顺序相反则会导致数组下标溢出，因为如果left不满足</span></span><br><span class="line">    <span class="comment">//小于len的条件，则不会判断后面的条件，就不会导致数组溢出</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largestIndex]) &#123;</span><br><span class="line">        <span class="comment">// 如果有左节点，并且左节点的值更大，更新最大值的索引</span></span><br><span class="line">        largestIndex = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largestIndex]) &#123;</span><br><span class="line">        <span class="comment">// 如果有右节点，并且右节点的值更大，更新最大值的索引</span></span><br><span class="line">        largestIndex = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largestIndex != i) &#123;</span><br><span class="line">        <span class="comment">// 如果最大值不是当前非叶子节点的值，那么就把当前节点和最大值的子节点值互换</span></span><br><span class="line">        swap(arr, i, largestIndex);</span><br><span class="line">        <span class="comment">// 因为互换之后，子节点的值变了，如果该子节点也有自己的子节点，仍需要再次调整。</span></span><br><span class="line">        heapify(arr, largestIndex, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp=arr[j];</span><br><span class="line">    arr[j]=arr[i];</span><br><span class="line">    arr[i]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<strong>最好最坏平均 都为O(nlogn)</strong></p><p>空间复杂度：O(1)</p><p>稳定性：不稳定</p><h2 id="七、归并排序"><a href="#七、归并排序" class="headerlink" title="七、归并排序"></a>七、归并排序</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/1a63567f7ebb40479e25919faf3cf131.gif"></p><blockquote><p> 归并排序的基本思想（分治思想）：</p><ol><li><p>（拆分）将一段数组分为左序列和右序列，让他们两个分别有序，再将左序列细分为左序列和右序列，如此重复该步骤，直到细分到区间不存在或者只有一个数字为止</p></li><li><p>（合并）将第一步得到的数字合并成有序区间</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> left,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid= (left+right)/<span class="number">2</span>;</span><br><span class="line">    mergeSort(a,left,mid);</span><br><span class="line">    mergeSort(a,mid+<span class="number">1</span>,right);</span><br><span class="line">    merge(a,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将两个数组合并</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建辅助数组aux  根据要合并的数组创建相对应大小的辅助数组</span></span><br><span class="line">    <span class="type">int</span>[] aux = <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//辅助数组aux 这里i-left 使得aux从0开始赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">        aux[i-left]=a[i];</span><br><span class="line">    <span class="comment">//i:临时数组左边比较的元素下标；j:临时数组右边比较的元素的下标；k:原数组将要放置的元素下标</span></span><br><span class="line">    <span class="type">int</span> i=left,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=left;k&lt;=right;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检查左下标是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;mid)</span><br><span class="line">        &#123;</span><br><span class="line">            a[k]=aux[j-left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            a[k]=aux[i-left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(aux[i-left]&lt;=aux[j-left])</span><br><span class="line">        &#123;</span><br><span class="line">            a[k]=aux[i-left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[k]=aux[j-left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度度：<strong>最好最坏平均 都为O(nlogn)</strong></p><p>空间复杂度：O(n)</p><p>稳定性:稳定</p><h2 id="八、桶排序"><a href="#八、桶排序" class="headerlink" title="八、桶排序"></a>八、桶排序</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/image-20221219185937930.png" alt="image-20221219185937930"></p><blockquote><p>桶排序核心思想就是将要排序的数据分到几个有序的桶里，每个通在分别进行排序，每个桶排序完成后再把每个桶里的数据按照顺序依次取出，组成新的序列，该序列就是排好序的序列。类似归并排序中中的分治思想。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="comment">//先求出数组中的最大的数</span></span><br><span class="line">    <span class="type">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;max)&#123;</span><br><span class="line">            max=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到最大数是几位数,将数字转换成字符串</span></span><br><span class="line">    <span class="type">int</span> maxLength=(max+<span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个二维数组，表示10个桶，每个桶就是一个数组</span></span><br><span class="line">    <span class="comment">//为了在放入数时防止数据溢出，我们每个桶的大小为arr.length,</span></span><br><span class="line">    <span class="comment">// 即每个桶最多放进数组里的所有元素</span></span><br><span class="line">    <span class="type">int</span>[][] bucket=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">    <span class="type">int</span>[] bucketElementCount=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,n=<span class="number">1</span>;i&lt;maxLength;i++,n*=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对每个元素的对应位进行处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="comment">//取出每个元素的对应位的值</span></span><br><span class="line">            <span class="type">int</span> digiOfElement=arr[j]/n%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放入到对应的桶中</span></span><br><span class="line">            bucket[digiOfElement][bucketElementCount[digiOfElement]]=arr[j];</span><br><span class="line">            bucketElementCount[digiOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照这个桶的顺序即一维数组的下标一次取出数据放入原来数组</span></span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每一桶，并将桶中数据放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;bucketElementCount.length;k++)&#123;</span><br><span class="line">            <span class="comment">//如果桶中有数据，才放入原来数组</span></span><br><span class="line">            <span class="keyword">if</span>(bucketElementCount[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;bucketElementCount[k];m++)&#123;</span><br><span class="line">                    arr[index++]=bucket[k][m];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每一轮处理后，需将bucketElementCount[k]=0</span></span><br><span class="line">            bucketElementCount[k]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;轮，对个位数的排序处理 arr=&quot;</span>+             Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<strong>最好O(n) 最坏O(n*k) 平均 O(n+k)</strong></p><p>空间复杂度：O(n+k)</p><p>稳定性：稳定</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th></th><th><strong>最好</strong></th><th><strong>最好</strong></th><th><strong>平均</strong></th><th><strong>空间复杂度</strong></th><th><strong>稳定性</strong></th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>不稳定</td></tr><tr><td>直接插入排序</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td><strong>O(n)</strong></td><td><strong>O(n^2)</strong></td><td><strong>O(n^1.3)</strong></td><td>O(1)</td><td>不稳定</td></tr><tr><td>直接选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n)</td><td>O(n*2)</td><td>O(n+k)</td><td>O(n+k)</td><td>稳定</td></tr></tbody></table><p>参考文献：</p><p><a href="https://blog.csdn.net/qq_46440190/article/details/123945524?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167144468116800192246408%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167144468116800192246408&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-123945524-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v1&utm_term=%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%20java&spm=1018.2226.3001.4187">1</a></p><p><a href="https://blog.csdn.net/weixin_57675461/article/details/121903270?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167143784916800184157989%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167143784916800184157989&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121903270-null-null.142%5Ev68%5Econtrol,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v1&utm_term=%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">2</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo上传失败问题</title>
      <link href="/2022/12/13/%E7%AC%94%E8%AE%B0%E5%8C%BA/Hexo/"/>
      <url>/2022/12/13/%E7%AC%94%E8%AE%B0%E5%8C%BA/Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows搭建hexo博客报错"><a href="#Windows搭建hexo博客报错" class="headerlink" title="Windows搭建hexo博客报错"></a>Windows搭建hexo博客报错</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">FATAL</span> &#123;</span><br><span class="line">  <span class="attr">err</span>: <span class="title class_">Error</span>: <span class="title class_">Spawn</span> failed</span><br><span class="line">      at <span class="title class_">ChildProcess</span>.&lt;anonymous&gt; (<span class="attr">C</span>:\<span class="title class_">Users</span>\myosotis\<span class="title class_">Desktop</span>\<span class="title class_">Hexo</span>_blog\node_modules\hexo-util\lib\spawn.<span class="property">js</span>:<span class="number">51</span>:<span class="number">21</span>)</span><br><span class="line">      at <span class="title class_">ChildProcess</span>.<span class="property">emit</span> (events.<span class="property">js</span>:<span class="number">315</span>:<span class="number">20</span>)</span><br><span class="line">      at <span class="title class_">ChildProcess</span>.<span class="property">cp</span>.<span class="property">emit</span> (<span class="attr">C</span>:\<span class="title class_">Users</span>\myosotis\<span class="title class_">Desktop</span>\<span class="title class_">Hexo</span>_blog\node_modules\cross-spawn\lib\enoent.<span class="property">js</span>:<span class="number">34</span>:<span class="number">29</span>)</span><br><span class="line">      at <span class="title class_">Process</span>.<span class="property">ChildProcess</span>.<span class="property">_handle</span>.<span class="property">onexit</span> (internal/child_process.<span class="property">js</span>:<span class="number">277</span>:<span class="number">12</span>) &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="number">128</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="title class_">Something</span><span class="string">&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span></span><br></pre></td></tr></table></figure><h2 id="方法一-推荐"><a href="#方法一-推荐" class="headerlink" title="方法一(推荐)"></a>方法一(推荐)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##进入站点根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##删除git提交内容文件夹</span></span><br><span class="line"><span class="built_in">rm</span> -rf .deploy_git/</span><br><span class="line"></span><br><span class="line"><span class="comment">##执行</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##最后</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><blockquote><p>修改 _config.yml 文件，将配置地址http方式切换成ssh方式</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##进入站点根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##删除git提交内容文件夹</span></span><br><span class="line">vim _config.yml</span><br><span class="line"></span><br><span class="line"><span class="comment">##修改</span></span><br><span class="line">deploy:</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line"></span><br><span class="line">repository: https://github.com/Uninfo/blog.github.io.git </span><br><span class="line">-&gt; git@github.com:Uninfo/blog.github.io.git</span><br><span class="line"></span><br><span class="line">branch: master</span><br><span class="line"></span><br><span class="line"><span class="comment">##最后</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>普通面试题</title>
      <link href="/2022/12/13/%E9%9D%A2%E8%AF%95/%E6%99%AE%E9%80%9A%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/12/13/%E9%9D%A2%E8%AF%95/%E6%99%AE%E9%80%9A%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h3><p>java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件</p><p>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件普通的指令长度和其他特性。</p><h3 id="2-JDK和JRE的区别是什么？"><a href="#2-JDK和JRE的区别是什么？" class="headerlink" title="2. JDK和JRE的区别是什么？"></a>2. JDK和JRE的区别是什么？</h3><p><img src="https://img-blog.csdnimg.cn/0759c4fd10a14347a3499364aab1dea6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAV1lBWkg=,size_20,color_FFFFFF,t_70,g_se,x_16"></p><blockquote><p>JRE：Java Runtime Environment</p><p>JDK：Java Development Kit</p><p>JRE顾名思义是<strong>java运行时环境</strong>，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。</p><p>JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。</p><p>如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。</p><p>JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本 。<br>再说说java的跨平台吧:</p><p> java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行。</p><p>最后解释下机器码和字节码的区别:</p><p>一，机器码，完全依附硬件而存在～并且不同硬件由于内嵌指令集不同，即使相同的0 1代码意思也可能是不同的～换句话说，根本不存在跨平台性～比如～不同型号的CPU,你给他个指令10001101，他们可能会解析为不同的结果～</p></blockquote><p>二，我们知道JAVA是跨平台的，为什么呢？因为他有一个jvm,不论那种硬件，只要你装有jvm,那么他就认识这个JAVA字节码～～～～至于底层的机器码，咱不用管，有jvm搞定，他会把字节码再翻译成所在机器认识的机器码～～～</p><h3 id="3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h3><blockquote><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p><p>Java中static方法不能被覆盖，因为方法覆盖是基于<strong>运行时动态绑定</strong>的，而static方法是<strong>编译时静态绑定</strong>的。static方法跟类的任何实例都不相关，所以概念上不适用。</p><p>java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。</p></blockquote><h3 id="4-是否可以在static环境中访问非static变量？"><a href="#4-是否可以在static环境中访问非static变量？" class="headerlink" title="4. 是否可以在static环境中访问非static变量？"></a>4. 是否可以在static环境中访问非static变量？</h3><blockquote><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p></blockquote><h3 id="5-Java支持的数据类型有那些？什么是自动拆装箱？"><a href="#5-Java支持的数据类型有那些？什么是自动拆装箱？" class="headerlink" title="5. Java支持的数据类型有那些？什么是自动拆装箱？"></a>5. Java支持的数据类型有那些？什么是自动拆装箱？</h3><blockquote><p>Java语言支持的8种基本数据类型是：</p><p>byte</p><p>short</p><p>int</p><p>long</p><p>float</p><p>double</p><p>boolean</p><p>char</p><p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</p><p>Java支持的数据类型包括两种：一种是<strong>基本数据类型</strong>，包含byte，char,short, boolean ,int , long, float,double;另一种是<strong>引用类型</strong>：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程。</p></blockquote><h3 id="6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？"><a href="#6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？" class="headerlink" title="6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？"></a>6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？</h3><blockquote><p>Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p></blockquote><h3 id="7-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#7-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h3><blockquote><p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。<br>Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。<br>Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</p></blockquote><h3 id="8-Java支持多继承么？"><a href="#8-Java支持多继承么？" class="headerlink" title="8. Java支持多继承么？"></a>8. Java支持多继承么？</h3><blockquote><p>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p></blockquote><h3 id="9-接口和抽象类的区别是什么？"><a href="#9-接口和抽象类的区别是什么？" class="headerlink" title="9. 接口和抽象类的区别是什么？"></a>9. 接口和抽象类的区别是什么？</h3><blockquote><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p><p><strong>JDK1.8接口支持静态方法和默认方法</strong></p><p>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。<br>也可以参考JDK8中抽象类和接口的区别</p></blockquote><h3 id="10-在java中为什么很多人说有值传递和引用传递？引用传递的本质是什么"><a href="#10-在java中为什么很多人说有值传递和引用传递？引用传递的本质是什么" class="headerlink" title="10. 在java中为什么很多人说有值传递和引用传递？引用传递的本质是什么?"></a>10. 在java中为什么很多人说有值传递和引用传递？引用传递的本质是什么?</h3><blockquote><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><p><strong>线程与进程的区别归纳：</strong></p><p><strong>a.地址空间和其它资源</strong>：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</p><p><strong>b.通信：</strong>进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</p><p><strong>c.调度和切换</strong>：线程上下文切换比进程上下文切换要快得多。</p><p>d.在多线程OS中，进程不是一个可执行的实体。</p></blockquote><h3 id="11-创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#11-创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="11. 创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>11. 创建线程有几种不同的方式？你喜欢哪一种？为什么？</h3><blockquote><p>有4种方式可以用来创建线程：<br>继承Thread类<br>实现Runnable接口<br>应用程序可以使用Executor框架来创建线程池</p><p>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p><p>还有一种方式是实现Callable接口</p></blockquote><h3 id="12-概括的解释下线程的几种可用状态。"><a href="#12-概括的解释下线程的几种可用状态。" class="headerlink" title="12. 概括的解释下线程的几种可用状态。"></a>12. 概括的解释下线程的几种可用状态。</h3><blockquote><ol><li><p>新建( new )：新创建了一个线程对象。</p></li><li><p>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</p></li><li><p>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</p></li><li><p>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：</p></li></ol><p>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。</p><p>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。</p><p>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。      当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</p><ol start="5"><li>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li></ol></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/149974_1450349079825_4697A22AC611680A692472687DEC1CFD" alt="img"></p><h3 id="13-同步方法和同步代码块的区别是什么？"><a href="#13-同步方法和同步代码块的区别是什么？" class="headerlink" title="13. 同步方法和同步代码块的区别是什么？"></a>13. 同步方法和同步代码块的区别是什么？</h3><blockquote><p>区别：</p><p>同步方法默认用this或者当前类class对象作为锁；</p><p>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</p><p>同步方法使用关键字 synchronized修饰方法，而同步代码块主要是修饰需要进行同步的代码，用  synchronized（object）{代码内容}进行修饰；</p></blockquote><h3 id="14-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#14-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="14. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>14. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3><blockquote><p>监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p></blockquote><h3 id="15-什么是死锁-deadlock-？"><a href="#15-什么是死锁-deadlock-？" class="headerlink" title="15. 什么是死锁(deadlock)？"></a>15. 什么是死锁(deadlock)？</h3><blockquote><p>所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：</p><ul><li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。</li></ul></blockquote><h3 id="16-如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#16-如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="16. 如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>16. 如何确保N个线程可以访问N个资源同时又不导致死锁？</h3><blockquote><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p></blockquote><h3 id="17-Java集合类框架的基本接口有哪些？"><a href="#17-Java集合类框架的基本接口有哪些？" class="headerlink" title="17. Java集合类框架的基本接口有哪些？"></a>17. Java集合类框架的基本接口有哪些？</h3><blockquote><p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的Collection。<br>List：有顺序的collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>普通面试题</title>
      <link href="/2022/12/13/%E9%9D%A2%E8%AF%95/%E6%99%AE%E9%80%9A%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%AF%E6%9C%AC/"/>
      <url>/2022/12/13/%E9%9D%A2%E8%AF%95/%E6%99%AE%E9%80%9A%E9%9D%A2%E8%AF%95%E9%A2%98%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h3><p>java虚拟机是一个可以执行字节码文件的——。Java源文件被编译成能被——执行的字节码文件</p><p>Java被设计成允许应用程序可以运行在——，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道——普通的指令长度和其他特性。</p><h3 id="2-JDK和JRE的区别是什么？"><a href="#2-JDK和JRE的区别是什么？" class="headerlink" title="2. JDK和JRE的区别是什么？"></a>2. JDK和JRE的区别是什么？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/0759c4fd10a14347a3499364aab1dea6.png"></p><blockquote><p>JRE：Java Runtime Environment</p><p>JDK：Java Development Kit</p><p>JRE顾名思义是<strong>——</strong>，包含了——，——。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。</p><p>JDK顾名思义是——，是程序员使用——编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了——，同时还包含了编译java源码的——，还包含了很多——和——：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的——和demo例子程序。</p><p>如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。</p><p>JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本 。<br>再说说java的跨平台吧:</p><p>java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行。</p><p>最后解释下机器码和字节码的区别:</p><p>一，机器码，完全依附硬件而存在～并且不同硬件由于内嵌指令集不同，即使相同的0 1代码意思也可能是不同的～换句话说，根本不存在跨平台性～比如～不同型号的CPU,你给他个指令10001101，他们可能会解析为不同的结果～</p></blockquote><p>二，我们知道JAVA是跨平台的，为什么呢？因为他有一个jvm,不论那种硬件，只要你装有jvm,那么他就认识这个JAVA字节码～～～～至于底层的机器码，咱不用管，有jvm搞定，他会把字节码再翻译成所在机器认识的机器码～～～</p><h3 id="3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#3-”static”关键字是什么意思？Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？"></a>3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</h3><blockquote><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p><p>Java中static方法不能被覆盖，因为方法覆盖是基于<strong>运行时动态绑定</strong>的，而static方法是<strong>编译时静态绑定</strong>的。static方法跟类的任何实例都不相关，所以概念上不适用。</p><p>java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。</p></blockquote><h3 id="4-是否可以在static环境中访问非static变量？"><a href="#4-是否可以在static环境中访问非static变量？" class="headerlink" title="4. 是否可以在static环境中访问非static变量？"></a>4. 是否可以在static环境中访问非static变量？</h3><blockquote><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p></blockquote><h3 id="5-Java支持的数据类型有那些？什么是自动拆装箱？"><a href="#5-Java支持的数据类型有那些？什么是自动拆装箱？" class="headerlink" title="5. Java支持的数据类型有那些？什么是自动拆装箱？"></a>5. Java支持的数据类型有那些？什么是自动拆装箱？</h3><blockquote><p>Java语言支持的——种基本数据类型是：</p><p>byte</p><p>——</p><p>int</p><p>——</p><p>——</p><p>double</p><p>——</p><p>char</p><p>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</p><p>Java支持的数据类型包括两种：一种是<strong>——</strong>，包含byte，char,short, boolean ,int , long, float,double;另一种是<strong>——</strong>：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程。</p></blockquote><h3 id="6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？"><a href="#6-Java中的方法覆盖-Overriding-和方法重载-Overload-是什么意思？" class="headerlink" title="6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？"></a>6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？</h3><blockquote><p>Java中的方法重载发生在——里面两个或者是多个方法的方法名相同但是——的情况。与此相对，方法覆盖是说子类——父类的方法。方法覆盖必须有——的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p></blockquote><h3 id="7-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"><a href="#7-Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？" class="headerlink" title="7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？"></a>7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</h3><blockquote><p>当新对象被创建的时候，——会被调用。每一个类都有——。在程序员没有给类提供构造方法的情况下，——会为这个类创建一个默认的构造方法。<br>Java中构造方法重载和——很相似。可以为——创建多个构造方法。每一个构造方法必须有它自己——。<br>Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。</p></blockquote><h3 id="8-Java支持多继承么？"><a href="#8-Java支持多继承么？" class="headerlink" title="8. Java支持多继承么？"></a>8. Java支持多继承么？</h3><blockquote><p>Java中类不支持——，只支持单继承（即一个类只有一个父类）。 但是java中的——支持多继承，，即一个子接口可以有——。（接口的作用是用来扩展对象的功能，一个子接口继承——，说明子接口扩展了——，当类——接口时，类就扩展了相应的功能）。</p></blockquote><h3 id="9-接口和抽象类的区别是什么？"><a href="#9-接口和抽象类的区别是什么？" class="headerlink" title="9. 接口和抽象类的区别是什么？"></a>9. 接口和抽象类的区别是什么？</h3><blockquote><p>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p><p><strong>JDK1.8接口支持静态方法和默认方法</strong></p><p>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。<br>类可以实现很多个接口，但是只能继承一个抽象类<br>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。<br>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。<br>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。<br>接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。<br>也可以参考JDK8中抽象类和接口的区别</p></blockquote><h3 id="10-在java中为什么很多人说有值传递和引用传递？引用传递的本质是什么"><a href="#10-在java中为什么很多人说有值传递和引用传递？引用传递的本质是什么" class="headerlink" title="10. 在java中为什么很多人说有值传递和引用传递？引用传递的本质是什么?"></a>10. 在java中为什么很多人说有值传递和引用传递？引用传递的本质是什么?</h3><blockquote><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><p><strong>线程与进程的区别归纳：</strong></p><p><strong>a.地址空间和其它资源</strong>：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</p><p><strong>b.通信：</strong>进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</p><p><strong>c.调度和切换</strong>：线程上下文切换比进程上下文切换要快得多。</p><p>d.在多线程OS中，进程不是一个可执行的实体。</p></blockquote><h3 id="11-创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#11-创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="11. 创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>11. 创建线程有几种不同的方式？你喜欢哪一种？为什么？</h3><blockquote><p>有4种方式可以用来创建线程：<br>继承——<br>实现——<br>应用程序可以使用Executor框架来创建线程池</p><p>实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p><p>还有一种方式是实现——接口</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础题</title>
      <link href="/2022/12/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/"/>
      <url>/2022/12/13/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-JDK和JRE有什么区别？"><a href="#1-JDK和JRE有什么区别？" class="headerlink" title="1. JDK和JRE有什么区别？"></a>1. JDK和JRE有什么区别？</h3><p>JDK（Java Development Kit） java开发工具包</p><p>JRE（Java Runtime Environment） Java运行环境</p><p>JDK中包含JRE，JDK有一个名为jre的目录，里面包含两个文件夹bin和lib，bin就是JVM，lib就是JVM工作所需要的类库。</p><h3 id="2-和equals的区别是什么？"><a href="#2-和equals的区别是什么？" class="headerlink" title="2. == 和equals的区别是什么？"></a>2. == 和equals的区别是什么？</h3><ol><li><p>对于基本类型，==比较的是值。</p></li><li><p>对于引用类型，==比较的是地址。</p></li><li><p>equals不能用于基本类型的比较</p></li><li><p>如果没有重写equals，equels就相当于==</p></li><li><p>如果重写了equals方法，equals比较的就是对象内容</p></li></ol><h3 id="3-final在java中有什么作用？"><a href="#3-final在java中有什么作用？" class="headerlink" title="3. final在java中有什么作用？"></a>3. final在java中有什么作用？</h3><p>（1）用来修饰一个引用</p><ol><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>资料链接</title>
      <link href="/2022/12/13/%E9%9D%A2%E8%AF%95/%E8%B5%84%E6%96%99%E9%93%BE%E6%8E%A5/"/>
      <url>/2022/12/13/%E9%9D%A2%E8%AF%95/%E8%B5%84%E6%96%99%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/Tyson0314/Java-learning">java基础</a></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/image-20221217152855214.png" alt="image-20221217152855214"></p><p><a href="https://javaxiaobear.gitee.io/">面试网站</a></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/image-20221217154609385.png" alt="image-20221217154609385"></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>垂直方向布局</title>
      <link href="/2022/12/13/web%E5%89%8D%E7%AB%AF/2_CSS/%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E5%B8%83%E5%B1%80/"/>
      <url>/2022/12/13/web%E5%89%8D%E7%AB%AF/2_CSS/%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="垂直方向布局"><a href="#垂直方向布局" class="headerlink" title="垂直方向布局"></a>垂直方向布局</h1><h2 id="元素溢出"><a href="#元素溢出" class="headerlink" title="元素溢出"></a>元素溢出</h2><p>子元素是在父元素的内容排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出。</p><p>使用<code>overflow</code>/<code>overflow-x</code> /<code>overflow-y</code>属性来设置父元素如何处理溢出的子元素</p><blockquote><p>子元素是在父元素的内容排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出。</p><p>使用overflow、overflow-x、overflow-y属性来设置父元素然后处理溢出的子元素</p><p>子元素是在父元素的内容排列，如果子元素的大小超过了父元素，则子元素会从父元素中溢出，这种现象叫元素溢出。</p><p>使用overflow，overflow-x，overflow-y属性来设置父元素，然后处理溢出的子元素。</p></blockquote><ol><li><code>visible</code> 溢出内容会在父元素外部位置显示，默认值</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: visible; <span class="comment">/*默认值*/</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet consectetur adipisicing elit. Asperiores aspernatur</span><br><span class="line">  illo inventore deleniti laudantium quaerat excepturi sed quidem tempore?</span><br><span class="line">  Eaque, cumque porro. Fuga quam error cupiditate quasi eveniet in numquam!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>hidden</code>溢出内容会被裁剪，不会显示</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">overflow</span>: hidden; <span class="comment">/* 隐藏溢出内容 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet consectetur adipisicing elit. Asperiores aspernatur</span><br><span class="line">  illo inventore deleniti laudantium quaerat excepturi sed quidem tempore?</span><br><span class="line">  Eaque, cumque porro. Fuga quam error cupiditate quasi eveniet in numquam!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>scroll</code> 生成两个滚动条，通过滚动条来查看完整的内容</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">overflow</span>: scroll;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet consectetur adipisicing elit. Asperiores aspernatur</span><br><span class="line">  illo inventore deleniti laudantium quaerat excepturi sed quidem tempore?</span><br><span class="line">  Eaque, cumque porro. Fuga quam error cupiditate quasi eveniet in numquam!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4 <code>auto</code>根据需要生成滚动条</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">overflow</span>: auto;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet consectetur adipisicing elit. Asperiores aspernatur</span><br><span class="line">  illo inventore deleniti laudantium quaerat excepturi sed quidem tempore?</span><br><span class="line">  Eaque, cumque porro. Fuga quam error cupiditate quasi eveniet in numquam!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="边距折叠"><a href="#边距折叠" class="headerlink" title="边距折叠"></a>边距折叠</h2><p>垂直外边距的重叠（折叠）:  相邻的垂直方向外边距发生重叠现象</p><h3 id="一、兄弟元素"><a href="#一、兄弟元素" class="headerlink" title="一、兄弟元素"></a>一、兄弟元素</h3><p>兄弟元素之间的相邻，垂直外边距会取两者之间的较大值（两者都是正值）</p><p>特殊情况：</p><ul><li>如果相邻的外边距一正一负，则取两者的和</li><li>如果相邻的外边距都是负值，则取两者中绝对值较大的</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>,</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.boxl</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span><br><span class="line">  <span class="comment">/*设置一个下外边距*/</span></span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="comment">/*设置一个上外边距*/</span></span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疑问</strong></p><p>当浏览器缩放比例是100%时，我们使用FastStone Capture工具自带的刻度尺测量，发现“兄弟”之间似乎没有我们想象的那么“亲近”</p><p>两者的垂直方向间距是125px，我们明明上下元素设置的是100px啊，这是为什么呢？</p><blockquote><p>在网页布局中，通过谷歌浏览器或者火狐浏览器预览时，发现我们定义的盒模型width，height，margin，padding值都是不准确的</p><p>谷歌、火狐浏览器缩放为80%时，margin值才是正确</p></blockquote><p><strong>总结</strong></p><p>兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理</p><blockquote><p>注：内联元素脱离文档流变为块元素</p></blockquote><h3 id="二、父子元素"><a href="#二、父子元素" class="headerlink" title="二、父子元素"></a>二、父子元素</h3><p>父子元素间相邻外边距，子元素会传递给父元素（上外边距）</p><p>待续。。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo上传失败问题</title>
      <link href="/2022/12/13/web%E5%89%8D%E7%AB%AF/note/yarn%20%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/12/13/web%E5%89%8D%E7%AB%AF/note/yarn%20%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="yarn使用"><a href="#yarn使用" class="headerlink" title="yarn使用"></a>yarn使用</h1><h2 id="1-1-什么是-yarn"><a href="#1-1-什么是-yarn" class="headerlink" title="1.1. 什么是 yarn?"></a>1.1. 什么是 yarn?</h2><p>Yarn 是 facebook 发布的一款取代 npm 的包管理工具。</p><h2 id="1-2-yarn-的特点"><a href="#1-2-yarn-的特点" class="headerlink" title="1.2. yarn 的特点"></a>1.2. yarn 的特点</h2><h3 id="1-2-1-速度超快。"><a href="#1-2-1-速度超快。" class="headerlink" title="1.2.1. 速度超快。"></a>1.2.1. 速度超快。</h3><p>Yarn 缓存了每个下载过的包, 所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率, 因此安装速度更快。</p><blockquote><p>Yarn缓存了每个下载过的包，所以再次使用时无需重复下载。同时利用并行下载以最大化资源利用率，因此安装速度更快。</p></blockquote><h3 id="1-2-2-超级安全。"><a href="#1-2-2-超级安全。" class="headerlink" title="1.2.2. 超级安全。"></a>1.2.2. 超级安全。</h3><p>在执行代码之前, Yarn 会通过算法校验每个安装包的完整性。</p><blockquote><p>在执行代码之前，Yarn会通过算法校验每一个安装包的完整性。</p></blockquote><h3 id="1-2-3-超级可靠。"><a href="#1-2-3-超级可靠。" class="headerlink" title="1.2.3. 超级可靠。"></a>1.2.3. 超级可靠。</h3><p>使用详细、简洁的锁文件格式和明确的安装算法, Yarn 能够保证在不同系统上无差异的工作。</p><blockquote><p>使用详细、简洁的锁文件格式和明确的安装算法，Yarn能够保证在不同系统上无差异的工作。</p></blockquote><h2 id="1-3-为什么会出现-yarn"><a href="#1-3-为什么会出现-yarn" class="headerlink" title="1.3. 为什么会出现 yarn"></a>1.3. 为什么会出现 yarn</h2><p>npm 存在一些历史遗留问题, npm 很多依赖不会指定版本号, 默认会安装最新的版本, 这样就会出现问题: 当新版本无法兼容之前的项目, 原项目可能会出现 bug。yarn 为了解决这个问题推出了 yarn.lock 的机制, 把依赖模块的版本号全部锁定, 当你执行 yarn install 的时候, yarn 会读取这个文件获得依赖的版本号, 然后依照这个版本号去安装对应的依赖模块, 这样依赖就会被锁定, 以后再也不用担心版本号的问题了。其他人或者其他环境下使用的时候, 把这个 yarn.lock 拷贝到相应的环境项目下再安装即可。<br>注意: 这个文件不要手动修改它, 当你使用一些操作如 yarn add 时, yarn 会自动更新 yarn.lock。</p><h2 id="1-4-yarn-的安装"><a href="#1-4-yarn-的安装" class="headerlink" title="1.4. yarn 的安装"></a>1.4. yarn 的安装</h2><h3 id="1-4-1-下载-node-js-使用-npm-安装"><a href="#1-4-1-下载-node-js-使用-npm-安装" class="headerlink" title="1.4.1. 下载 node.js, 使用 npm 安装"></a>1.4.1. 下载 node.js, 使用 npm 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure><p>查看版本: <code>yarn --version</code></p><h3 id="1-4-2-Yarn-淘宝源安装-分别复制粘贴以下代码行到黑窗口运行即可"><a href="#1-4-2-Yarn-淘宝源安装-分别复制粘贴以下代码行到黑窗口运行即可" class="headerlink" title="1.4.2. Yarn 淘宝源安装, 分别复制粘贴以下代码行到黑窗口运行即可"></a>1.4.2. Yarn 淘宝源安装, 分别复制粘贴以下代码行到黑窗口运行即可</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn config set registry https://registry.npm.taobao.org -g</span><br><span class="line">yarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g</span><br></pre></td></tr></table></figure><h2 id="1-5-yarn-的常用命令"><a href="#1-5-yarn-的常用命令" class="headerlink" title="1.5. yarn 的常用命令"></a>1.5. yarn 的常用命令</h2><h3 id="1-5-1-初始化项目"><a href="#1-5-1-初始化项目" class="headerlink" title="1.5.1. 初始化项目"></a>1.5.1. 初始化项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init // 同 npm init, 执行输入信息后, 会生成 package.json 文件</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init //同npm init，执行输入信息后，会生成package.json文件</span><br></pre></td></tr></table></figure><h3 id="1-5-2-yarn-的配置项"><a href="#1-5-2-yarn-的配置项" class="headerlink" title="1.5.2. yarn 的配置项"></a>1.5.2. yarn 的配置项</h3><ul><li>  <code>yarn config list</code> // 显示所有配置项</li><li>  <code>yarn config get &lt;key&gt;</code> // 显示某配置项</li><li>  <code>yarn config delete &lt;key&gt;</code> // 删除某配置项</li><li>  <code>yarn config set &lt;key&gt; &lt;value&gt; [-g|--global]</code> // 设置配置项</li></ul><h3 id="1-5-3-安装包"><a href="#1-5-3-安装包" class="headerlink" title="1.5.3. 安装包"></a>1.5.3. 安装包</h3><ul><li>  <code>yarn install</code> // 安装 package.json 里所有包, 并将包及它的所有依赖项保存进 yarn.lock</li><li>  <code>yarn install --flat</code> // 安装一个包的单一版本</li><li>  <code>yarn install --force</code> // 强制重新下载所有包</li><li>  <code>yarn install --production</code> // 只安装 dependencies 里的包</li><li>  <code>yarn install --no-lockfile</code> // 不读取或生成 yarn.lock</li><li>  <code>yarn install --pure-lockfile</code> // 不生成 yarn.lock</li></ul><h3 id="1-5-4-添加包-会更新-package-json-和-yarn-lock"><a href="#1-5-4-添加包-会更新-package-json-和-yarn-lock" class="headerlink" title="1.5.4. 添加包 (会更新 package.json 和 yarn.lock)"></a>1.5.4. 添加包 (会更新 package.json 和 yarn.lock)</h3><ul><li>  <code>yarn add [package]</code> // 在当前的项目中添加一个依赖包, 会自动更新到 package.json 和 yarn.lock 文件中</li><li>  <code>yarn add [package]@[version]</code> // 安装指定版本, 这里指的是主要版本, 如果需要精确到小版本, 使用 - E 参数</li><li>  <code>yarn add [package]@[tag]</code> // 安装某个 tag(比如 beta,next 或者 latest)</li></ul><p>默认安装包的主要版本里的最新版本, 下面两个命令可以指定版本:</p><ul><li>  <code>yarn add --exact/-E</code> // 安装包的精确版本。例如 <code>yarn add foo@1.2.3</code> 会接受 1.9.1 版, 但是 <code>yarn add foo@1.2.3 --exact</code> 只会接受 1.2.3 版</li><li>  <code>yarn add --tilde/-T</code> // 安装包的次要版本里的最新版。例如 <code>yarn add foo@1.2.3 --tilde</code> 会接受 1.2.9, 但不接受 1.3.0</li></ul><h3 id="1-5-5-发布包"><a href="#1-5-5-发布包" class="headerlink" title="1.5.5. 发布包"></a>1.5.5. 发布包</h3><p><code>yarn publish</code></p><h3 id="1-5-6-移除一个包"><a href="#1-5-6-移除一个包" class="headerlink" title="1.5.6. 移除一个包"></a>1.5.6. 移除一个包</h3><p><code>yarn remove &lt;packageName&gt;</code>: 移除一个包, 会自动更新 package.json 和 yarn.lock</p><h3 id="1-5-7-更新一个依赖"><a href="#1-5-7-更新一个依赖" class="headerlink" title="1.5.7. 更新一个依赖"></a>1.5.7. 更新一个依赖</h3><p><code>yarn upgrade</code> 用于更新包到基于规范范围的最新版本</p><h3 id="1-5-8-运行脚本"><a href="#1-5-8-运行脚本" class="headerlink" title="1.5.8. 运行脚本"></a>1.5.8. 运行脚本</h3><p><code>yarn run</code> 用来执行在 package.json 中 scripts 属性下定义的脚本</p><h3 id="1-5-9-显示某个包的信息"><a href="#1-5-9-显示某个包的信息" class="headerlink" title="1.5.9. 显示某个包的信息"></a>1.5.9. 显示某个包的信息</h3><p><code>yarn info &lt;packageName&gt;</code> 可以用来查看某个模块的最新版本信息</p><h3 id="1-5-10-缓存"><a href="#1-5-10-缓存" class="headerlink" title="1.5.10. 缓存"></a>1.5.10. 缓存</h3><ul><li>yarn cache<ul><li>  yarn cache list # 列出已缓存的每个包 yarn cache dir # 返回 全局缓存位置 yarn cache clean # 清除缓存</li></ul></li></ul><h2 id="1-6-npm-与-yarn-命令比较"><a href="#1-6-npm-与-yarn-命令比较" class="headerlink" title="1.6. npm 与 yarn 命令比较"></a>1.6. npm 与 yarn 命令比较</h2><table><thead><tr><th>NPM</th><th>YARN</th><th>说明</th></tr></thead><tbody><tr><td><code>npm init</code></td><td><code>yarn init</code></td><td>初始化某个项目</td></tr><tr><td><code>npm install/link</code></td><td><code>yarn install/link</code></td><td>默认的安装依赖操作</td></tr><tr><td><code>npm install taco --save</code></td><td><code>yarn add taco</code></td><td>安装某个依赖, 并且默认保存到 package</td></tr><tr><td><code>npm uninstall taco --save</code></td><td><code>yarn remove taco</code></td><td>移除某个依赖项目</td></tr><tr><td><code>npm install taco --save --dev</code></td><td><code>yarn add taco --dev</code></td><td>安装某个开发时依赖项目</td></tr><tr><td><code>npm update taco --save</code></td><td><code>yarn upgrade taco</code></td><td>更新某个依赖项目</td></tr><tr><td><code>npm install taco --global</code></td><td><code>yarn global add taco</code></td><td>安装某个全局依赖项目</td></tr><tr><td><code>npm publish/login/logout</code></td><td><code>yarn publish/login/logout</code></td><td>发布 / 登录 / 登出, 一系列 NPM Registry 操作</td></tr><tr><td><code>npm run/test</code></td><td><code>yarn run/test</code></td><td>运行某个命令</td></tr></tbody></table><h2 id="1-7-使用-yrm-工具管理一些-npm-源"><a href="#1-7-使用-yrm-工具管理一些-npm-源" class="headerlink" title="1.7. 使用 yrm 工具管理一些 npm 源"></a>1.7. 使用 yrm 工具管理一些 npm 源</h2><h3 id="1-7-1-安装"><a href="#1-7-1-安装" class="headerlink" title="1.7.1. 安装"></a>1.7.1. 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add yrm</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yrm --registry=https:registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="1-7-2-查看可用源"><a href="#1-7-2-查看可用源" class="headerlink" title="1.7.2. 查看可用源"></a>1.7.2. 查看可用源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yrm ls</span><br></pre></td></tr></table></figure><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/image-20221220111706742.png" alt="image-20221220111706742"></p><h3 id="1-7-3-选择源"><a href="#1-7-3-选择源" class="headerlink" title="1.7.3. 选择源"></a>1.7.3. 选择源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yrm use taobao</span><br></pre></td></tr></table></figure><h2 id="1-8-快速删除-node-modules"><a href="#1-8-快速删除-node-modules" class="headerlink" title="1.8. 快速删除 node_modules"></a>1.8. 快速删除 node_modules</h2><p>手动删除真的很慢:</p><ul><li>  安装: <code>npm install rimraf -g</code></li><li>  使用: <code>rimraf node_modules</code></li></ul><p>rimraf 是 node 的一个包, 可以快速删除 node_modules, 再也不用等半天了。</p><h2 id="1-9-Yarn-docs"><a href="#1-9-Yarn-docs" class="headerlink" title="1.9. Yarn docs"></a>1.9. Yarn docs</h2><ul><li>  Yarn 1 (Classic): <a href="https://classic.yarnpkg.com/en/docs/cli/run">https://classic.yarnpkg.com/en/docs/cli/run</a></li><li>  Yarn 2+: <a href="https://yarnpkg.com/getting-started/migration">https://yarnpkg.com/getting-started/migration</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/03/web%E5%89%8D%E7%AB%AF/note/%E4%B8%89%E7%A7%8D%E6%9A%B4%E9%9C%B2%E6%96%B9%E6%B3%95%E5%92%8C%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8FES6/"/>
      <url>/2022/12/03/web%E5%89%8D%E7%AB%AF/note/%E4%B8%89%E7%A7%8D%E6%9A%B4%E9%9C%B2%E6%96%B9%E6%B3%95%E5%92%8C%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8FES6/</url>
      
        <content type="html"><![CDATA[<h2 id="对外暴露的三种方式"><a href="#对外暴露的三种方式" class="headerlink" title="对外暴露的三种方式"></a>对外暴露的三种方式</h2><h3 id="1-分别暴露"><a href="#1-分别暴露" class="headerlink" title="1. 分别暴露"></a>1. 分别暴露</h3><p>也叫多行暴露，在引入时需要用对象来引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export let a = 1</span><br><span class="line">export function A()&#123;</span><br><span class="line">console.log(&quot;你好&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-统一暴露"><a href="#2-统一暴露" class="headerlink" title="2. 统一暴露"></a>2. 统一暴露</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">function A ()&#123;</span><br><span class="line">console.log(&quot;你好&quot;)</span><br><span class="line">&#125;</span><br><span class="line">export &#123; a , A &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意： 以上两种向外暴露方式在主文件引入时必须使用对象的解构赋值引用， 不能使用变量接收的方式来映入</p><p>（ 即上两方式和默认暴露的区别）</p><h3 id="3-默认暴露"><a href="#3-默认暴露" class="headerlink" title="3. 默认暴露"></a>3. 默认暴露</h3><p>一个 js 文件中只能有一个默认暴露，默认暴露的可以是一个常量，函数，对象等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//默认暴露一个函数</span><br><span class="line">export default function A()&#123;</span><br><span class="line">console.log(&quot;你好&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//默认暴露一个对象</span><br><span class="line">let a = 1</span><br><span class="line">function A ()&#123;</span><br><span class="line">console.log(&quot;你好&quot;)</span><br><span class="line">&#125;</span><br><span class="line">export default &#123; a , fun &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h2><ol><li>解构赋值引入<br>向外暴露方式在主文件引入时必须使用对象的解构赋值引用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; a , A &#125; from &quot;文件路径&quot;</span><br><span class="line">//此时当前模块便含有 a 变量，和fun函数</span><br><span class="line">console.log(a)// 1</span><br><span class="line">fun()// 你好</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>直接引入<br>对于默认暴露，直接引入即可</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如果要引入的j默认暴露的是一个函数</span><br><span class="line">import f from &quot;文件路径&quot;  //此处引入的就是一个函数</span><br><span class="line">f() // 你好</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP笔记</title>
      <link href="/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/TCP/"/>
      <url>/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/TCP/</url>
      
        <content type="html"><![CDATA[<h1 id="1-如何理解UDP-和-TCP-区别-应用场景"><a href="#1-如何理解UDP-和-TCP-区别-应用场景" class="headerlink" title="1. 如何理解UDP 和 TCP? 区别? 应用场景?"></a>1. 如何理解UDP 和 TCP? 区别? 应用场景?</h1><h2 id="一、UDP"><a href="#一、UDP" class="headerlink" title="一、UDP"></a>一、UDP</h2><p>UDP（User Datagram Protocol），用户数据包协议，是一个简单的<strong>面向数据报的通信协议</strong>，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层</p><p>也就是说无论应用层交给<code>UDP</code>多长的报文，它统统发送，一次发送一个报文</p><p>而对接收方，接到后直接去除首部，交给上面的应用层就完成任务</p><p><code>UDP</code>报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小</p><p><img src="https://static.vue-js.com/928e5d20-b393-11eb-ab90-d9ae814b240d.png" alt="img"></p><p>特点如下：</p><ul><li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务</li><li>传输途中出现丢包，UDP 也不负责重发</li><li>当包的到达顺序出现乱序时，UDP没有纠正的功能。</li><li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为</li></ul><h2 id="二、TCP"><a href="#二、TCP" class="headerlink" title="二、TCP"></a>二、TCP</h2><p>TCP（Transmission Control Protocol），传输控制协议，是一种可靠、<strong>面向字节流的通信协议</strong>，把上面应用层交下来的数据看成无结构的字节流来发送</p><p>可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小</p><p><code>TCP</code>报文首部有20个字节，额外开销大</p><p><img src="https://static.vue-js.com/a0010d40-b393-11eb-ab90-d9ae814b240d.png" alt="img"></p><p>特点如下：</p><ul><li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li><li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li><li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）</li></ul><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p><code>UDP</code>与<code>TCP</code>两者的都位于传输层，如下图所示：</p><p><img src="https://static.vue-js.com/a92bda80-b393-11eb-ab90-d9ae814b240d.png" alt="img"></p><p>两者区别如下表所示：</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠性</td><td>可靠</td><td>不可靠</td></tr><tr><td>连接性</td><td>面向连接</td><td>无连接</td></tr><tr><td>报文</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>效率</td><td>传输效率低</td><td>传输效率高</td></tr><tr><td>双共性</td><td>全双工</td><td>一对一、一对多、多对一、多对多</td></tr><tr><td>流量控制</td><td>滑动窗口</td><td>无</td></tr><tr><td>拥塞控制</td><td>慢开始、拥塞避免、快重传、快恢复</td><td>无</td></tr><tr><td>传输效率</td><td>慢</td><td>快</td></tr></tbody></table><ul><li>TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取</li><li>TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方</li><li>TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</li><li>TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</li></ul><p>两者应用场景如下图：</p><p><img src="https://static.vue-js.com/b6cdd800-b393-11eb-ab90-d9ae814b240d.png" alt="img"></p><p>可以看到，TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景</p><h1 id="2-TCP-IP-网络模型有哪几层？"><a href="#2-TCP-IP-网络模型有哪几层？" class="headerlink" title="2. TCP/IP 网络模型有哪几层？"></a>2. TCP/IP 网络模型有哪几层？</h1><p>问大家，为什么要有 TCP/IP 网络模型？</p><p>对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套<strong>通用的网络协议</strong>。</p><p>这个网络协议是分层的，每一层都有各自的作用和职责，接下来就根据「 TCP/IP 网络模型」分别对每一层进行介绍。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>最上层的，也是我们能直接接触到的就是<strong>应用层</strong>（<em>Application Layer</em>），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。</p><p>所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。</p><p>应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。</p><p>而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="img"></p><p>在传输层会有两个传输协议，分别是 TCP 和 UDP。</p><p>TCP 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p><p>UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 <strong>TCP 段</strong>（<em>TCP Segment</em>）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png" alt="img"></p><p>当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<strong>端口</strong>。</p><p>比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。</p><p>由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。</p><p>实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。</p><p>也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是<strong>网络层</strong>（<em>Internet Layer</em>）。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="img"></p><p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg" alt="img"></p><p>网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。</p><p>我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。</p><p>因此，需要将 IP 地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><p>怎么分的呢？这需要配合<strong>子网掩码</strong>才能算出 IP 地址 的网络号和主机号。</p><p>举个例子，比如 10.100.122.0/24，后面的<code>/24</code>表示就是 <code>255.255.255.0</code> 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。</p><p>知道了子网掩码，该怎么计算出网络地址和主机地址呢？</p><p>将 10.100.122.2 和 255.255.255.0 进行<strong>按位与运算</strong>，就可以得到网络号和主机号</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg" alt="img"></p><p>大家可以去搜索下子网掩码计算器，自己改变下「掩码位」的数值，就能体会到子网掩码的作用了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E5%99%A8.png" alt="子网掩码计算器"></p><p>那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。</p><p>除了寻址能力， IP 协议还有另一个重要的能力就是<strong>路由</strong>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p><p>路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg" alt="IP地址的网络号"></p><p>所以，<strong>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</strong>。</p><h2 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h2><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png" alt="img"></p><p>IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。</p><p>什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。</p><p>以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。</p><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</p><p>所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是<strong>应用层，传输层，网络层和网络接口层</strong>。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="img"></p><p>再给大家贴一下每一层的封装格式：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img"></p><p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p><h1 id="3-DNS协议-是什么？说说DNS-完整的查询过程"><a href="#3-DNS协议-是什么？说说DNS-完整的查询过程" class="headerlink" title="3. DNS协议 是什么？说说DNS 完整的查询过程?"></a>3. DNS协议 是什么？说说DNS 完整的查询过程?</h1><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器</p><p>简单来讲，<code>DNS</code>相当于一个翻译官，负责将域名翻译成<code>ip</code>地址</p><ul><li>IP 地址：一长串能够唯一地标记网络上的计算机的数字</li><li>域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识</li></ul><p><img src="https://static.vue-js.com/965a03a0-b78f-11eb-ab90-d9ae814b240d.png" alt="img"></p><h2 id="二、域名"><a href="#二、域名" class="headerlink" title="二、域名"></a>二、域名</h2><p>域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名…</p><p><img src="https://static.vue-js.com/9f112780-b78f-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>例如<code>www.xxx.com</code>，<code>www</code>为三级域名、<code>xxx</code>为二级域名、<code>com</code>为顶级域名，系统为用户做了兼容，域名末尾的根域名<code>.</code>一般不需要输入</p><p>在域名的每一层都会有一个域名服务器，如下图：</p><p><img src="https://static.vue-js.com/f40e0090-b7a4-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>除此之外，还有电脑默认的本地域名服务器</p><h2 id="三、查询方式"><a href="#三、查询方式" class="headerlink" title="三、查询方式"></a>三、查询方式</h2><p>DNS 查询的方式有两种：</p><ul><li>递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案</li></ul><p><img src="https://static.vue-js.com/a73be9e0-b78f-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><ul><li>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求</li></ul><p><img src="https://static.vue-js.com/b023e1c0-b78f-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><h2 id="四、域名缓存"><a href="#四、域名缓存" class="headerlink" title="四、域名缓存"></a>四、域名缓存</h2><p>在域名服务器解析的时候，使用缓存保存域名和<code>IP</code>地址的映射</p><p>计算机中<code>DNS</code>的记录也分成了两种缓存方式：</p><ul><li>浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗</li><li>操作系统缓存：操作系统的缓存其实是用户自己配置的 <code>hosts</code> 文件</li></ul><h2 id="五、查询过程"><a href="#五、查询过程" class="headerlink" title="五、查询过程"></a>五、查询过程</h2><p>解析域名的过程如下：</p><ul><li>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</li><li>若没有命中，则继续搜索操作系统的 DNS 缓存</li><li>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</li><li>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询<ul><li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul></li><li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li><li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</li><li>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</li></ul><p>流程如下图所示：</p><p><img src="https://static.vue-js.com/bec3c740-b78f-11eb-ab90-d9ae814b240d.png" alt="img"></p><h1 id="4-如何理解CDN？说说实现原理？"><a href="#4-如何理解CDN？说说实现原理？" class="headerlink" title="4. 如何理解CDN？说说实现原理？"></a>4. 如何理解CDN？说说实现原理？</h1><h2 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h2><p>CDN的全称是Content Delivery Network，即内容分发网络。</p><p>我们都用过天猫超市，在上面买东西非常方便。天猫超市的模式是货品先入天猫超市（后文简称为”猫超”）的菜鸟仓，然后由猫超统一派送的。</p><p>为了缩短物流的时间，可以让消费者快速的收到货品，菜鸟在全国各地建了本地仓库，现在大多数情况下，在猫超下单，第二天都可以收到（楼主在江浙沪包邮区，其他地区可能稍有延迟）。</p><p>比如我在杭州市西湖区，下单购买了一箱零食，没过多久就可以看到猫超已经发货了，发货地址是杭州的萧山仓，从杭州的一个区运输到另外一个区，24小时怎么也到了。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c709283e98~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>￼</p><p>猫超的配送采用的是智能仓配模式，菜鸟为天猫超市提供全国智能分仓，在商品销售前就已经来到距离消费者最近的仓储基地，下单购买后，由最近的仓发货，就近配送，速度比跨越多个省市跑过来的快多了。</p><p>我们可以在菜鸟网络的官网上看到其全国各地的仓库情况，我们可以看到他目前覆盖了全国20哥省份，70个城市，共有327各仓库。这些仓库组合在一起被称之为”全国仓网”。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c71d280196~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>图：菜鸟全国仓配网络</p><p>我们在浏览网络的时候，其实就和以上这个过程十分相似，我们访问一个页面的时候，会向服务器请求很多网络资源，包括各种图片、声音、影片、文字等信息。这和我们要购买的多种货物一样。</p><p>就像猫超会把货物提前存储在菜鸟建设在全国各地的本地仓库来减少物流时间一样，网站也可以预先把内容分发至全国各地的加速节点。这样用户就可以就近获取所需内容，避免网络拥堵、地域、运营商等因素带来的访问延迟问题，有效提升下载速度、降低响应时间，提供流畅的用户体验。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c722ca14fc~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>￼所以，”内容分发网络”就像前面提到的”全国仓配网络”一样，解决了因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率。</p><p>有了仓配网络之后，除了可以提升货物的配送效率，还有很多其他的好处：</p><p>1、首先通过预先做好了货物分发，使得最终货品从出仓到消费者手中的过程是比较短的，那么同城范围内可选择的配送公司就有很多选择，除了比较大的四通一达、顺丰以外，还可以选用一些小的物流公司、甚至菜鸟直接调用饿了么的蜂鸟配送也不是不可能。</p><blockquote><p>CDN技术消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量</p></blockquote><p>2、对于仓配系统来说，最大的灾难可能就是仓库发生火灾、水灾等自然灾害。如果把原来的一个集中式的大仓库打散成多个分布式的小仓库，分别部署在不同地区，就可以有效的减小自然灾害带来的影响。</p><blockquote><p>广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种DDoS攻击对网站的影响，同时保证较好的服务质量</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c72316037c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c71fab33b0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c727f05c71~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c7251ba9ca~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="CDN的基本工作过程"><a href="#CDN的基本工作过程" class="headerlink" title="CDN的基本工作过程"></a>CDN的基本工作过程</h2><p>传统快递企业采用的配送模式，通过”商家→网点→分拨→分拨→网点→客户”的环节进行配送。这个过程会有一些问题，如环节多、时效慢、易破损等。</p><p>上面这个过程和传统网站的请求响应过程类似，一般经历以下步骤：</p><ul><li>用户在自己的浏览器中输入要访问的网站域名。</li><li>浏览器向本地DNS服务器请求对该域名的解析。</li><li>本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。</li><li>本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以迭代方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。</li><li>浏览器得到域名解析结果，就是该域名相应的服务设备的IP地址 。</li><li>浏览器获取IP地址之后，经过标准的TCP握手流程，建立TCP连接。</li><li>浏览器向服务器发起HTTP请求。</li><li>服务器将用户请求内容传送给浏览器。</li><li>经过标准的TCP挥手流程，断开TCP连接。</li></ul><p>电商自建物流之后，配送模式有所变化：提前备货将异地件转化成同城件，省去干线环节提升时效，仓储高自动化分拣保证快速出库的同时也保证了分拣破损率较低。</p><p>对于用户来说，购物过程并没有变化，唯一的感受就是物流好像是比以前快了。所以，引入CDN之后，用户访问网站一般经历以下步骤：</p><ul><li>当用户点击网站页面上的内容URL，先经过本地DNS系统解析，如果本地DNS服务器没有相应域名的缓存，则本地DNS系统会将域名的解析权交给CNAME指向的CDN专用DNS服务器。</li><li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。</li><li>用户向CDN的全局负载均衡设备发起URL访问请求。</li><li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的URL，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。</li><li>基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的缓存服务器节点，并从缓存服务器节点处得到缓存服务器的IP地址，最终将得到的IP地址返回给全局负载均衡设备：</li><li>根据用户IP地址，判断哪一个边缘节点距用户最近；</li><li>根据用户所请求的URL中携带的内容名称，判断哪一个边缘节点上有用户所需内容；</li><li>查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力。</li><li>全局负载均衡设备把服务器的IP地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c73af1a83f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>图：华为云全站加速示意图</p><p>CDN全局负载均衡设备与CDN区域负载均衡设备根据用户IP地址，将域名解析成相应节点中缓存服务器的IP地址，实现用户就近访问，从而提高服务端响应内容的速度。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c73b501d98~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c73caf8adb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c7475b7a73~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c74840d283~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="CDN的组成"><a href="#CDN的组成" class="headerlink" title="CDN的组成"></a>CDN的组成</h2><p>前面我们说过，一个仓配网络是由多个仓库组成的，同理，内容分发网络（CDN）是由多个节点组成的。一般来讲，CDN网络主要由中心节点、边缘节点两部分构成。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c74d0dade9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>图：帝联云下载加速场景图</p><h3 id="中心节点"><a href="#中心节点" class="headerlink" title="中心节点"></a><strong>中心节点</strong></h3><p>中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理。</p><h3 id="边缘节点"><a href="#边缘节点" class="headerlink" title="边缘节点"></a><strong>边缘节点</strong></h3><p>CDN边缘节点主要指异地分发节点，由负载均衡设备、高速缓存服务器两部分组成。</p><p>负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率；同时还负责收集节点与周围环境的信息，保持与全局负载均衡DNS的通信，实现整个系统的负载均衡。</p><p>高速缓存服务器（Cache）负责存储客户网站的大量信息，就像一个靠近用户的网站服务器一样响应本地用户的访问请求。通过全局负载均衡DNS的控制，用户的请求被透明地指向离他最近的节点，节点中Cache服务器就像网站的原始服务器一样，响应终端用户的请求。因其距离用户更近，故其响应时间才更快。</p><p><strong>中心节点就像仓配网络中负责货物调配的总仓，而边缘节点就是负责存储货物的各个城市的本地仓库。</strong></p><p>目前，主要由很多提供CDN服务的云厂商在各地部署了很多个CDN节点，拿阿里云举例，我们可以在阿里云的官网上了解到：阿里云在全球拥有2500+节点。中国大陆拥有2000+节点，覆盖34个省级区域，大量节点位于省会等一线城市。海外和港澳台拥有500+节点，覆盖70多个国家和地区。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c75b2ad570~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="-w777"></p><p>图：阿里云在中国大陆的CDN节点的分布情况</p><p>有了如上图的阿里云在中国大陆的CDN节点的分布之后（这是不是也和我们前面看到的那张菜鸟网络的全国仓网很像），一个在杭州的电信网络用户，访问某个部署在阿里云上面的网站时，获取到的一些资源，如页面上的某个图片、某段影片或者某些文字，可能就是该网站预先分发到浙江的某个移动CDN存储节点提供的，这样就可以大大的减少网站的响应时间。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c75c4845bb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c76146215c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c761ff141a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c76772f2cc~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c93e65ac32~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c776fd41b4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="CDN相关技术"><a href="#CDN相关技术" class="headerlink" title="CDN相关技术"></a>CDN相关技术</h2><p>首先我们想一下，要想建设一个庞大的仓配网络都需要考虑哪些问题，需要哪些技术手段呢？</p><p>笔者认为主要是四个重要关注的点，分别是：</p><p>1、如何妥善的将货物分发到各个城市的本地仓。</p><p>2、如何妥善的各个本地仓存储货物。</p><p>3、如何根据用户的收货地址，智能的匹配出应该优先从哪个仓库发货，选用哪种物流方式等。</p><p>4、对于整个仓配系统如何进行管理，如整体货物分发的精确度、仓配的时效性、发货地的匹配度等。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c77f6942ba~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>图：菜鸟仓库智能机器人分拣货物</p><p>这其实和CDN中最重要的四大技术不谋而合，那就是内容发布、内容存储、内容路由以及内容管理等。</p><h3 id="内容发布"><a href="#内容发布" class="headerlink" title="内容发布"></a><strong>内容发布</strong></h3><p>它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处。</p><h3 id="内容存储"><a href="#内容存储" class="headerlink" title="内容存储"></a><strong>内容存储</strong></h3><p>对于CDN系统而言，需要考虑两个方面的内容存储问题。一个是内容源的存储，一个是内容在 Cache节点中的存储。</p><h3 id="内容路由"><a href="#内容路由" class="headerlink" title="内容路由"></a><strong>内容路由</strong></h3><p>它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应。</p><h3 id="内容管理"><a href="#内容管理" class="headerlink" title="内容管理"></a><strong>内容管理</strong></h3><p>它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c7786c3ee4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/5/16c5f7c77f5be450~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础笔记</title>
      <link href="/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="弱弱的问一问-要操作系统干嘛？"><a href="#弱弱的问一问-要操作系统干嘛？" class="headerlink" title="弱弱的问一问: 要操作系统干嘛？"></a>弱弱的问一问: 要操作系统干嘛？</h3><p>这里先不讲<code>操作系统</code>的概念了，因为文字太生硬了，我们只需要看一个简单的例子：</p><ul><li>在我们的JS代码里，只需要输入 <code>console.log(1+1)</code>; 就可以在浏览器面板中看到<code>2</code>，这其中发生了什么事情呢?(简单扫一眼)</li><li>首先键盘输入代码<code>1+1</code>到显示器输出<code>2</code>, 需要<code>CPU</code>控制键盘（输入设备） ，将获取的<code>1+1</code>指令放入内存</li><li>然后CPU的控制器从内存中取出指令，并分析出指令是让计算机做一个<code>1+1</code>的加法运算</li><li>此时CPU的控制将控制CPU的运算器做<code>1+1</code>的加法运算，并得出结果<code>2</code></li><li>最后CPU控制器控制运算器将结果返给内存，内存也在CPU控制器的控制下，将结果<code>2</code>返回给屏幕（输出设备）</li></ul><p>好了，这里问题是，如果没有操作系统，一个简单的1+1运算，你的js代码还需要考虑这些硬件的协调工作，比如你的代码要协调CPU资源什么时候读取你的代码，什么时候把进程切换到别的进程。。。这些脏活累活都是操作系统帮你屏蔽了，要不这代码可咋写啊。。。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/625bd319664a4c47ac3e09c42af27648~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h3 id="弱弱的问一问-前端学这个干嘛？"><a href="#弱弱的问一问-前端学这个干嘛？" class="headerlink" title="弱弱的问一问: 前端学这个干嘛？"></a>弱弱的问一问: 前端学这个干嘛？</h3><p>很早以前看朴零大神的《深入浅出NodeJS》的时候，讲到进程间通信，有一句大概说，windows平台进程间通信用的是管道，linux平台用的是domain socket，我一看就傻眼了，啥是进程间通信？啥是管道？啥是domain socket？😭 看不懂啊….  这些都是跟操作系统进程的知识相关）。</p><p>啥也了不说了，兄弟，学习的小车已经粗发了！</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bed1a16e29e94f2493459b2ac958daa1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h3 id="2、操作系统运行机制和体系结构"><a href="#2、操作系统运行机制和体系结构" class="headerlink" title="2、操作系统运行机制和体系结构"></a>2、操作系统运行机制和体系结构</h3><p>预备知识： 什么是指令（更详细内容请看我的计算机组成原理文章）</p><p>比如说，如下图（简单扫一下即可）：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7e94d10138444fca675d3e78771cd3d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>a+b是一段程序代码，a+b在CPU看来并不能一步完成，可以翻译成如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 意思是将内存的<span class="number">16</span>号单元数据，放到<span class="selector-tag">A</span>寄存器，</span><br><span class="line">LOAD <span class="selector-tag">A</span>, <span class="number">16</span></span><br><span class="line">// 意思是将内存的<span class="number">16</span>号单元数据，放到<span class="selector-tag">B</span>寄存器</span><br><span class="line">LOAD <span class="selector-tag">B</span>, <span class="number">17</span></span><br><span class="line">// 存器里的<span class="selector-tag">A</span>,<span class="selector-tag">B</span>数据相加，得到C</span><br><span class="line">ADD C, <span class="selector-tag">A</span>, <span class="selector-tag">B</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里就可以看得出来，指令是<code>CPU</code>能<code>识别</code>和<code>执行</code>的最基本命令。</p><h4 id="2-1-两种指令、两种处理器状态、两种程序"><a href="#2-1-两种指令、两种处理器状态、两种程序" class="headerlink" title="2.1 两种指令、两种处理器状态、两种程序"></a>2.1 两种指令、两种处理器状态、两种程序</h4><p>假如说一个用户可以随意把服务器上的所有文件删光，这是很危险的。所以有些指令普通用户是不能使用的，只能是<code>权限较高</code>的用户能使用。此时指令就分为了两种，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c63454bc3f6d47ada18e16ac8b1448bb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>这就引出一个问题：CPU<code>如何判断</code>当前是否可以执行<code>特权指令</code>？ 如下图: <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ffec6ba8bb84fd3b671562ddaa4dd3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> CPU通常有两种工作模式即：<code>内核态</code>和<code>用户态</code>，而在PSW（这个不用管，就知道有一个寄存器的标志位0表示用户态，1表示核心态）中有一个二进制位控制这两种模式。</p><p>对于应用程序而言，有的程序能执行特权指令，有的程序只能执行非特权指令。所以操作系统里的程序又分为两种：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2b1d866079496989d6aa802976c718~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="2-2-操作系统内核简单介绍"><a href="#2-2-操作系统内核简单介绍" class="headerlink" title="2.2 操作系统内核简单介绍"></a>2.2 操作系统内核简单介绍</h4><p>从下图，我们先看看操作系统内核包含哪些</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7aad0ff1519c45e88923eac0ca186ff1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>操作系统内核中跟硬件紧密相关的部分有：</p><ul><li>时钟管理。操作系统的时钟管理是依靠<code>硬件定时器</code>的（具体硬件怎么实现我也不太清楚，好像是靠硬件周期性的产生一个脉冲信号实现的）。时钟管理相当重要，比如我们<code>获取时间信息</code>，<code>进程切换</code>等等都是要依靠时钟管理。</li><li>中断处理（下一小节会详细介绍）。</li><li>原语（后面会有案例提到）。现在可以简单理解为用来实现某个特定功能，在执行过程中<code>不可被中断</code>的指令集合。原语有一个非常重要的特性，就是原子性（其运行<code>一气呵成，不可中断</code>）。</li></ul><h4 id="2-3-中断"><a href="#2-3-中断" class="headerlink" title="2.3 中断"></a>2.3 中断</h4><ul><li>在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU<code>暂时中止程序的执行</code>转而<code>处理这个新的情况</code>的过程就叫做<code>中断</code>。 下面举一个例子：</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbb1d6ab19194af0990f24f1d4f3b54c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 第一个应用程序在用户态执行了一段时间后 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62afac3d324d4d4db8a4e6e594861cfd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 接着操作系统切换到核心态，处理中断信号 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff2fa4931c914df39b70b5165d50e5d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>操作系统发现<code>中断的信号</code>是第一个程序的时间片（每个程序不能一直执行，CPU会给每个程序一定的执行时间，这段时间就是时间片）用完了，应该换第二个应用程序执行了</li><li>切换到<code>第2个进程</code>后，操作系统会将<code>CPU</code>的<code>使用权</code>交换给第二个应用程序，接着第二个应用程序就在<code>用户态</code>下开始执行。</li><li><code>进程</code>2需要调用<code>打印机资源</code>，这时会执行一个<code>系统调用</code>（后面会讲系统调用，这里简单理解为需要操作系统进入核心态处理的函数），让操作系统进入核心态，去调用打印机资源</li><li>打印机开始工作，<code>此时进程2</code>因为要等待打印机启动，操作系统就不等待了（等到打印机准备好了，再回来执行程序2），直接切换到<code>第三个应用程序</code>执行</li><li>等到打印机准备好了，此时打印机通过I/O控制器会给操作系统发出一<code>个中断信号</code>，操作系统又进入到核心态，发现这个中断是因为<code>程序2</code>等待打印机资源，现在打印机准备好了，就切换到<code>程序2</code>，切换到<code>用户态</code>，把CPU给程序2继续执行。</li></ul><p>好了，现在可以给出一个结论，就是用户态、核心态之间的切换是怎么实现的?</p><ul><li>“用户态 —&gt; 核心态”是通过中断实现的。<code>并且中断时唯一途径</code>。</li><li>“核心态 —&gt; 用户态”的切换时通过执行一个特权指令，将程序状态的标志位设为用户态。</li></ul><h4 id="2-4-中断的分类"><a href="#2-4-中断的分类" class="headerlink" title="2.4 中断的分类"></a>2.4 中断的分类</h4><p>举一个例子，什么是内中断和外中断：</p><p>接着说之前的范桶同学，小时候不爱学习，每次学习着学习着突然异想天开，回过神来已经过好好长一段时间，这是<code>内部中断</code>。想着想着老师走过来，给了范捅一嘴巴，这是<code>外部中断</code>。</p><p>官方解释如下： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dcf78ddde4945f0b93f7d55952f64da~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>内中断常见的情况如<code>程序非法操作</code>(比如你要拿的的数据的内存地址不是内存地址，是系统无法识别的地址)，<code>地址越界</code>(比如系统给你的程序分配了一些内存，但是你访问的时候超出了你应该访问的内存范围)、<code>浮点溢出</code>(比如系统只能表示1.1到5.1的范围，你输入一个100, 超出了计算机能处理的范围)，或者<code>异常</code>，<code>陷入trap</code>（是指应用程序请求系统调用造成的，什么是系统调用，后面小节会举例讲）。</li><li>外中断常见的情况如<code>I/O中断</code>（由I/O控制器产生，用于发送信号通知操作完成等信号，比如进程需要请求打印机资源，打印机有一个启动准备的过程，准备好了就会给CPU一个I/O中断，告诉它已经准备好了）、<code>时钟中断</code>（由处理器内部的计时器产生，允许操作系统以一定规程执行函数，操作系统每过大约15ms会进行一次线程调度，就是利用时钟中断来实现的）。</li></ul><h4 id="2-5-系统调用"><a href="#2-5-系统调用" class="headerlink" title="2.5 系统调用"></a>2.5 系统调用</h4><blockquote><p>为什么需要系统调用？</p></blockquote><ul><li>比如你的程序需要<code>读取文件信息</code>，可读取文件属于<code>读取硬盘里的数</code>据，这个操作应该时CPU在<code>内核态</code>去完成的，我们的应用程序怎么让CPU去帮助我们切换到内核态完成这个工作呢，这里就需要<code>系统调用了</code>。</li><li>这里就引出系统调用的概念和作用。</li><li>应用程序<code>通过系统调用请求操作系统的服务</code>。系统中的各种共享资源都由操作系统统一管理，因此在用户程序中，凡是与<code>资源有关的操作</code>（如存储分配、I/O操作、文件管理等），都<code>必须</code>通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。</li></ul><p>以下内容简单看一下即可，系统调用的分类：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63e2b27cc0914088a2d0357ab332ade7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>需要注意的是，<code>库函数</code>和<code>系统调用</code>容易混淆。</p><ul><li>库是可重用的模块 <code>处于用户态</code></li><li>进程通过系统调用从用户态进入<code>内核态</code>， 库函数中有很大部分是对系统调用的封装</li></ul><p>举个例子：比如<code>windows</code>和<code>linux</code>中，创建进程的系统调用方法是不一样的。 但在node中的只需要调用相同函数方法就可以创建一个进程。例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入创建子进程的模块</span></span><br><span class="line"><span class="keyword">const</span> childProcess = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取cpu的数量</span></span><br><span class="line"><span class="keyword">const</span> cpuNum = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).<span class="title function_">cpus</span>().<span class="property">length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建与cpu数量一样的子进程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">  childProcess.<span class="title function_">fork</span>(<span class="string">&#x27;./worker.js&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-6-进程的定义、组成、组织方式、状态与转换"><a href="#2-6-进程的定义、组成、组织方式、状态与转换" class="headerlink" title="2.6 进程的定义、组成、组织方式、状态与转换"></a>2.6 进程的定义、组成、组织方式、状态与转换</h4><h5 id="2-6-1-为什么要引入进程的概念呢？"><a href="#2-6-1-为什么要引入进程的概念呢？" class="headerlink" title="2.6.1 为什么要引入进程的概念呢？"></a>2.6.1 为什么要引入进程的概念呢？</h5><ul><li>早期的计算机只支持<code>单道程序</code>（是指所有进程一个一个排队执行，A进程执行时，CPU、内存、I/O设备全是A进程控制的，等A进程执行完了，才换B进程，然后对应的资源比如CPU、内存这些才能换B用）。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85d60c74edfc4e9485fba703f52dd97e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></li><li>现代计算机是<code>多道程序</code>执行，就是同时看起来有多个程序在一起执行，那每个程序执行都需要系统分配给它资源来执行，比如<code>CPU</code>、<code>内存</code>。</li><li>拿内存来说，操作系统要知道给A程序分配的内存有哪些，给B程序分配的内存有哪些，这些都要有小本本记录下来，这个小本本就是进程的一部分，进程的一大职责就是<code>记录目前程序运行的状态</code>。</li><li>系统为每个运行的程序配置一个数据结构，称为<code>进程控制块</code>（PCB），用来描述进程的各种信息（比如代码段放在哪）。</li></ul><h5 id="2-6-2-进程的定义？"><a href="#2-6-2-进程的定义？" class="headerlink" title="2.6.2 进程的定义？"></a>2.6.2 进程的定义？</h5><p>简要的说，进程就是具有<code>独立功能的程序</code>在数据集合上<code>运行的过程</code>。(强调动态性)</p><h5 id="2-6-3-PCB有哪些组成"><a href="#2-6-3-PCB有哪些组成" class="headerlink" title="2.6.3 PCB有哪些组成"></a>2.6.3 PCB有哪些组成</h5><p>如下图，分别说明一下 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fad302f1961248dc8489739fd8e28c46~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li><code>进程标识符PID</code>相当于身份证。是在进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，<code>用于区分不同的进程</code>。</li><li>用户标识符<code>UID</code>用来表示这个进程<code>所属的用户</code>是谁。</li><li>进程当前状态和优先级下一小节会详细介绍</li><li>程序段指针是指当前进程的程序在<code>内存的什么地方</code>。</li><li>数据段指针是指当前进程的数据在<code>内存的什么地方</code>。</li><li>键盘和鼠标是指进程被<code>分配得到的I/O设备</code>。</li><li>各种寄存器值是指比如把程序计数器的值，比如有些计算的结果算到一半，进程切换时需要把这些值保存下来。</li></ul><h5 id="2-6-4-进程的组织"><a href="#2-6-4-进程的组织" class="headerlink" title="2.6.4 进程的组织"></a>2.6.4 进程的组织</h5><p>在一个系统中，通常由数十、数百乃至数千个<code>PCB</code>。为了对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。这里介绍一种组织方式，类似数据结构里的链表。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80201fdf7ce242f18174dcb18ff4b833~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h5 id="2-6-5-进程的状态"><a href="#2-6-5-进程的状态" class="headerlink" title="2.6.5 进程的状态"></a>2.6.5 进程的状态</h5><p><code>进程是程序的一次执行。</code>在这个执行过程中，有时进程正在<code>被CPU处理</code>，有时又需要<code>等待CPU服务</code>，可见，进程的 状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p><p>进程的三种基本状态：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b732a28a9ad435f8f20b365edd08916~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>进程的另外两种状态：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cea105addf6473da486e64fe6b9be56~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h5 id="2-6-6-进程状态的转换"><a href="#2-6-6-进程状态的转换" class="headerlink" title="2.6.6 进程状态的转换"></a>2.6.6 进程状态的转换</h5><p>进程的状态并不是一成不变的，在一定情况下会动态转换。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ce930479dc4ba0a6fb021198de671d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>以上的这些进程状态的转换是如何实现的呢，这就要引出下一个角色了，叫`原语。</p><ul><li>原语是<code>不可被中断</code>的原子操作。我们举一个例子看看原语是怎么保证不可中断的。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca6a27dd09f14178870960ad305ae3ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 原语采用<code>关中断指令</code>和<code>开中断指令</code>实现。</p><ul><li>首先执行关中断指令</li><li>然后外部来了中断信号，不予以处理</li><li>等到开中断指令执行后，其他中断信号才有机会处理。</li></ul><h4 id="2-6-进程的通信"><a href="#2-6-进程的通信" class="headerlink" title="2.6 进程的通信"></a>2.6 进程的通信</h4><blockquote><p>为什么需要进程间通信呢？</p></blockquote><p>因为进程是<code>分配系统资源的单位</code>（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/763951d99b6a4ba3992415554d9fec2e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h5 id="2-6-1-进程通信方法—共享存储"><a href="#2-6-1-进程通信方法—共享存储" class="headerlink" title="2.6.1 进程通信方法—共享存储"></a>2.6.1 进程通信方法—共享存储</h5><p>因为两个进程的存储空间<code>不能相互访问</code>，所以操作系统就提供的一个内存空间让彼此都能访问，这就是共享存储的原理。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca7157b11dd74f8e90dd42f9b5dd9cf4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>其中，介绍一下基于存储区的共享。</p><ul><li>在内存中画出一块<code>共享存储区</code>，数据的形式、存放位置都是由进程控制，而不是操作系统。</li></ul><h5 id="2-6-2-进程通信方法—管道"><a href="#2-6-2-进程通信方法—管道" class="headerlink" title="2.6.2 进程通信方法—管道"></a>2.6.2 进程通信方法—管道</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36e3b665bee04bcfbb0a20c359f76c3c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>管道数据是以<code>字符流</code>（注意不是字节流）的形式写入管道，当管道写满时，写进程的<code>write()</code>系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的<code>read()</code>系统调用将被阻塞。</li><li>如果没写满就不允许读。如果都没空就不允许写。</li><li>数据一旦被读出，就从管道中被丢弃，这就意味着<code>读进程</code>最多只能有一个。</li></ul><h5 id="2-6-3-进程通信方法—消息传递"><a href="#2-6-3-进程通信方法—消息传递" class="headerlink" title="2.6.3 进程通信方法—消息传递"></a>2.6.3 进程通信方法—消息传递</h5><p>进程间的数据交换以<code>格式化的消息</code>为单位。进程通过操作系统提供的<code>&quot;发送消息/接收消息&quot;</code>两个原语进行数据交换。</p><p>其中消息是什么意思呢？就好像你发QQ消息，消息头的来源是你，消息体是你发的内容。如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66fee389dbd44c39b57d3883ec13f441~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>接下来我们介绍一种<code>间接通信</code>的方式（很像中介者模式或者发布订阅模式）, 如下图：中介者是信箱，进程通过它来收发消息。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c7ab1f18d704b9fbcebef25447cbc80~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="2-7-线程"><a href="#2-7-线程" class="headerlink" title="2.7 线程"></a>2.7 线程</h4><blockquote><p>为什么要引入线程呢？</p></blockquote><ul><li>比如你在玩QQ的时候，QQ是一个进程，如果QQ的进程里没有多线程并发，那么QQ进程就只能<code>同一时间做一件事情</code>（比如QQ打字聊天）</li><li>但是我们真实的场景是QQ聊天的同时，还可以发文件，还可以视频聊天，这说明如果QQ<code>没有多线程并发能力</code>，QQ能够的实用性就大大降低了。所以我们<code>需要线程</code>，也就是<code>需要进程拥有能够并发</code>多个事件的能力。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30a1f85b6c474ed794feaa05d758341a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>引入线程后带来的变化 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2eeee2b2646477ea6806ca40e8cb1f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h3 id="3-进程的同步和互斥"><a href="#3-进程的同步和互斥" class="headerlink" title="3 进程的同步和互斥"></a>3 进程的同步和互斥</h3><blockquote><p>同步。是指多个进程中发生的事件存在某种先后顺序。即某些进程的执行必须先于另一些进程。</p></blockquote><p>比如说<code>进程A</code>需要从缓冲区读取<code>进程B</code>产生的信息，当缓冲区为空时，<code>进程B</code>因为读取不到信息而被阻塞。而当<code>进程A</code>产生信息放入缓冲区时，<code>进程B</code>才会被唤醒。概念如图1所示。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43bc18cf5524f659a9ecfd8f8ccd5ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><blockquote><p>互斥。是指多个进程不允许同时使用同一资源。当某个进程使用某种资源的时候，其他进程必须等待。</p></blockquote><p>比如<code>进程B</code>需要访问打印机，但此时<code>进程A</code>占有了打印机，<code>进程B</code>会被阻塞，直到<code>进程A</code>释放了打印机资源,进程B才可以继续执行。概念如图3所示。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f49d7a510234059a036db17621e6611~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="3-1-信号量（了解概念即可）"><a href="#3-1-信号量（了解概念即可）" class="headerlink" title="3.1 信号量（了解概念即可）"></a>3.1 信号量（了解概念即可）</h4><p><code>信号量</code>主要是来解决进程的<code>同步</code>和<code>互斥</code>的，我们前端需要了解，如果涉及到同步和互斥的关系（我们编程大多数关于流程的逻辑问题，本质不就是同步和互斥吗？）</p><p>在操作系统中，常用<code>P、V信号量</code>来实现进程间的<code>同步</code>和<code>互斥</code>，我们简单了解一下一种常用的信号量，<code>记录型信号量</code>来简单了解一下信号量本质是怎样的。（c语言来表示，会有备注）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 剩余资源</span></span><br><span class="line">    Struct process *L <span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>意思是信号量的结构有两部分组成，<code>一部分是剩余资源value</code>，比如目前有两台打印机空闲，那么剩余资源就是2，谁正在使用打印机，剩余资源就减1。</p><p><code>Struct process *L </code>意思是，比如2台打印机都有人在用，这时候你的要用打印机，此时会把这个打印机资源的请求放入阻塞队列，L就是阻塞队列的地址。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*P 操作，也就是记录型信号量的请求资源操作*/</span></span><br><span class="line">void wait (semaphore S) &#123;</span><br><span class="line">    S<span class="selector-class">.value--</span>;</span><br><span class="line">    if (S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        block (S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要注意的是，如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列中。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*V 操作，也就是记录型信号量的释放资源操作*/</span></span><br><span class="line">void singal (semaphore S) &#123;</span><br><span class="line">    S<span class="selector-class">.value</span>++;</span><br><span class="line">    if (S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        wakeup (S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>释放资源后，若还有别的进程在等待这个资源，比如打印机资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为继续态。</p><h4 id="3-2-生产者消费者问题（了解概念即可）"><a href="#3-2-生产者消费者问题（了解概念即可）" class="headerlink" title="3.2 生产者消费者问题（了解概念即可）"></a>3.2 生产者消费者问题（了解概念即可）</h4><p>为什么要讲这个呢，主要是node的流的机制，本质就是生产者消费者问题，可以简单的看看这个问题如何解决。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1e2c682268d41ca8c83534fa084a99c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 如上图，<code>生产者</code>的主要作用是生成<code>一定量的数据放到缓冲区中</code>，然后<code>重复此过程</code>。与此同时，消费者也在<code>缓冲区消耗这些数据</code>。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>这里我们需要两个同步信号量和一个互斥信号量</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 互斥信号量，实现对缓冲区的互斥访问</span><br><span class="line">semaphore <span class="attr">mutex</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">// 同步信号量，表示目前还可以生产几个产品</span><br><span class="line">semaphore <span class="attr">empty</span> = n<span class="comment">;</span></span><br><span class="line">// 同步信号量，表示目前可以消耗几个产品</span><br><span class="line">semaphore <span class="attr">full</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>生产者代码如下</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">producer () &#123;</span><br><span class="line">    <span class="built_in">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 生产一个产品</span></span><br><span class="line">        <span class="selector-tag">P</span>(empty);</span><br><span class="line">        <span class="comment">// 对缓冲区加锁</span></span><br><span class="line">        <span class="selector-tag">P</span>(mutex);</span><br><span class="line">        这里的代码是生产一个产品</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="comment">// 产出一个产品</span></span><br><span class="line">        <span class="built_in">V</span>(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>消费者代码如下</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">producer () &#123;</span><br><span class="line">    <span class="built_in">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 消费一个产品</span></span><br><span class="line">        <span class="selector-tag">P</span>(full);</span><br><span class="line">        <span class="comment">// 对缓冲区加锁</span></span><br><span class="line">        <span class="selector-tag">P</span>(mutex);</span><br><span class="line">        这里的代码是消费一个产品</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="comment">// 消费一个产品</span></span><br><span class="line">        <span class="built_in">V</span>(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-内存的基础知识和概念"><a href="#4-内存的基础知识和概念" class="headerlink" title="4 内存的基础知识和概念"></a>4 内存的基础知识和概念</h3><blockquote><p>为什么需要内存</p></blockquote><p>内存是计算机<code>其它硬件设备</code>与<code>CPU沟通</code>的桥梁、中转站。程序执行前需要先放到内存中才能被CPU处理。</p><h4 id="4-1-cpu如何区分执行程序的数据在内存的什么地方"><a href="#4-1-cpu如何区分执行程序的数据在内存的什么地方" class="headerlink" title="4.1 cpu如何区分执行程序的数据在内存的什么地方"></a>4.1 cpu如何区分执行程序的数据在内存的什么地方</h4><ul><li>是通过给<code>内存的存储单元编址</code>实现的。（存储单元一般是以字节为单位）</li><li>如下图，内存的存储单元，就像一个酒店的房间，都有编号，比如程序一的数据都在1楼，1楼1号存储着程序里<code>let a = 1</code>这段代码。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a38ed59e7b0490d8cf33f1918aad2b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="4-2-内存管理-内存空间的分配与回收"><a href="#4-2-内存管理-内存空间的分配与回收" class="headerlink" title="4.2 内存管理-内存空间的分配与回收"></a>4.2 内存管理-内存空间的分配与回收</h4><ul><li>内存分配分为<code>连续分配</code>和<code>非连续分配</code>，连续分配是指用户进程分配的必须是<code>一个连续的内存空间</code>。</li><li>这里我们只讲连续分配中的<code>动态分区分配</code>。</li><li>什么是动态分区分配呢，这种分配方式<code>不会预先划分内存分区</code>，而是在进程装入内存时，根据进程的大小<code>动态地</code>建立分区，并使分区的大小<code>正好适合</code>进程的需要。（比如，某计算机内存大小64MB，系统区8MB，用户区56MB…，现在我们有几个进程要装入内存，如下图）</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffd33160b37145b1b88cac9291623cac~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>随之而来的问题就是，如果此时进程1使用完了，相应在内存上的数据也被删除了，那么<code>空闲的区域</code>，后面该怎么分配（也就是说随着进程退出，会有很多空闲的内存区域出现）</li></ul><p>我们讲一种较为简单的处理方法叫<code>空闲分区表</code>法来解决这个问题。如下图，右侧的表格就是一个空闲分区表。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a68dfb01459c42c6903079072272157d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配呢，例如下图，分别有<code>20MB</code>，<code>10MB</code>，<code>4MB</code>三个空闲分区块，现在<code>进程5</code>需要<code>4MB</code>空闲分区，改怎么分配呢？</p><p>我们需要按照一定的动态分区分配算法，比如有<code>首次适应算法</code>，指的是每次都从低地址开始查找，找到第一个能满足大小的空闲分区。还有比如<code>最佳适应算法</code>，指的是从空闲分区表中找到最小的适合分配的分区块来满足需求。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b26aa3c975264ceea6d3ed652d1c6614~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p><code>连续分配缺点很明显</code>，大多数情况，需要分配的进程大小，不能跟空闲分区剩下的大小完全一样，这样就产生很多很难利用的<code>内存碎片</code>。</p><p>这里我们介绍一种更好的空闲分区的分配方法，<code>基本分页存储</code>。如下图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd268e0a431a4b15ae4296bfca89694a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 将内存空间分为<code>一个个大小相等</code>的分区（比如：每个分区<code>4KB</code>）.每个分区就是一个<code>“页框”</code>。页框号从<code>0</code>开始。</p><p>将用户进程的地址空间分为与页框大小相等的一个个区域，称为<code>“页”</code>。每个页也是从<code>0</code>开始。</p><h3 id="5-文件管理"><a href="#5-文件管理" class="headerlink" title="5 文件管理"></a>5 文件管理</h3><blockquote><p>文件是什么？</p></blockquote><p>文件就是一组有意义的<code>信息/数据</code>集合。</p><p>计算机中存放了各种各样的文件，一个文件有哪些属性呢？文件内部的数据应该怎样组织起来？文件之间又该怎么组织起来？</p><h4 id="5-1-文件的属性"><a href="#5-1-文件的属性" class="headerlink" title="5.1 文件的属性"></a>5.1 文件的属性</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6421765e1ce4a9cb65e43d141024eb7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>文件名。即文件的名字，需要注意的是，同一目录下<code>不允许</code>有重名的文件。</li><li>标识符。操作系统用于区分各个文件的一种<code>内部的名称</code>。</li><li>类型。文件的类型。</li><li>位置。文件<code>存放的路径</code>，同时也是在硬盘里的位置（需要转换成物理硬盘上的地址）</li><li>创建时间、上次修改时间、文件所有者就是字面意思。</li><li>保护信息。比如对这个文件的<code>执行权限</code>，是否有删除文件权限，修改文件权限等等。</li></ul><h4 id="5-2-文件内部数据如何组织在一起"><a href="#5-2-文件内部数据如何组织在一起" class="headerlink" title="5.2 文件内部数据如何组织在一起"></a>5.2 文件内部数据如何组织在一起</h4><p>如下图，文件主要分为<code>有结构文件</code>和<code>无结构文件</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f1af8437fa94756b1b43fd6bf33b192~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="5-3-文件之间如何组织起来"><a href="#5-3-文件之间如何组织起来" class="headerlink" title="5.3 文件之间如何组织起来"></a>5.3 文件之间如何组织起来</h4><p>通过<code>树状结构</code>组织的。例如<code>windows</code>的文件间的组织关系如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/432b2dcbf38c4a8980f4870e1d6b4c9c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>接下来我们详细的了解一下<code>文件的逻辑结构</code></p><h4 id="5-4-文件的逻辑结构"><a href="#5-4-文件的逻辑结构" class="headerlink" title="5.4 文件的逻辑结构"></a>5.4 文件的逻辑结构</h4><p>逻辑结构是指，在用户看来，文件内部的数据是如何组织起来的，而<code>“物理结构”</code>是在操作系统看来，文件是如何保存在外存，比如<code>硬盘</code>中的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70dc16b172314e5db51fc5d04d8a064e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>比如，<code>“线性表”</code>就是一种逻辑结构，在用户看来，线性表就是一组有先后关系的元素序列，如：<code>a,b,c,d,e....</code></p><ul><li><code>“线性表”</code>这种逻辑结构可以用不同的物理结构实现，比如：<code>顺序表/链表</code>。<code>顺序表</code>的各个元素在逻辑上相邻，在物理上也相邻：而<code>链表</code>的各个元素在物理上可以是不相邻的。</li><li>因此，顺序表可以实现<code>“随机访问”</code>，而<code>“链表”</code>无法实现随机访问。</li></ul><p>接下来我了解一下有结构文件的三种逻辑结构</p><h5 id="5-4-1-顺序文件"><a href="#5-4-1-顺序文件" class="headerlink" title="5.4.1 顺序文件"></a>5.4.1 顺序文件</h5><blockquote><p>什么是顺序文件</p></blockquote><p>指的是文件中的记录一个接一个地在逻辑上是<code>顺序排列</code>，记录可以是<code>定长</code>或<code>变长</code>，各个记录在物理上可以<code>顺序存储</code>或<code>链式存储</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5a6f71703a849c3a2a3b3d10f521481~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>顺序文件按结构来划分，可以分为<code>串结构</code>和<code>顺序结构</code>。</li><li>串结构是指记录之间的顺序与<code>关键字无关</code>，通常都是按照记录的时间决定记录的顺序。</li><li>顺序结构就必须保证记录之间的先后顺序按<code>关键字排列</code>。</li></ul><p>这里需要注意的知识点是，顺序文件的存储方式和是否<code>按关键字排列</code>，会影响数据<code>是否支持随机存取</code>和<code>是否可以快速按关键字找到对应记录</code>的功能。</p><p>可以看到，顺序文件按顺序存放对于查找是非常有帮助的，我们在记录文件的时候也可以注意利用这一点。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d09c18951374a87b2add0bd911adb45~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h5 id="5-4-2-索引文件"><a href="#5-4-2-索引文件" class="headerlink" title="5.4.2 索引文件"></a>5.4.2 索引文件</h5><p>对于<code>可变长记录文件</code>，要找到<code>第i</code>个记录，必须先顺序查找<code>前i-1</code>个记录（也就是需要遍历一遍），但是很多场景中又必须使用可变长记录，如何解决这个问题呢？这就引出来马上讲的<code>索引文件</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63a6c065b6404ad7a095d76fa7427be5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>给这些变长的记录都用一张索引表来记录，一个索引表项包括了<code>索引号</code>，<code>长度</code>和<code>指针</code>。</li><li>其中，可以将关键字作为索引号的内容，如果关键字本身的排列是有序的，那么还可以按照关键字进行折半查找。这里是关键，因为我们平时用mysql数据库对某个字段假如索引，就是这个道理。</li><li>但是建立索引表的问题也很明显，首先若要<code>删除/增加</code>一个记录，同时也要对<code>索引表</code>操作，其次，如果<code>增加一条记录才1KB</code>，但是索引表<code>增加i一条记录可能有8KB</code>，以至于索引表的体积大大多于记录。存储空间的利用率就比较低。</li></ul><h5 id="5-4-3-索引顺序文件"><a href="#5-4-3-索引顺序文件" class="headerlink" title="5.4.3 索引顺序文件"></a>5.4.3 索引顺序文件</h5><p>索引顺序文件是<code>索引文件</code>和<code>顺序文件</code>思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是，并不是每个记录对应一个<code>索引表项</code>，而是一组记录对应一个索引表项。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a70b298461f4e84970428384a9d3e45~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>如上图，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不需要按关键字排序</p><h4 id="5-5-文件目录"><a href="#5-5-文件目录" class="headerlink" title="5.5 文件目录"></a>5.5 文件目录</h4><p>首先，我们需要了解一下<code>文件控制</code>块是什么。我们假设目前在<code>windows的D盘</code>，如下图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae80fe1578784a6abf0649f7e404d215~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>可以看到，目录本身就是一种<code>有结构的文件</code>，记录了目录里的<code>文件</code>和<code>目录</code>的信息，比如名称和类型。而这些一条条的记录就是一个个的<code>“文件控制块”（FCB）</code>。</p><p>文件目录的结构通常是<code>树状的</code>，例如linux里<code>/</code>是指根路径，<code>/home</code>是根路径下的二级目录</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f8e8b78cf9a43bd8ec0e3913eb69d53~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>需要注意的是，树状目录<code>不容易实现文件共享</code>，所以在树形目录结构的基础上，增加了一些指向同一节点的有向边（可以简单理解为引用关系，就跟js里的对象一样）</li><li>也就是说需要为<code>每个共享节点</code>设置一个<code>共享计数器</code>，用于记录此时有多少个地方在共享该结点。只有<code>共享计数器减为0</code>，才删除该节点。</li></ul><h4 id="文件分配方式（物理分配）"><a href="#文件分配方式（物理分配）" class="headerlink" title="文件分配方式（物理分配）"></a>文件分配方式（物理分配）</h4><p>我们这里介绍一种索引分配的方式：</p><p>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表记录了文件各个逻辑块对应的物理块。索引表存放的磁盘块称为索引快。文件数据存放的磁盘块称为数据块。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc8174ebcc114535bba6c176aa994c2e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="截屏2021-07-30 上午8.48.45.png"></p><p>如上图，假设某个新创建的文件’aaa’的数据依次存放磁盘块2-&gt;5-&gt;13&gt;9。7号磁盘块作为’aaa‘的索引块，索引块保存了索引表的内容</p><h4 id="文件的逻辑分配和物理分配"><a href="#文件的逻辑分配和物理分配" class="headerlink" title="文件的逻辑分配和物理分配"></a>文件的逻辑分配和物理分配</h4><p>上面我们讲到了文件的逻辑分配，是站在用户视角的分配，物理分配是站在操作系统的角度的分配，分配的是实际的物理磁盘里的空间。</p><p>举个例子，我们用户看到的文件，意识里都是顺序排列的，比如说，excel表有100行数据，用户看来这100行数据就是连续的。</p><p>在操作系统的视角，它可以把这100行数据分为一个个的数据块，比如跟磁盘块（假设磁盘块是1kb大小）一样都是1kb，拆分后的数据可以使用索引表的形式分配（也就是我们上面才讲了的，索引分配的方式，打散分配在实际的物理磁盘里）</p><h4 id="5-6-文件存储空间管理"><a href="#5-6-文件存储空间管理" class="headerlink" title="5.6 文件存储空间管理"></a>5.6 文件存储空间管理</h4><p>首先，我们了解一下磁盘分为<code>目录区</code>和<code>文件区</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52b8b0a5f7a3429086355bc4d270f413~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>接着，我们了解一下常见的两种<code>文件存储空间的管理算法</code>，如下图，假如硬盘上<code>空闲的数据块</code>是蓝色，<code>非空闲的数据</code>块是橙色。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cd7a2957b11495c9cdb1f36fe8a6da0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>对分配连续的存储空间，可以采用<code>空闲表法</code>（只讲这种较简单的方法）来<code>分配</code>和<code>回收</code>磁盘块。对于分配，可以采用首次适应，最佳适应等算法来决定要为文件分配哪个区间。（空闲表表示如下）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efaf172946114c8eb87b30a2ea169879~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li><code>首次适应</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>第一个满足条件</code>的空闲区间。</li><li><code>最佳适应算法</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>满足条件而且空闲块最小的空闲区间</code>。</li></ul><p>再讲一种位示图法</p><p>如下图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bb290ae36894a6f9c1403c4957b7bc3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p><p>每一个二进制位对应一个磁盘块，比如上面0表示空闲块，1表示已分配的块。而且我们可以通过一定的公式，可以从示图表的横纵坐标推断出物理块的实际地址，也可以从物理块的实际地址推断出在表里的横纵坐标。</p><h4 id="5-7-文件共享"><a href="#5-7-文件共享" class="headerlink" title="5.7 文件共享"></a>5.7 文件共享</h4><p>文件共享分为两种</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/678a819dc59c46cba3266249aa5ba27e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>注意，多个用户<code>共享同一个文件</code>，意味着系统只有<code>“一份”</code>文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到<code>文件的变化</code>。</li><li>软连接可以理解为<code>windows</code>里的<code>快捷方式</code>。</li><li>硬链接可以理解为js里的<code>引用计数</code>，只有引用为<code>0</code>的时候，才会真正删除这个文件。</li></ul><h4 id="5-8-文件保护"><a href="#5-8-文件保护" class="headerlink" title="5.8 文件保护"></a>5.8 文件保护</h4><p>操作系统需要保护文件的安全，一般有如下3种方式：</p><ul><li>口令保护。是指为文件设置一个<code>“口令”</code>（比如123），用户请求访问该文件时必须提供对应的口令。口令一般放在文件对应的<code>FCB或者索引结点</code>上。</li><li>加密保护。使用某个<code>&quot;密码&quot;</code>对文件进行加密，在访问文件时需要提供<code>正确的“密码”</code>才能对文件进行正确的解密。</li><li>访问控制。在每个文件的FCB或者索引节点种增加一个<code>访问控制列表</code>，该表中记录了各个用户可以对该文件执行哪些操作。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b30ba5541246ad90018aedce215a26~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h2 id="总结文件系统这块的内容"><a href="#总结文件系统这块的内容" class="headerlink" title="总结文件系统这块的内容"></a>总结文件系统这块的内容</h2><p>我们举一个实际案例，把上面的内容总结一下。</p><p>假如我们当前的操作系统采用如下的文件系统管理方式：</p><ul><li>文件的物理结构 — 索引分配（混合索引）</li><li>文件目录的实现 — inode结点</li><li>空闲分区管理 — 位示图法</li></ul><p>那么我们假设0号磁盘块就是装载位示图的磁盘块，用来管理哪些磁盘是空闲的哪些是正在使用的。 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5129b71fdcb34e3ab49b2de7469215ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>因为这里我们已经使用了0号块，位示图的第一项就是1</p><p>接着我们把磁盘块第二块用来放inode节点，也就是文件目录索引节点，意思是文件目录下存放的只有文件名和索引节点的位置，要知道文件的详细信息，就要靠着</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68935b04dd884171a13dd36c3584b73a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>假设2号磁盘块存放了我们根目录信息，而本身目录其实也是一种特殊的文件，也在inode节点表里有自己的信息，1号磁盘块增加类似如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型：目录</span><br><span class="line">存放在：2号磁盘块</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>2号磁盘块里面存放了一个<code>你好.txt</code>文件，那么2号磁盘块会增加一行信息，类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件名：你好.txt</span><br><span class="line">inode结点：2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这就意味着，2号inode节点存放了你好.txt文件的具体磁盘块在哪，所以在1号磁盘块的2号inode节点增加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型：txt</span><br><span class="line">存放在：3、4号磁盘块</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>为什么要放到3、4号磁盘块呢，因为我们有位示图，知道哪些磁盘块是空闲的就分配给它，一扫描发现3、4正空闲而且满足存放这个文件的条件，就分配出去了。</p><p>我们在细分一下这里的3、4号磁盘块是什么意思，因为我们物理磁盘块分配的方法是混合索引，其实3、4号磁盘块表示的形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接索引：3号磁盘块</span><br><span class="line">直接索引：4号磁盘块</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面只涉及到直接索引，我们其实还可以有1级索引，2级索引，这些索引指向的是一个索引表，我们这里就不详细叙述了（之前交过索引块和索引表）。</p><p>到这里我们们就基本明白了一个文件系统的基本运行原理。</p><h3 id="6-I-O设备"><a href="#6-I-O设备" class="headerlink" title="6 I/O设备"></a>6 I/O设备</h3><blockquote><p>什么是I/O设备</p></blockquote><p>I/O就是<code>输入输出</code>(Input/Output)的意思，I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/536eb5ac39434f8b8af6854229cca78a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><h4 id="6-1-I-O设备分类–按使用特性"><a href="#6-1-I-O设备分类–按使用特性" class="headerlink" title="6.1 I/O设备分类–按使用特性"></a>6.1 I/O设备分类–按使用特性</h4><ul><li>人机交互类设备，这类设备传输数据的速度慢</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcdfaebb040f4233be5f864b00905eae~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>存储设备，这类设备传输数据的速度较快</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89c845739cd242ea867cdc3a519fa784~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>网络通信设备，这类设备的传输速度介于人机交互设备和存储设备之间</li></ul><h4 id="6-2-I-O控制器"><a href="#6-2-I-O控制器" class="headerlink" title="6.2 I/O控制器"></a>6.2 I/O控制器</h4><p>CPU无法直接控制<code>I/O设备的机械部件</code>，因此I/O设备还要有一个电子部件作为<code>CPU</code>和<code>I/O设备</code>机械部件之间的<code>“中介”</code>，用于实现CPU对设备的控制。这个电子部件就是<code>I/O控制器</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c4431903aa8475688e9b181938a4e85~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><ul><li>接收和识别CPU发出的指令是指，比如CPU发来读取文件的命令，I/O控制器中会有相应的<code>控制寄存器</code>来存放命令和参数</li><li>向cpu报告设备的状态是指，I/O控制器会有相应的<code>状态寄存器</code>，用来记录I/O设备<code>是否空闲</code>或者<code>忙碌</code></li><li>数据交换是指I/O控制器会设置相应的<code>数据寄存器</code>。输出时，数据寄存器用于<code>暂存CPU发来的数据</code>，之后再由控制器传送给设备。</li><li>地址识别是指，为了区分设备控制器中的各个寄存器中的各个寄存器，也需要给各个寄存器设置一个特性的<code>“地址”</code>。I/O控制器通过CPU提供的“地址”来判断CPU要读写的是哪个寄存器</li></ul><h4 id="6-3-I-O控制方式"><a href="#6-3-I-O控制方式" class="headerlink" title="6.3 I/O控制方式"></a>6.3 I/O控制方式</h4><ul><li>这里我们指讲一下目前比较先进的方式，通道控制方式。</li><li>通道可以理解为一种<code>“弱鸡版CPU”</code>。通道可以识别并执行一系列通道指令。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1321294866e34aa99674e26e8780d7e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></li></ul><p>通道最大的优点是极大的<code>减少了CPU的干预频率</code>，<code>I/O设备</code>完成任务，通道会向CPU发出<code>中断</code>，不需要轮询来问I/O设备是否完成CPU下达的任务。</p><p>本文完结。</p><p>作者：孟祥_成都<br>链接：<a href="https://juejin.cn/post/6844904112803282957">https://juejin.cn/post/6844904112803282957</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git笔记</title>
      <link href="/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git详细学习"><a href="#Git详细学习" class="headerlink" title="Git详细学习"></a>Git详细学习</h1><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Ⅰ-Git操作"><a href="#Ⅰ-Git操作" class="headerlink" title="Ⅰ-Git操作"></a>Ⅰ-Git操作</h1><h2 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a>一、初始化</h2><blockquote><p>该处是用来提交时当作签名使用的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;我的用户名&quot;</span><br><span class="line">git config --global user.email &quot;我的邮箱&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除配置信息</span></span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></table></figure><h2 id="二、Git工作流程与区域"><a href="#二、Git工作流程与区域" class="headerlink" title="二、Git工作流程与区域"></a>二、Git工作流程与区域</h2><h3 id="1、区域"><a href="#1、区域" class="headerlink" title="1、区域"></a>1、区域</h3><ol><li><p>工作区</p><blockquote><p>平时写代码的文件目录</p></blockquote></li><li><p>暂存区</p><blockquote><p>git add 后提交暂存的地方</p></blockquote></li><li><p>版本库</p><blockquote><p>git commit 后给你生成版本的地方,注意push是提交到远程仓库而不是版本库,请勿混淆</p></blockquote></li></ol><h3 id="2、工作流程"><a href="#2、工作流程" class="headerlink" title="2、工作流程"></a>2、工作流程</h3><blockquote><p>每个项目都有一个Git目录(.git)他是Git用来保存元数据和对象数据库的地方.该目录非常重要,每次克隆镜像仓库的时候,实际拷贝的就是这个目录里的数据</p></blockquote><h5 id="①、在工作目录中修改某些文件"><a href="#①、在工作目录中修改某些文件" class="headerlink" title="①、在工作目录中修改某些文件"></a>①、在工作目录中修改某些文件</h5><blockquote><p>从项目中取出某个版本的所有文件和目录,用以开始后续工作的叫做工作目录,这些文件实际上都是从Git目录中的压缩对象数据库中提取出来的,接下去就可以在工作目录中对这些文件进行编辑</p></blockquote><h5 id="②、保存到暂存区域-对暂存区做快照"><a href="#②、保存到暂存区域-对暂存区做快照" class="headerlink" title="②、保存到暂存区域,对暂存区做快照"></a>②、保存到暂存区域,对暂存区做快照</h5><blockquote><p>暂存区域只不过是个简单的文件,一般都放在Git目录中,有时候人们会把这个区域的文件叫做索引文件,不过标准说法还是叫暂存区域</p></blockquote><h5 id="③、提交更新"><a href="#③、提交更新" class="headerlink" title="③、提交更新"></a>③、提交更新</h5><blockquote><p>将保存区在暂存区域的文件快照永久转储到本地数据库(Git目录)中</p></blockquote><p>我们可以从文件所处位置来判断状态:如果是Git目录中保存着的特定版本文件,就属于提交版本;如果做了修改并已放入暂存区域,就属于已暂存状态;如果自上次去除后,做了修改但还没有放到暂存区域,就是已修改状态</p><h2 id="三、对象详解-底层命令"><a href="#三、对象详解-底层命令" class="headerlink" title="三、对象详解(底层命令)"></a>三、对象详解(底层命令)</h2><h3 id="1、git对象"><a href="#1、git对象" class="headerlink" title="1、git对象"></a>1、git对象</h3><blockquote><ol><li>key:val 组成的键值对(key是val相应的hash)</li></ol><p>​        键值对在git内部是blob类型(git特有)</p><ol start="2"><li>存储数据文件内容,也称为数据对象</li></ol></blockquote><h5 id="①-直接写入git对象方法与读取-存入”-git-objects”"><a href="#①-直接写入git对象方法与读取-存入”-git-objects”" class="headerlink" title="① 直接写入git对象方法与读取(存入”.git/objects”)"></a>① 直接写入git对象方法与读取(存入”.git/objects”)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将打印内容写入对象(git数据库)并且返回其相应哈希值</span></span><br><span class="line">echo &quot;写入的对象内容&quot; | git hash-object -w --stdin </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取内容并不能直接<span class="built_in">cat</span>读取,因为git存入时已经加密,需要如下代码 -p:内容  -t:类型</span></span><br><span class="line">git cat-file -p 存入对象的哈希值(此值可以由上一步得到) </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将文件写入git对象,即我们常见的版本控制中出现的</span></span><br><span class="line">git hash-object -w ./test.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看Git存储的数据  返回其文件夹内的所有哈希文件</span></span><br><span class="line">find .git/objects -type f </span><br></pre></td></tr></table></figure><h3 id="2、树对象"><a href="#2、树对象" class="headerlink" title="2、树对象"></a>2、树对象</h3><blockquote><p>树对象是存储键值 作用为控制版本,如我们的版本前回退 就是在操作这个对象的(指向改变)</p><p>作用就是生成快照</p><p>这个也是git的必杀特性,因为他的切换分支与版本都很快 只是指针切换</p></blockquote><h4 id="构建树对象"><a href="#构建树对象" class="headerlink" title="构建树对象"></a>构建树对象</h4><blockquote><p>我们可以通过 update-index , write-tree , read-tree 等命令来构建树对象并且塞到暂存区</p></blockquote><h5 id="①-利用-update-index-命令-创建暂存区"><a href="#①-利用-update-index-命令-创建暂存区" class="headerlink" title="① 利用 update-index 命令 创建暂存区"></a>① 利用 <code>update-index</code> 命令 创建暂存区</h5><blockquote><p>利用 <code>update-index</code> 命令 为test.txt文件的首个版本创建一个暂存区,并通过<code>write-tree</code>命令生成树对象</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1生成一个树对象</span></span><br><span class="line">git update-index --add --cacheinfo 100664(文件状态码:普通文件) 哈希值 对应文件名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成快照(树对象)</span></span><br><span class="line">git write-tree</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2 将第一个树对象加入第二个树对象,使其成为新的树对象</span></span><br><span class="line">git read-tree -prefix=bak 哈希值(树对象的)  </span><br><span class="line">git write-tree</span><br></pre></td></tr></table></figure><h5 id="②-查看暂存区当前样子"><a href="#②-查看暂存区当前样子" class="headerlink" title="② 查看暂存区当前样子"></a>② 查看暂存区当前样子</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -s</span><br></pre></td></tr></table></figure><h3 id="3、提交对象"><a href="#3、提交对象" class="headerlink" title="3、提交对象"></a>3、提交对象</h3><blockquote><ol><li>通过上述两个对象操作后,你会发现你已经生成了不同项目的快照,但是问题是:如果想重用这些快照,你必须记住所有三个 SHA-1(快照)哈希值 .但是,你也完全不知道是谁保存了这些快照,在什么时刻保存的,以及为什么保存这些快照.而以上这些,正是提交对象(commit object)能为你保存的基本信息</li><li>我们可以通过调用commit-tree命令创建一个提交对象,为此需要指定一个树对象的SHA-1值,为此需要指定一个树对象的SHA-1值 , 以及该提交的父提交对象(如果有的话,第一次将暂存区做快照就没有父对象)</li><li>真正的一个版本其实就是提交对象</li></ol></blockquote><h5 id="①-创建提交对象"><a href="#①-创建提交对象" class="headerlink" title="① 创建提交对象"></a>① 创建提交对象</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;first commit&quot; |git commit-tree 树对象的哈希值</span><br></pre></td></tr></table></figure><p>②指定一个树对象的SHA-1值 , 以及该提交的父提交对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;second commit&quot; | git commit-tree 提交的树对象哈希值 -p 父亲树对象哈希值</span><br></pre></td></tr></table></figure><h2 id="四、高层命令"><a href="#四、高层命令" class="headerlink" title="四、高层命令"></a>四、高层命令</h2><h3 id="1、git-add"><a href="#1、git-add" class="headerlink" title="1、git add  ."></a>1、git add  .</h3><blockquote><ol><li><p>会将工作目录的修改,保存成git对象 <code>先到版本库,再到暂存区</code>,而不是直接到暂存区</p></li><li><p>在工作目录修改几个文件,就会生成几个git对象(一个文件对应一个git文件)</p></li><li><p>同一个文件,每次修改再add的时候都会生成一个新的git对象,是<code>增量</code>而不是覆盖</p></li><li><p>所以说git是绝对安全的,就算我只存到暂存区没有提交 git也会给我保存</p></li><li><p>只有后面提交的时候,才会根据暂存区内容给我生成树对象并存入版本区,然后加上我们的提交信息,才生成提交对象存入版本库</p></li></ol></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">相当于以下两个命令集合</span></span><br><span class="line">git hash-object -w 文件名(修改了多少个工作目录中的文件,就要被执行几次)</span><br><span class="line">git update-index ...</span><br></pre></td></tr></table></figure><h3 id="2、git-commit-m-“注释内容”"><a href="#2、git-commit-m-“注释内容”" class="headerlink" title="2、git  commit -m “注释内容”"></a>2、git  commit -m “注释内容”</h3><blockquote><p>将暂存区提交到版本库</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git write-tree</span><br><span class="line">git commit-tree</span><br></pre></td></tr></table></figure><blockquote><p>跳过暂存区存入(之前add过的,直接提交)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="3、git-init"><a href="#3、git-init" class="headerlink" title="3、git init"></a>3、git init</h3><blockquote><p>初始化仓库 初始化后,在当前目录下出现一个名为.git的文件夹</p></blockquote><h3 id="4、git-status"><a href="#4、git-status" class="headerlink" title="4、git status"></a>4、git status</h3><blockquote><p>查看文件的状态</p></blockquote><h3 id="5、git-diff"><a href="#5、git-diff" class="headerlink" title="5、git diff"></a>5、git diff</h3><ol><li><p>当前做的那些更新没有暂存?</p><p>命令:<code>git diff</code>(不加参数直接输入git diff)</p></li><li><p>有哪些更新已经暂存起来准备好了下次提交</p><p>命令:<code>git diff --cached</code>或者<code>git diff --staged(1.6.1以上版本)</code></p></li></ol><h3 id="6、git-log"><a href="#6、git-log" class="headerlink" title="6、git log"></a>6、git log</h3><blockquote><ol><li><p><code>git log</code>(不带参数)</p><p><code>空格键</code>往下翻页 <code>b</code>向上翻页 <code>q</code>退出日志查阅</p></li><li><p>git log –oneline </p><p>将日志信息拍成一行显示</p></li><li><p>git reflog</p><p>所有的日志信息</p></li><li><p>git log –oneline –decorate –graph –all</p><p>查看所有的分支信息命令</p></li></ol></blockquote><h3 id="7、git-rm"><a href="#7、git-rm" class="headerlink" title="7、git rm"></a>7、git rm</h3><blockquote><p>删除工作目录对应的文件,再将修改添加到暂存区(如同删除后给你用了 <code>git add 文件名</code>)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除命令</span></span><br><span class="line">git rm 文件名 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接提交修改,因为<span class="built_in">rm</span>命令帮你提交到暂存区了</span></span><br><span class="line">git commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure><h3 id="8、git-mv"><a href="#8、git-mv" class="headerlink" title="8、git mv"></a>8、git mv</h3><blockquote><p>将工作目录中的文件进行重命名,再将修改添加到暂存区</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv 原文件名  新文件名</span><br></pre></td></tr></table></figure><h2 id="五、配别名"><a href="#五、配别名" class="headerlink" title="五、配别名"></a>五、配别名</h2><blockquote><p>Git并不会在你输入部分命令时自动推断出你想要的命令,如果不想每次都输入完整的Git命令,可以通过git config 文件来轻松为每一个命令设置一个别名</p><p>此处运行后将会写入你的配置文件,可以进入配置文件直接删除</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.自定义命令 &quot; `git` 命令后面的指令 &quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如配置查看分支信息 <span class="string">&quot;git log --oneline --decorate --graph --all&quot;</span></span></span><br><span class="line">git config --global alias.logbranch &quot;log --oneline --decorate --graph --all&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置切换分支</span></span><br><span class="line">git config --global alias.co checkout</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用方式</span></span><br><span class="line">git logbranch</span><br></pre></td></tr></table></figure><h2 id="六、分支"><a href="#六、分支" class="headerlink" title="六、分支"></a>六、分支</h2><blockquote><ol><li><p>前言:</p><p>几乎所有的版本控制系统都以某种形式支持分支.使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线.在很多版本控制系统中,这是略微低效的过程–常常需要完全创建一个源代码目录的副本,对于大项目来说,这会耗费很多时间,而Git的分支模型极其的高校轻量,是Git的必杀特性,也正因为这一特性,是的Git从众多版本控制系统中脱颖而出</p></li><li><p>分支的本质:</p><p><code>Git的分支,其实本质上是提交对象</code>,,所有的分支都有机会被HEAD引用(<code>HEAD一个时刻只会指向一个分支</code>),当我们有新的提交的时候 HEAD会携带当前持有的分支向前移动</p><p>Git的默认分支名字是master,在多次提交后,你其实已经有一个指向最后那个提交对象的master分支.他会在每次的提交操作中自动向前</p><p>注意:Git的”master”分支并不是一个特殊分支.她就跟其他分支完全没有区别.之所以几乎每个仓库都有master分支,是因为<code>git init</code>命令默认创建它,并且大多数人懒得区改动它</p></li><li><p>分支的原理:</p><ol><li><p><code>.git/refs</code>目录中保存了分支及其对应的提交对象</p></li><li><p>当运行类似于<code>git branch (branchname)</code>这样的命令时,Git会取得当前所在分支最新提交对应的SHA-1值,并将其加入你想要创建的任何新分支中</p></li><li><p>当你执行<code>git branch (branchname)</code>时,Git如何知道最新提交的SHA-1值呢?答案是HEAD文件</p><p><code>HEAD文件</code>是一个符号引用(stmbolic reference),指向目前所在的分支.所谓符号医用,意味着它并不像普通引用那样包含一个SHA-1值.它时一个指向其他引用的指针</p></li></ol></li></ol></blockquote><h3 id="1、git-branch"><a href="#1、git-branch" class="headerlink" title="1、git branch"></a>1、git branch</h3><blockquote><ol><li><p>git branch(不加参数)</p><p>作用:<code>显示所有分支</code>信息</p></li><li><p>git branch 分支名</p><p>作用:<code>创建分支</code></p></li><li><p>git branch -v</p><p>作用:查看每一个分支最后一次提交</p></li><li><p>git branch -d(-D强制删除) 分支名</p><p>作用:<code>删除分支</code>,小d需要你这个分支是干净的才能删除(如已合并)</p></li><li><p>git branch –merged </p><p>作用:查看那些分支已经合并到当前分支</p><p>在这个列表中的分支名字前没有*号的分支通常可以使用<code>git branch -d</code> 删除掉</p></li><li><p>git branch –no-merged</p><p>作用:查看所有包含未合并工作的分支</p><p>尝试使用<code>git branch -d</code>命令删除在这个列表中的分支时会失败,如果真的想要删除分支并丢掉哪些工作,可以使用<code>-D</code> 选项爱强制删除它</p></li><li><p>git log –oneline –decorate –graph –all</p><p>作用:查看所有的分支信息命令</p></li><li><p>git branch 分支名 commitHash</p><p>作用:新建一个分支,并且使分支指向对应的提交对象(版本穿梭<code>可以替代撤销与重置</code>)</p></li></ol></blockquote><h3 id="2、git-checkout-分支名"><a href="#2、git-checkout-分支名" class="headerlink" title="2、git checkout 分支名"></a>2、git checkout 分支名</h3><blockquote><p>作用:<code>切换分支</code>  checkout还有其他作用,后面会提到</p><p>它会动三个地方:HEAD(指针) 暂存区 工作目录</p></blockquote><blockquote><ol><li><p><code>注意</code>:分支切换会改变你工作目录中的文件,所以在切换分支时,一定要注意你的工作目录里的文件会被改变,如果时切换到一个比较旧的分支,你的工作目录会回复到该分支最后一次提交的样子,如果Git不能干净利落的完成这个任务,它将禁止切换分支</p></li><li><p><code>坑</code>:在切换分支时, 如果当前分支上由未暂存的修改(<code>第一次</code>) 或者 有未提交的暂存<code>(第一次</code>) 分支可以切换成功,但是这种操作可能会污染其他分支</p><p>ps:<code>第一次</code>–当前分支如果已经提交过一次,将不让你切换,但是第一次没有提交过,git会帮你保存文件 但是它并不知道新增修改是属于哪个分支,所以会带回当前分支</p></li><li><p>最佳操作方式:<code>每次在切换分支前,需要提交一下当前分支(先使用status查看状态)</code></p></li></ol></blockquote><h3 id="3、git-checkout-b-“新的分支名”"><a href="#3、git-checkout-b-“新的分支名”" class="headerlink" title="3、git checkout -b “新的分支名”"></a>3、git checkout -b “新的分支名”</h3><blockquote><p>创建并进入该分支,类似于上面两个命令集合</p></blockquote><h3 id="4、模拟实战流程"><a href="#4、模拟实战流程" class="headerlink" title="4、模拟实战流程"></a>4、模拟实战流程</h3><blockquote><ol><li><p>需要解决主程序的的一个小BUG,所以使用<code>git  checkout -b &quot;iss_bug&quot;</code>新建分支并在这个分支进行bug调修</p></li><li><p>当你再<code>iss_bug</code>分支上开发到一半,这时,在主程序发现了一个紧急BUG需要你放下这个重要性为次要的bug进行修改.你老板都给你打了紧急电话,所以你需要先将写到一半的bug进行保存提交(<code>commit</code>提交或者储存  到暂存区,并不是提交合并到主分支,也不是push提交),确定status是干净的时候,切换回主分支,再用第一步的方法创建<code>hot_bug</code>分支(这时候<code>hit_bug</code>的版本是master没有进行<code>iss_bug</code>调修的版本),进行修复</p></li><li><p>当你将紧急bug修复后,进行提交,确定status干净后切换回master分支,进行合并:代码如下</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge hit_bug</span><br></pre></td></tr></table></figure><ol start="4"><li>修改完后再查看status(这是个好习惯,防止偶尔记忆混淆造成不必要的麻烦),再切换至普通bug分支<code>iss_bug</code>进行修改,成功后切换回去合并</li><li>如果出现冲突,去出现冲突的文件手动修改(决定保留那部分代码),再进行<code>git add</code>表示冲突解决,在进行提交 </li></ol></blockquote><h3 id="5、合并分支"><a href="#5、合并分支" class="headerlink" title="5、合并分支"></a>5、合并分支</h3><blockquote><p>命令: <code>git merge branchname</code>(分支名)</p><p>注意:合并分支时要先切换到<code>主要分支</code>(即下面的被合并分支),在这个分支上进行合并新分支,使得这个分支进行版本更新</p><ol><li><p>快进合并–&gt;不会产生冲突</p><p>​        指被合并分支并没有进行修改,停留在原地,只有新分支进行修改更新,更        新完成后进行合并,原版本相当于直接前进版本,称为快进合并</p></li><li><p>典型合并–&gt;有可能产生冲突</p><p>​        指被合并分支在新分支进行开发时,本身也进行修改开发,可能会改动到同        一代码或者文件而产生重复修改</p></li><li><p>解决冲突:<code>打开冲突的文件</code>  进行修改 ,修改完成后进行:<code>add标记修改完成</code>,然后commit进行提交</p></li></ol></blockquote><blockquote><p><code>git 在pull或者合并分支</code>的时候有时会遇到一个第一段是黄色,下面文字是青色(偏蓝色)。可以不管(直接下面3,4步)，如果要输入解释的话就需要:</p><p>1.按键盘字母 i 进入insert模式</p><p>2.修改最上面那行黄色合并信息,可以不修改</p><p>3.按键盘左上角”Esc”</p><p>4.输入”:wq”,注意是冒号+wq,按回车键即可</p></blockquote><h2 id="七、存储"><a href="#七、存储" class="headerlink" title="七、存储"></a>七、存储</h2><blockquote><ol><li><p>需求背景:</p><p>有时,当你在项目的一部分上已经工作了一段时间后,所有东西都进入了混乱的状态,而这时你想要切换到另一个分支做一点别的事情.问题是,你不想仅仅因为过会儿回到这一点而做了一半的工作创建一次提交</p></li><li><p>解决:</p><p>针对这个问题的答案是 <code>git stash</code> 命令(当然,直接提交<code>commit</code>也可以,这个是用来不想生成提交对象而用)</p></li><li><p>原理:</p><p>git切换分支之所以保留你的未提交的修改文件,是因为它不想你因为误操作使得之前代码报废所以会当你status不干净时组织你切换分支(<code>ps</code>:如果是第一次创建的文件没有追踪过,它不认识是属于那份分支将会带到你切换后的分支造成污染),</p><p>而你将其保存到栈上(<code>ps</code>:换句话说将这部分内容抽取到一个类似共有的栈上,你在哪个分支都能够通过命令取到),git就知道你这个内容已经储存并不会造成切换分支使得你写的代码丢失,便不会阻止你切换分支或者切换带文件污染分支</p></li></ol></blockquote><h3 id="1、git-stash"><a href="#1、git-stash" class="headerlink" title="1、git stash"></a>1、git stash</h3><blockquote><p><code>git stash</code>命令会将未完成的修改保存到一个栈上,而你可以在任何时候重新应用这些改动(<code>git stash apply</code>),</p><p><code>注意!!!!!</code>:使用前你要先<code>git add .</code>,否则你会发现,你执行此命令后,没有追踪的部分全部消失了</p></blockquote><h3 id="2、git-stash-list"><a href="#2、git-stash-list" class="headerlink" title="2、git stash list"></a>2、git stash list</h3><blockquote><p>查看存储</p></blockquote><h3 id="3、git-stash-pop"><a href="#3、git-stash-pop" class="headerlink" title="3、git stash pop"></a>3、git stash pop</h3><blockquote><p>来应用储藏然后立即从栈上扔掉它 <code>这是最推荐的使用</code></p></blockquote><h3 id="4、git-stash-apply-stash-2"><a href="#4、git-stash-apply-stash-2" class="headerlink" title="4、git stash apply stash@{2}"></a>4、git stash apply stash@{2}</h3><blockquote><p>如果不指定一个储藏,git认为指定栈顶<code>不常用</code></p></blockquote><h3 id="5、git-stash-drop-“储藏的名字”"><a href="#5、git-stash-drop-“储藏的名字”" class="headerlink" title="5、git stash drop “储藏的名字”"></a>5、git stash drop “储藏的名字”</h3><blockquote><p>加上要储藏的名字移除他 <code>不常用</code></p></blockquote><h3 id="6、git-stash-clear"><a href="#6、git-stash-clear" class="headerlink" title="6、git stash clear"></a>6、git stash clear</h3><blockquote><p>在查看存储后,运行此命令  清空stash栈</p></blockquote><h2 id="八、撤销与重置"><a href="#八、撤销与重置" class="headerlink" title="八、撤销与重置"></a>八、撤销与重置</h2><blockquote><p>特别是重置部分理解即可(用到了再去查),撤销尽量可以掌握</p></blockquote><h3 id="Ⅰ-撤销"><a href="#Ⅰ-撤销" class="headerlink" title="Ⅰ- 撤销"></a>Ⅰ- 撤销</h3><h4 id="1、git-commit-–amend"><a href="#1、git-commit-–amend" class="headerlink" title="1、git commit –amend"></a>1、git commit –amend</h4><blockquote><ol><li><p>这个命令会将暂存区中的文件提交,修订提交(<code>不是撤销而是重新提交</code>)</p></li><li><p>如果自上次提交以来你还未做任何修改(如:在上次提交后马上执行此命令),那么快照会保持不变,而你修改的只是提交信息</p></li><li><p>如果你提交后发现忘记了暂存某些需要的修改,可以像下面这样操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;错误的注释&quot; #或者commit了错误的修改</span><br><span class="line">git add &quot;文件名或者.&quot;  #重新add正确的文件</span><br><span class="line">git commit --amend#进行重新提交</span><br></pre></td></tr></table></figure><p>最终你只会有一个提交 (第二次提交将会替代第一次提交)</p></li><li><p>可以修改上次提交的文件与注释</p></li></ol></blockquote><h4 id="2、git-reset"><a href="#2、git-reset" class="headerlink" title="2、git reset"></a>2、git reset</h4><blockquote><ol><li>一般我们写完代码后,是这样提交的:</li></ol><ul><li>git add . //添加追踪所有文件</li><li>git commit -m “feat(前端-Git学习详细笔记):更新撤销commit操作” //添加commit提交信息</li></ul><ol start="2"><li>但是commit写完提交信息后,突然想到还有一个地方代码没改到/保存,如果放到下一个commit却不合适(同一个功能修改,分成两个commit),原因详见下方的 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E2%85%A3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">版本控制工具的使用基本原则</a> </li><li>执行此命令命令:<code>git reset --soft HEAD^</code></li></ol><ul><li>HEAD^的意思是上一个版本，也可以写成HEAD~1</li><li>如果你进行了2次commit，想都撤回，可以使用HEAD~2</li><li>详见下方 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#reset%E4%B8%89%E9%83%A8%E6%9B%B2">reset三部曲</a></li></ul><p>作用:将文件从<code>暂存区中撤回</code>到工作目录中(仅仅是撤回commit操作，你写的代码仍然保留)</p></blockquote><h4 id="3、git-checkout"><a href="#3、git-checkout" class="headerlink" title="3、git checkout"></a>3、git checkout</h4><blockquote><p>是的,你没看错,这个是切换分支的命令,但是他也能用来<code>撤销文件修改</code></p><p>命令:<code>git checkout --文件名</code></p><p>将在工作目录中对文件的修改撤销</p><p><code>注意</code>:这是一个危险的命令,这很重要.你对那个文件做的任何修改都会消失–你只是拷贝了另一个文件(原来版本的文件)来覆盖它.除非你确实秦楚不想要那个文件了,否则不要使用这个命令</p></blockquote><h3 id="Ⅱ-重置reset"><a href="#Ⅱ-重置reset" class="headerlink" title="Ⅱ - 重置reset"></a>Ⅱ - 重置reset</h3><blockquote><p>注意:<code>--hard</code>标记是<code>reset</code>命令唯一的<code>危险用法</code>,也是Git真正的销毁数据的几个仅有操作之一.其他任何形式的<code>reset</code>调用都可以轻松撤销,但是<code>--hard</code>选项不能,因为它强制覆盖了工作目录中的文件.</p><p>如在这种特殊情况:我们的Git数据库中的一个提交内还留有该文件的几个版本,我们可以通过<code>reflog</code>来找回它,但若是该文件还未提交,Git仍会覆盖他导致它无法恢复</p></blockquote><h4 id="reset三部曲"><a href="#reset三部曲" class="headerlink" title="reset三部曲"></a>reset三部曲</h4><blockquote><p>第一部:git reset –soft HEAD~(等于之前的–amend,后面如果跟随数字,就是回退几个版本,默认1个)</p><p>​    移动HEAD (但带着分支一起移动,与checkout不同(它只动HEAD))  –&gt;相当于回到你没有 [ commit ]的时候,代码仍在</p><p>第二部:git reset –mixed HEAD~</p><p>​    移动HEAD 并且动了了暂存区</p><p>第三部:git reset –hard HEAD~</p><p>​    移动HEAD 并且动了了暂存区 动了工作目录 ( 你的提交的代码也会没掉 )</p></blockquote><h3 id="Ⅲ-错误的git-push提交成功后如何撤销回退"><a href="#Ⅲ-错误的git-push提交成功后如何撤销回退" class="headerlink" title="Ⅲ -  错误的git push提交成功后如何撤销回退"></a>Ⅲ -  错误的git push提交成功后如何撤销回退</h3><blockquote><p>我们在使用Git进行版本控制时，有可能会出现这种情况。git push后发现提交的内容不是想要的，这时候我们怎么做呢，提交上去的内容是没有删除按钮的（比如github，或码云）。所以我们需要一些手段将提交上去内容撤销下来。</p><p>而要撤销,就要用到上面所学的 <code>git reset</code></p></blockquote><h4 id="1、错误场景示范"><a href="#1、错误场景示范" class="headerlink" title="1、错误场景示范"></a>1、错误场景示范</h4><blockquote><p>Ⅰ- 当我撰写 [ commit ] 信息没注意到,以为是对的时候直接提交 –&gt; 因为本人提交笔记时喜欢按 [ ↑ ] 找到之前的提交信息进行修改</p><img src="A_Git详细学习笔记中的图片/image-20210813153403664.png" alt="image-20210813153403664" style="zoom:67%;" /> <p>Ⅱ- 此时可以看到,错误的 [ commit ] 已经提交了 (当然,适用场景不只是commit ,也可错误代码之类的)</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155746112.png" alt="image-20210813155746112"> </p></blockquote><h4 id="2、回退操作"><a href="#2、回退操作" class="headerlink" title="2、回退操作"></a>2、回退操作</h4><blockquote><p>咱们操作稳重一点,使用git reset –soft HEAD~就好了(如果回退后代码也不想要,可以用<code>git stash</code>,暂存,达到代码也回退的效果)</p></blockquote><h5 id="①-git-reflog"><a href="#①-git-reflog" class="headerlink" title="① git reflog"></a>① git reflog</h5><blockquote><p>commits，它在git中扮演了一个重要角色，我们平常用的一些操作git clone ,git commit 都会产生commits，通俗的讲这个就是版本号，但是git reset并不会产生commits（不是不会产生，而是会产生 但是都是一样的），我们可以先看看自己项目中的commits，使用如下命令:<code>git reflog</code></p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154309057.png" alt="image-20210813154309057"> </p></blockquote><h5 id="②-git-reset-–soft-HEAD"><a href="#②-git-reset-–soft-HEAD" class="headerlink" title="②  git  reset –soft HEAD~"></a>②  git  reset –soft HEAD~</h5><blockquote><p>运行此代码后,我们的 [ HEAD ] 指向了上一个 [ commits ]</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154448889.png" alt="image-20210813154448889"> </p></blockquote><h5 id="③-查看缓存"><a href="#③-查看缓存" class="headerlink" title="③  查看缓存"></a>③  查看缓存</h5><blockquote><ul><li><p>此时你可以用<code>stash staus</code>查看,会发现,之前提交的代码已经放回缓存区了</p></li><li><p>如果你不想要此次提交所有代码,可以使用<code>git stash</code> ,然后再去清空即可(当然,本人此处还是需要的,所以要留下)</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154839981.png" alt="image-20210813154839981"> </p></li></ul></blockquote><h5 id="④-重新撰写-commit-信息"><a href="#④-重新撰写-commit-信息" class="headerlink" title="④ 重新撰写 [ commit ]信息"></a>④ 重新撰写 [ commit ]信息</h5><blockquote><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154928064.png" alt="image-20210813154928064"> </p></blockquote><h5 id="⑤-强制提交"><a href="#⑤-强制提交" class="headerlink" title="⑤ 强制提交"></a>⑤ 强制提交</h5><blockquote><p>如果你重新撰写 [ commit ] 后马上重新push,你会发现无法提交: 因为我们当前落后远程一个版本!</p><p>所以此时直接强制提交即可,就能覆盖远程提交记录</p><blockquote><p><code>git push -f</code></p></blockquote><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155049169.png" alt="image-20210813155049169"> </p></blockquote><h4 id="3、成功展示"><a href="#3、成功展示" class="headerlink" title="3、成功展示"></a>3、成功展示</h4><blockquote><ul><li>在网站工作台首页能看到已经将更改后的 [ coommit ] 强制推送上来了</li></ul><p> 也许你会奇怪:为啥工作台上还能看到? 其实已经删了!!!你看下方</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155614570.png" alt="image-20210813155614570"> </p><ul><li>但是你查看提交记录,会发现之前错误的commit已经被覆盖</li></ul><img src="A_Git详细学习笔记中的图片/image-20210813155339300.png" alt="image-20210813155339300" style="zoom:80%;" /></blockquote><h2 id="九、数据恢复"><a href="#九、数据恢复" class="headerlink" title="九、数据恢复"></a>九、数据恢复</h2><blockquote><p>在你使用Git的时候,你可能会意外丢失一次提交:</p><p>①通常这是因为你强制删除了正在工作的分支,但是最后你却需要这个分支;②抑或是你硬重置了一个分支,放弃了你想要的提交.</p><p>如果这些事情已经发生,该如何找回你的提交呢?</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><blockquote><p>推荐方法最好是<code>直接看恢复</code>,上面实例时当你使用硬重置回当初未删除版本进行恢复,出现的一系列问题解决</p></blockquote><blockquote><ol><li>假设你已经提交了五次,而现在,我们将master分支硬重置到了第三次提交来找回当时删除的分支.但是这时候你会发现一个事情:</li></ol><p>现在顶部的两个提交已经丢失了-没有分支指向这些提交(因为你将指针移到了第三个,那么前面两个就找不到了)</p><ol start="2"><li>你现在已经得到并且恢复当时第三次还存在的的提交了(<code>恢复方法在下面,恢复文件到这步,下面3、4是回到最新版本</code>)</li></ol><p>现在准备回到当初最新的版本时,你发现你进行打印竟然没有前面两次提交信息(你需要他的哈希值进行版本穿梭或者重置),你需要最新一次提交的哈希值,但是你估计想不起来了,对吗?</p><ol start="3"><li><p>最方便,也是最常用的方法,是使用一个名叫<code>log reflog</code>的工具(前面高层命令提过),当你在工作时,Git会默默记录每一次你改变的HEAD时它的值,每一次你提交或者改变分支,引用日志都会被刷新</p></li><li><p>如果<code>git reflog</code>显示的内容你觉得不足够多,可以执行<code>git log -g</code>,这个命令会以标准日志的格式输出引用日志</p></li></ol></blockquote><h3 id="恢复-推荐的"><a href="#恢复-推荐的" class="headerlink" title="恢复 推荐的"></a>恢复 <code>推荐的</code></h3><blockquote><ol><li><p>通过<code>git reflog</code>找到你需要的文件还未删除的版本哈希值,那个就是你丢失的提交,你可以通过创建一个新的分支指向这个提交来恢复它.</p><p>例如:你可以创建一个名为<code>recover-branch</code>的分支执行这个提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch recover-branch 当前需要恢复(之前丢失的)的提交哈希值</span><br></pre></td></tr></table></figure></li><li><p>现在有一个名为<code>recover-branch</code>的分支是你的<code>master</code>分支曾经指向的地方(即当时你删除该需要的文件的前的那个版本),这样你在这次提交的版本后,也能通过切换这个分支得到曾丢失的文件</p></li><li><p>这个分支功能能帮你做很多东西,善用分支,Git最强功能</p></li></ol></blockquote><h2 id="十、打tag"><a href="#十、打tag" class="headerlink" title="十、打tag"></a>十、打tag</h2><blockquote><p>Git可以给历史中的某一次提交打上标签,表示重要.比较有代表性的是人们会用这个功能来<code>标记发布节点</code>(v1.0等等)</p></blockquote><h3 id="1、列出标签"><a href="#1、列出标签" class="headerlink" title="1、列出标签"></a>1、列出标签</h3><blockquote><p>命令:<code>git tag</code> 或者 <code>git tag -l &#39;v1.*&#39;</code></p><p>​    前者列出所有,后者列出以<code>v1.</code>开头的所有</p></blockquote><h3 id="2、创建标签"><a href="#2、创建标签" class="headerlink" title="2、创建标签"></a>2、创建标签</h3><blockquote><p>git使用两种主要类型的标签:轻量标签 与 附注标签</p></blockquote><h5 id="①轻量标签"><a href="#①轻量标签" class="headerlink" title="①轻量标签"></a>①轻量标签</h5><blockquote><p>轻量标签很像一个不会改变的的分支(他只是一个特定提交的引用),直接在提交前使用命令即可给当前分支打上标签</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者下面的</span></span><br><span class="line">git tag v1.0 提交对象哈希</span><br></pre></td></tr></table></figure><h5 id="②附注标签"><a href="#②附注标签" class="headerlink" title="②附注标签"></a>②附注标签</h5><blockquote><p>附注标签是存储在Git数据库中的一个完整对象.他们是可以被校验的,其中包含打标签者的名字、电子邮件地址、日期时间;通常<code>建议创建复制标签</code>,这样你可以拥有以上所有信息,但如果只是想用一个临时标签,或者由于某些原因不想表村那些信息,轻量标签也是可用的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0</span><br><span class="line">git tag -a v1.0 提交对象哈希</span><br><span class="line">git tag -a v1.0 提交对象哈希 -m &quot;我的注释信息&quot;</span><br></pre></td></tr></table></figure><h3 id="3、查看特定标签"><a href="#3、查看特定标签" class="headerlink" title="3、查看特定标签"></a>3、查看特定标签</h3><blockquote><p><code>git show</code> 可以显示任意类型的对象(git对象 树对象 提交对象 tag对象)</p><p>命令: <code>git show tagname</code></p></blockquote><h3 id="4、删除标签"><a href="#4、删除标签" class="headerlink" title="4、删除标签"></a>4、删除标签</h3><blockquote><ol><li><p>删除标签 要删除你在本地仓库上的标签,可以使用命令 <code>git tag -d &lt;tagname&gt;</code>如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1.0</span><br></pre></td></tr></table></figure></li><li><p>应该注意上述命令并不会从任何远程仓库中移出这个标签,你必须使用<code>git push &lt;tamote&gt;:refs/tags/&lt;tagname&gt;</code>来更新你的远程仓库,如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v1.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">origin是你配置的远程仓库地址别名,你可以直接用远程仓库地址</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="5、捡出标签"><a href="#5、捡出标签" class="headerlink" title="5、捡出标签"></a>5、捡出标签</h3><blockquote><ol><li><p>如果说你想查看某个标签所指向的文件版本,可以使用<code>git checkout</code>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout tagname</span><br></pre></td></tr></table></figure></li><li><p>虽然说这会使得你的仓库处于”分离 头指针(deacthed HEAD)”状态.在”分离头指针”状态下,如果你做了某些更改然后提交它们,标签不会发生变化,但你的新提交将不属于任何分支,并且将无法访问,除非访问确切的提交哈希,因此你如果需要进行更改–比如说你需要<code>修复旧版本</code>的错误–这通常需要创建一个新的分支(捡出后创建,就会默认将当前捡出的版本作为新分支的第一版本-前面分支提到过)</p><p>这样就可以修改到旧版本的代码(如同vue的尤雨溪在vue3.x会更新vue1.0版本生态)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b version(新的分支)</span><br></pre></td></tr></table></figure></li></ol></blockquote><h1 id="Ⅱ-代码风格"><a href="#Ⅱ-代码风格" class="headerlink" title="Ⅱ-代码风格"></a>Ⅱ-代码风格</h1><h2 id="1、Eslint"><a href="#1、Eslint" class="headerlink" title="1、Eslint"></a>1、Eslint</h2><blockquote><p>ESlint是一个开源的JavaScript代码检查工具,由红宝书作者创建</p><p>初衷是为了让程序员可以创建自己的检测规则.ESLint的所有规则都被设计成可插入的</p><p>ESLint使用Node.js编写,这样既可以有一个快速的运行环境同时也便于安装</p><p>此处引入概念,具体学习之后将开新的笔记</p></blockquote><h2 id="2、commit提交规范"><a href="#2、commit提交规范" class="headerlink" title="2、commit提交规范"></a>2、commit提交规范</h2><blockquote><ol><li><p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">参考自阮一峰老师的文章</a></p></li><li><p>Header</p></li></ol><p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p><p><strong>（1）type</strong></p><p><code>type</code>用于说明 commit 的类别，只允许使用下面几个标识。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">feat：新功能（feature）。</span><br><span class="line">fix/to：修复bug，可以是<span class="variable constant_">QA</span>发现的<span class="variable constant_">BUG</span>，也可以是研发自己发现的<span class="variable constant_">BUG</span>。</span><br><span class="line">fix：产生diff并自动修复此问题。适合于一次提交直接修复问题</span><br><span class="line">to：只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix</span><br><span class="line">docs：文档（documentation）。</span><br><span class="line">style：格式（不影响代码运行的变动）。</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）。</span><br><span class="line">perf：优化相关，比如提升性能、体验。</span><br><span class="line">test：增加测试。</span><br><span class="line">chore：构建过程或辅助工具的变动。</span><br><span class="line">revert：回滚到上一个版本。</span><br><span class="line">merge：代码合并。</span><br><span class="line">sync：同步主线或分支的<span class="title class_">Bug</span>。</span><br></pre></td></tr></table></figure></blockquote><p>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p><p><strong>（2）scope</strong></p><p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>（3）subject</strong></p><p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p><blockquote><ul><li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li><li>第一个字母小写</li><li>结尾不加句号（<code>.</code>）</li></ul></blockquote></blockquote><h1 id="Ⅲ-远程操作"><a href="#Ⅲ-远程操作" class="headerlink" title="Ⅲ-远程操作"></a>Ⅲ-远程操作</h1><blockquote><p>三个必须懂的概念</p><ol><li>本地分支</li></ol><p>  工作目录中的分支</p><ol start="2"><li>远程跟踪分支</li></ol><p>  当你往远程分支<code>push</code>(还有克隆)的时候会创建远程跟踪分支</p><ol start="3"><li>远程分支</li></ol><p>  指保存在git网站上的那个远程仓库中的分支</p></blockquote><h3 id="1、团队协作流程"><a href="#1、团队协作流程" class="headerlink" title="1、团队协作流程"></a>1、团队协作流程</h3><blockquote><ol><li><p>项目经理初始化远程仓库</p><p> 一定要初始化一个空的仓库:再github上操作</p></li><li><p>项目经理创建本地仓库</p><ol><li><code>git remote 别名 仓库地址</code></li><li><code>git --init</code>,然后将源码复制进来</li><li>修改用户名 修改邮箱(双账号的才需要这步)</li><li><code>git  add</code> 和 <code>git commit</code></li></ol></li><li><p>项目经理推送到本地仓库到远程仓库</p><ol><li>清理window凭据</li><li><code>git push 别名 分支</code>(输入账号密码;推完之后会附带生成远程跟踪分支) </li></ol></li><li><p>项目邀请成员&amp;&amp;成员接受邀请</p><p> 在git网站上操作</p></li><li><p>成员克隆远程仓库</p><p> <code>git clone 仓库地址</code></p><p> 只有在克隆的时候 本地分支master 和 远程跟踪分支别名/master 是有同步关系的(可以直接pull或者push后面不用加origin)</p><p> 原因是,每次你push的时候是你远程跟踪分支替换掉(同步)你的远程分支，如果你想要新分支能直接push，需要本地分支去追踪远程追踪分支</p></li><li><p>成员做出贡献</p><ol><li>修改源代码文件</li><li><code>git add -&gt; commit -&gt; push</code></li></ol></li><li><p>项目经理更新修改</p><ol><li><code>git fetch 别名</code>(将修改同步到远程跟踪分支上)</li><li>git merge 远程跟踪分支</li></ol></li></ol></blockquote><h3 id="2、远程库"><a href="#2、远程库" class="headerlink" title="2、远程库"></a>2、远程库</h3><blockquote><p>正常的数据推送 和 拉取步骤</p><ol><li>确保本地分支已经跟踪了远程跟踪分支</li><li>拉取上传数据： git <code>pull</code> or <code>push</code></li></ol></blockquote><h4 id="Ⅰ-远程跟踪分支"><a href="#Ⅰ-远程跟踪分支" class="headerlink" title="Ⅰ-远程跟踪分支"></a>Ⅰ-远程跟踪分支</h4><blockquote><p>流程与释义:</p><ol><li><p><code>远程跟踪分支</code>是远程分支状态的引用。它们是你不能移动的本地分支。当你做任何网络通信操作时，它们会自动移动</p></li><li><p>它们以（remote）/(branch)形式命名，如果你想要看你最后一次与远程仓库origin时master分支的状态，可以查看origin/master分支</p></li><li><p>当<code>克隆</code>一个仓库时,它通常会自动的创建一个跟踪<code>origin/master</code>的master分支（所以你可以不跟踪直接pull与push后面不跟origin）</p></li><li><p>当我克隆之后，别人新建了一个分支push上去，我这时候想要或者并且跟踪这个新分支，我需要先<code>git fetch origin</code>获取下来，获取下来后想要切换并且跟踪这个分支时使用命令<code>git checkout --track 远程跟踪分支名(origin/分支名)</code></p></li></ol></blockquote><h5 id="做跟踪"><a href="#做跟踪" class="headerlink" title="做跟踪:"></a>做跟踪:</h5><blockquote><ol><li><p>克隆仓库时,会自动为master做跟踪</p></li><li><p>本地没有分支,要新建分支且追踪</p></li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track 远程跟踪分支(remote/分支名)</span><br></pre></td></tr></table></figure><ol start="3"><li>本地已经创建了分支,</li></ol>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u 远程跟踪分支(remote/分支名)</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅱ-本地分支怎么跟踪远程跟踪分支"><a href="#Ⅱ-本地分支怎么跟踪远程跟踪分支" class="headerlink" title="Ⅱ-本地分支怎么跟踪远程跟踪分支"></a>Ⅱ-本地分支怎么跟踪远程跟踪分支</h4><blockquote><ol><li><p>当克隆的时候 会自动生成一个master本地分支（已经跟踪了对应的远程跟踪分支）</p></li><li><p>在新建其他分支时，可以指定想要跟踪的远程跟踪分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 本地分支名 远程跟踪分支名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">简写形式</span></span><br><span class="line">git checkout --track 远程跟踪分支名(origin/分支名)</span><br></pre></td></tr></table></figure></li><li><p>将一个已经存在的本地分支 改成 一个跟踪分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u 远程跟踪分支名</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="Ⅲ-冲突"><a href="#Ⅲ-冲突" class="headerlink" title="Ⅲ-冲突"></a>Ⅲ-冲突</h4><blockquote><ol><li>git本地操作会不会有冲突？</li></ol><p>  典型合并的时候（如新建分支合并时）</p><ol start="2"><li>git远程协作的时候会不会有冲突</li></ol><p>  <code>push</code>与<code>pull</code></p></blockquote><blockquote><p>解决流程：</p><ol><li><p>假设你修改了a.js的代码，已经<code>add &amp;&amp;commit</code>（必须先这样才能提交，才能触发冲突）</p></li><li><p>但是这时别人也改了a.js同一行代码并且已经push上去了，你这时候进行push将会报错</p></li><li><p>这时候你需要先将其pull下来，这时候你会发现你的git将会给你提示，并且在本地的a.js中文件代码中，保留了你们两个的代码（并且会给你标注出来）</p></li><li><p>这时候一定要去与<code>与你冲突的开发人员交流</code>,讨论保留哪一个人的代码，或者进行修改（直接在你pull后的本地目录中修改），修改完成后使用<code>git add .</code>标记解决冲突然后<code>push</code>提交，这样别人pull的时候git就知道这部分时保留哪部分代码，直接覆盖（即在一个地方更改然后标记提交即可）</p></li><li><p>如果你发生冲突<code>不进行沟通</code>，将别人代码<code>直接注释掉</code>，让自己代码能跑，那么–真的很爽</p></li></ol><p>  但是别人功能可能就炸了，这时候你会被暴打:smirk:</p><p>  因为你解决冲突后（git add .）别人pull的时候并不会提示冲突，因为你用<code>add</code>标记解决了冲突，git认出来后会直接默认<code>覆盖</code>他的代码，不知不觉，你可能就毁了另外一个程序员美好的一天（莫名其妙的BUG导致加班），如果他没反应过来，可能就是两天甚至…，你到时候住院的时间也与这个成正比:smirk:</p></blockquote><h4 id="Ⅳ-pull-request-流程"><a href="#Ⅳ-pull-request-流程" class="headerlink" title="Ⅳ- pull request 流程"></a>Ⅳ- pull request 流程</h4><blockquote><p>​    <code>如果你想要参加某个项目，但是并没有推送权限</code>，这时候可以对这个项目进行”派生“（<code>Fork</code>),派生是指GitHub将在你的空间创建一个完全属于你的项目副本,且你对其有推送权限.通过这种方式,项目的管理者不再需要忙着把用户添加到贡献者列表并给予它们推送权限.人们可以派生这个项目,将修改推送到派生出的项目副本中,并通过创建合并请求(pull request)让它们改动进入原版本库</p><p>基本流程:</p><ol><li>自己在git网站上fork的项目到自己空间中,下面的操作都是基于这个fork的项目</li><li>从master分支中创建一个新的分支</li><li>提交一些修改来改进项目</li><li>将这个分支推送到git上</li><li>创建一个<code>合并</code>请求(在网站上点击发送信息)</li><li>在网站上进行讨论,并且根据实际情况继续修改</li><li>项目的拥有者合并或者关闭你的合并请求</li></ol><p>注意:</p><p> 每次在发起新的<code>Pull Request</code>时 要去拉去最新的原仓库的代码 而不是自己fork的那个仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;源仓库名字（自己定义）&gt; &lt;仓库地址链接&gt;</span><br><span class="line">git fetch 远程仓库名字</span><br><span class="line">git merge 对应的远程跟踪分支</span><br></pre></td></tr></table></figure></blockquote><hr><h1 id="Ⅳ-版本控制工具的使用基本原则"><a href="#Ⅳ-版本控制工具的使用基本原则" class="headerlink" title="Ⅳ-版本控制工具的使用基本原则"></a>Ⅳ-版本控制工具的使用基本原则</h1><h2 id="1、精准的提交"><a href="#1、精准的提交" class="headerlink" title="1、精准的提交"></a>1、精准的提交</h2><p>每次提交都是一个小儿完整的功能或者一个BUG的修复。不应该出现多个功能点一块提交或者多个BUG一起修复的情况。如果一旦发现提交的代码有问题，可以方便的会滚到改动之前的正确状态，不会影响到其他协作者开发进程。</p><h2 id="2、频繁的提交"><a href="#2、频繁的提交" class="headerlink" title="2、频繁的提交"></a>2、频繁的提交</h2><p>尽可能频繁的提交你的改动到远程仓库，这样，可以避免将来合并代码的时候产生大量的冲突以至于难以解决。同时，也可以让其他同事比较快的共享你的改动。</p><h2 id="3、不要提交不完整的功能"><a href="#3、不要提交不完整的功能" class="headerlink" title="3、不要提交不完整的功能"></a>3、不要提交不完整的功能</h2><p>如果你正在开发的新功能比较庞大，那么可以讲这个功能尽可能拆分为几个逻辑模块，并且要保证分次提交的逻辑模块不会影响到整个系统的正确性。如果你只是因为临时的一些事情需要切到别的分支或者是临时需要中断开发（比如说下班）,那么应该使用<code>Stash</code>储藏功能来保存你的更改。   –&gt;<a href="#%E4%B8%83%E3%80%81%E5%AD%98%E5%82%A8">相关知识点部分我跳转</a></p><h2 id="4、提交前进行测试"><a href="#4、提交前进行测试" class="headerlink" title="4、提交前进行测试"></a>4、提交前进行测试</h2><p>不要想当然的认为自己的代码是正确的，提交之前应该经过充分的测试才能提交，即使是提交到本地仓库，也应该进行测试，因为这些代码在未来会被推送到远程共享给你的同事。</p><h2 id="5、高质量的提交注释"><a href="#5、高质量的提交注释" class="headerlink" title="5、高质量的提交注释"></a>5、高质量的提交注释</h2><p>每次提交都应该包含完整的注释。团队成员应当遵循统一的提交规则，一般应当明确的体现出提交的类型以及具体的事情，例如 feat: add message list;</p><h2 id="6、遵循统一的流程规范"><a href="#6、遵循统一的流程规范" class="headerlink" title="6、遵循统一的流程规范"></a>6、遵循统一的流程规范</h2><p>Git 可以支持很多不同的工作流程：长期分支、功能分支、合并以及 rebase、git-flow 等等。选择什么样的开发流程要取决如下一些因素：项目开发的类型，部署模式和（可能是最重要的）开发团队成员的个人习惯。不管怎样，选择什么样的流程都需要得到所有开发成员的一致认可，并且一直遵循它。</p><h1 id="Ⅴ-实际遇到的问题与解决Mark"><a href="#Ⅴ-实际遇到的问题与解决Mark" class="headerlink" title="Ⅴ- 实际遇到的问题与解决Mark"></a>Ⅴ- 实际遇到的问题与解决Mark</h1><h2 id="1、将本地已有的一个项目上传到新建的git仓库的方法"><a href="#1、将本地已有的一个项目上传到新建的git仓库的方法" class="headerlink" title="1、将本地已有的一个项目上传到新建的git仓库的方法"></a>1、将本地已有的一个项目上传到新建的git仓库的方法</h2><p>将本地已有的一个非git项目上传到新建的git仓库的方法一共有两种。</p><h3 id="Ⅰ-克隆-拷贝"><a href="#Ⅰ-克隆-拷贝" class="headerlink" title="Ⅰ-  克隆+拷贝"></a>Ⅰ-  克隆+拷贝</h3><blockquote><p>第一种方法比较简单，直接用把远程仓库拉到本地，然后再把自己本地的项目拷贝到仓库中去。然后push到远程仓库上去即可。<strong>此方法适用于本地项目不是一个git仓库的情况。</strong></p><p>具体步骤如下：</p><h4 id="1、首先克隆"><a href="#1、首先克隆" class="headerlink" title="1、首先克隆"></a>1、首先克隆</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git <span class="built_in">clone</span> git@github.com:yuanmingchen/tensorflow_study.git</span><br></pre></td></tr></table></figure><h4 id="2、然后复制自己项目的所有文件-除了-git文件-到刚刚克隆下来的仓库中"><a href="#2、然后复制自己项目的所有文件-除了-git文件-到刚刚克隆下来的仓库中" class="headerlink" title="2、然后复制自己项目的所有文件(除了.git文件)到刚刚克隆下来的仓库中"></a>2、然后复制自己项目的所有文件(除了<code>.git</code>文件)到刚刚克隆下来的仓库中</h4><h4 id="3、最后push到远程仓库上面去："><a href="#3、最后push到远程仓库上面去：" class="headerlink" title="3、最后push到远程仓库上面去："></a>3、最后push到远程仓库上面去：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git push -u origin master</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-强行合并两个仓库"><a href="#Ⅱ-强行合并两个仓库" class="headerlink" title="Ⅱ-  强行合并两个仓库"></a>Ⅱ-  强行合并两个仓库</h3><blockquote><p>第二种方法就是先将本地的项目初始化为一个git仓库，然后再强行合并本地仓库和远程仓库，由于这两个仓库是完全不同的两个仓库，所以直接pull都会报错，需要在pull的时候假加上–allow-unrelated-histories才可以pull成功。<strong>此方法适用于本地项目已经是一个git仓库的情况。</strong></p><p>具体步骤如下：</p><h4 id="1、新建git仓库，将本地项目设置为一个git仓库。如果本地项目已经是一个git仓库了，请跳过这一步。在项目根目录下："><a href="#1、新建git仓库，将本地项目设置为一个git仓库。如果本地项目已经是一个git仓库了，请跳过这一步。在项目根目录下：" class="headerlink" title="1、新建git仓库，将本地项目设置为一个git仓库。如果本地项目已经是一个git仓库了，请跳过这一步。在项目根目录下："></a>1、新建git仓库，将本地项目设置为一个git仓库。如果本地项目已经是一个git仓库了，请跳过这一步。在项目根目录下：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git init</span><br></pre></td></tr></table></figure><h4 id="2、把当前目录下的已有文件-除了-git文件-全部加到刚刚新建的git仓库中："><a href="#2、把当前目录下的已有文件-除了-git文件-全部加到刚刚新建的git仓库中：" class="headerlink" title="2、把当前目录下的已有文件(除了.git文件)全部加到刚刚新建的git仓库中："></a>2、把当前目录下的已有文件(除了<code>.git</code>文件)全部加到刚刚新建的git仓库中：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git add .</span><br></pre></td></tr></table></figure><h4 id="3、保存刚刚加入的文件，并书写保存信息："><a href="#3、保存刚刚加入的文件，并书写保存信息：" class="headerlink" title="3、保存刚刚加入的文件，并书写保存信息："></a>3、保存刚刚加入的文件，并书写保存信息：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git commit -m <span class="string">&quot;push current files&quot;</span></span><br></pre></td></tr></table></figure><h4 id="4、将本地仓库与远程仓库关联起来："><a href="#4、将本地仓库与远程仓库关联起来：" class="headerlink" title="4、将本地仓库与远程仓库关联起来："></a>4、将本地仓库与远程仓库关联起来：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git remote add origin git@github.com:yuanmingchen/tensorflow_study.git</span><br></pre></td></tr></table></figure><h4 id="5、pull远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories忽略本地仓库和远程仓库的无关性，强行合并（关键）："><a href="#5、pull远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories忽略本地仓库和远程仓库的无关性，强行合并（关键）：" class="headerlink" title="5、pull远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories忽略本地仓库和远程仓库的无关性，强行合并（关键）："></a>5、pull远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories忽略本地仓库和远程仓库的无关性，强行合并（关键）：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h4 id="6、把本地仓库的内容push到远程仓库："><a href="#6、把本地仓库的内容push到远程仓库：" class="headerlink" title="6、把本地仓库的内容push到远程仓库："></a>6、把本地仓库的内容push到远程仓库：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git push -u origin master</span><br></pre></td></tr></table></figure><p>然后就ok了。</p></blockquote><h3 id="Ⅲ-其他git命令"><a href="#Ⅲ-其他git命令" class="headerlink" title="Ⅲ- 其他git命令"></a>Ⅲ- 其他git命令</h3><blockquote><p>最后附上git的一些其他命令：<br>1、删除已将关联的远程主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></table></figure><p>2、查看所有本地分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git branch -a</span><br></pre></td></tr></table></figure><p>3、新建一个分支，名字叫xf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git branch xf</span><br></pre></td></tr></table></figure><p>4、切换分支到xf分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git checkout xf</span><br></pre></td></tr></table></figure><p>5、把远程分支的代码pull到本地分支：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br>如：取回origin主机的master分支，与本地的xf分支合并，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git pull origin master:xf</span><br></pre></td></tr></table></figure><p>6、推送当前的分支，git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br>PS:注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。<br>如：把本地的xf分支推送到origin主机的master分支，输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;git push origin xf:master</span><br></pre></td></tr></table></figure></blockquote><h2 id="2、解决同一台电脑生成两份或多份ssh密钥、公钥映射两个或多个GitHub账号"><a href="#2、解决同一台电脑生成两份或多份ssh密钥、公钥映射两个或多个GitHub账号" class="headerlink" title="2、解决同一台电脑生成两份或多份ssh密钥、公钥映射两个或多个GitHub账号"></a>2、解决同一台电脑生成两份或多份ssh密钥、公钥映射两个或多个GitHub账号</h2><blockquote><p>此解决方案由百度多个方案结合而来,截取对我有用部分</p></blockquote><h3 id="Ⅰ-需求分析"><a href="#Ⅰ-需求分析" class="headerlink" title="Ⅰ- 需求分析"></a>Ⅰ- 需求分析</h3><blockquote><p>本人注册一个GitHub账户，用来分享本人自己的开源项目或者代码，同时，公司注册了一个GitHub账户，用来分享公司的开源项目。如果按照单个ssh公钥生成的方法则会把之前的公钥覆盖掉，这样将导致其中一方在下一次上传代码，本机和GitHub无法映射成功。</p><p>解决这个问题首先要明确如何生成单个ssh公钥。<br>ssh生成单个公钥命令：<code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>。<a href="https://blog.csdn.net/mynameissls/article/details/50528048">如何生成ssh公钥</a><br>上述命令会在当前<code>~/.ssh</code>目录下生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。其中<code>id_rsa</code>是私钥文件，<code>id_rsa_.pub</code>是公钥文件。<br><code>id_rsa</code>和<code>id_rsa_.pub</code>文件都是通过一个邮箱号生成的，同一个公钥文件不可以配置两个不同GitHub账户（已测试）。<br>那么两个GitHub账户就需要两个不同的邮箱号，来生成两组不同的公钥文件。</p></blockquote><h3 id="Ⅱ-解决方案思路"><a href="#Ⅱ-解决方案思路" class="headerlink" title="Ⅱ- 解决方案思路"></a>Ⅱ- 解决方案思路</h3><blockquote><p>命令：<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -f ~/.ssh/id_rsa_example</code><br>示例：分别以<a href="mailto:&#55;&#57;&#x31;&#56;&#49;&#53;&#53;&#x36;&#x37;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#x6d;">&#55;&#57;&#x31;&#56;&#49;&#53;&#53;&#x36;&#x37;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#x6d;</a>和<a href="mailto:&#103;&#97;&#108;&#x61;&#120;&#121;&#115;&#x6f;&#x66;&#x74;&#64;&#x73;&#x69;&#110;&#97;&#46;&#99;&#x6e;">&#103;&#97;&#108;&#x61;&#120;&#121;&#115;&#x6f;&#x66;&#x74;&#64;&#x73;&#x69;&#110;&#97;&#46;&#99;&#x6e;</a>两个邮箱在<code>~/.ssh</code>目录下生成两级不同的公钥文件。<br><a href="mailto:&#55;&#x39;&#49;&#56;&#49;&#53;&#x35;&#54;&#x37;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;">&#55;&#x39;&#49;&#56;&#49;&#53;&#x35;&#54;&#x37;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;</a>邮箱：<code>ssh-keygen -t rsa -C &quot;791815567@qq.com&quot; -f ~/.ssh/id_rsa_me</code><br><a href="mailto:&#x67;&#x61;&#108;&#97;&#x78;&#x79;&#115;&#111;&#102;&#116;&#x40;&#115;&#105;&#x6e;&#97;&#46;&#x63;&#110;">&#x67;&#x61;&#108;&#97;&#x78;&#x79;&#115;&#111;&#102;&#116;&#x40;&#115;&#105;&#x6e;&#97;&#46;&#x63;&#110;</a>邮箱：<code>ssh-keygen -t rsa -C &quot;galaxysoft@sina.cn&quot; -f ~/.ssh/id_rsa_galaxysoft</code><br>生成过程可参考<a href="https://blog.csdn.net/mynameissls/article/details/50528048">如何生成单个ssh公钥</a> 这篇文章。<br>执行完成后，会以<code>~/.ssh</code>目录下看<a href="mailto:&#x37;&#57;&#49;&#x38;&#49;&#x35;&#53;&#x36;&#55;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">&#x37;&#57;&#49;&#x38;&#49;&#x35;&#53;&#x36;&#55;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;</a>邮箱对应的私钥文件<code>id_rsa_me</code>、公钥文件<code>id_rsa_me.pub</code>和<a href="mailto:&#103;&#97;&#x6c;&#97;&#120;&#x79;&#x73;&#x6f;&#102;&#116;&#x40;&#115;&#x69;&#x6e;&#x61;&#x2e;&#99;&#x6e;">&#103;&#97;&#x6c;&#97;&#120;&#x79;&#x73;&#x6f;&#102;&#116;&#x40;&#115;&#x69;&#x6e;&#x61;&#x2e;&#99;&#x6e;</a>邮箱对应的私钥文件<code>id_rsa_galaxysoft</code>、公钥文件<code>id_rsa_galaxysoft.pub</code><br>分别在两个GitHub账户中添加对应的公钥信息即可，可参考<a href="https://blog.csdn.net/mynameissls/article/details/50528048">如何生成单个ssh公钥</a> 这篇文章</p></blockquote><h3 id="Ⅲ-生成新ssh-key"><a href="#Ⅲ-生成新ssh-key" class="headerlink" title="Ⅲ- 生成新ssh key"></a>Ⅲ- 生成新ssh key</h3><blockquote><p>如果我们电脑上已经存在了一个ssh key，那么我们需要在我们电脑上生成第二个你想在本电脑上使用的id_rsa，使用命令：<code>ssh-keygen -t rsa -C &quot;你的github注册邮箱&quot;</code>。</p><p>下图红色标注部分会提示你把新生成的id_rsa存放到哪里，此处默认会存放在c盘的用户名下的.ssh文件夹下（即你第一个github用户ssh key存放的目录），因此我们需要输入路径/c/Users/DodoMonster/.ssh（注意此路径是你的系统盘下用户目录安放ssh密钥的目录，请使用自己电脑上相对应的目录），最后我以“id_rsa_me”重新命名了ssh key防止默认与已有的ssh key重复。</p><blockquote><p>在输入了路径后，会提示你输入提交项目时输入的验证密码，不输则表示不用密码，这是为了防止别人随便在你的项目上push东西，所以最好还是输入以下你的密码。回车，再重复输入确认回车即可。</p></blockquote></blockquote><h3 id="Ⅳ-添加新ssh-key"><a href="#Ⅳ-添加新ssh-key" class="headerlink" title="Ⅳ- 添加新ssh key"></a>Ⅳ- 添加新ssh key</h3><blockquote><p>默认SSH只会读取id_rsa，所以为了让SSH识别新的私钥，需要将其添加到SSH agent<br>使用命令：<code>ssh-add ~/.ssh/id_rsa_me</code>(后面的是自己取的名字)</p><p>如果报错：Could not open a connection to your authentication agent.无法连接到ssh agent<br>可执行<code>ssh-agent bash</code>命令后再执行<code>ssh-add</code>命</p><p>然后将公钥添加到git账号中 <a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p></blockquote><h3 id="Ⅴ-配置config文件"><a href="#Ⅴ-配置config文件" class="headerlink" title="Ⅴ- 配置config文件"></a>Ⅴ- 配置config文件</h3><blockquote><p>查看.ssh文件中是否存在config文件</p><p>如果已存在则直接编辑config文件，命令：<code>vim config</code> #这是linux的命令，进入了vim界面后按<code>a或i或A或I</code>进入编辑模式，编辑完成后按esc键输入<code>:wq</code> 保存文件退出</p><p>如果不存在则需要创建config文件，命令：<code>touch config</code>，再对config文件进行编辑</p><p>对config文件进行配置填写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Default 第一个账号(123456@xxxx.com)</span></span><br><span class="line"></span><br><span class="line">Host gsgit</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_me</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"><span class="comment">#second 第二个账号（38894403@xxxx.com）</span></span><br><span class="line">    </span><br><span class="line">Host mygit</span><br><span class="line">     HostName gitee.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><blockquote><p>其中Host 后的名字可以随意方便自己记忆，但HostName必须为<code>github.com(或者其它git地址)。</code></p></blockquote></blockquote><h3 id="Ⅵ-测试是否配置成功"><a href="#Ⅵ-测试是否配置成功" class="headerlink" title="Ⅵ- 测试是否配置成功"></a>Ⅵ- 测试是否配置成功</h3><blockquote><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ssh -T git@zc</span><br></pre></td></tr></table></figure><p>出现欢迎语则为配置成功。</p><p>注意：配置完成后，在连接Host不是github.com的github仓库时，远程库的地址要对应地做一些修改：</p><p>而并非原来的<a href="mailto:&#x67;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#111;&#x6d;">&#x67;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#111;&#x6d;</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">git <span class="built_in">clone</span> git@gitee.com:hongjilin/cx.git</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">//改为</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">git <span class="built_in">clone</span> git@mygit:hongjilin/cx.git</span></span><br></pre></td></tr></table></figure><p>这样每次连接都会使用id_rsa_me与服务器进行连接。</p><p>配置至此，大功告成！</p></blockquote><h3 id="Ⅶ-问题Mark"><a href="#Ⅶ-问题Mark" class="headerlink" title="Ⅶ- 问题Mark"></a>Ⅶ- 问题Mark</h3><blockquote><p>当我切换到另外一个账号提交时 commit的提交者仍寻找全局配置中的username作为签名 而不是当前本地库绑定提交账号的用户名(所以我用公司账号的<code>.ssh</code>配置绕过了组织检测,但是署名却用的是个人账户)</p><p>别小看这个BUG,挺恐怖的,下面举个我的栗子:</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210621172453710.png" alt="image-20210621172453710"></p><p>到这时候你可能觉得好像也没啥吧?但是我个人账号不是公司组织里面的(也不好解释)、计算公司个人绩效时也无法统计、之前版本还无法用搜索条件查找我个人账号(因为本身个人账号就不是组织里面的)的提交…..问题可大可小</p><p>所以此处<code>Mark</code>,留待后续学习生活解决</p></blockquote><h4 id="此问题解决"><a href="#此问题解决" class="headerlink" title="此问题解决"></a>此问题解决</h4><blockquote><p>之前只是将此问题Mark,但是未将解决方式具体写下,现将其更新</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210621171934972.png" alt="image-20210621171934972"></p><p>或者可以直接写个python小脚本来修改:如果根据该仓库clone时的账号来进行切换是否更合理,这是个好办法… </p></blockquote><h2 id="3、commit报错无法提交"><a href="#3、commit报错无法提交" class="headerlink" title="3、commit报错无法提交"></a>3、commit报错无法提交</h2><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt; running pre-commit hook: lint-staged</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[STARTED] Preparing...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[FAILED] warning: LF will be replaced by CRLF <span class="keyword">in</span> sh.exe.stackdump.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[FAILED] The file will have its original line endings <span class="keyword">in</span> your working directory.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[STARTED] Running tasks...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[SKIPPED] Skipped because of previous git error.</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[STARTED] Applying modifications...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[SKIPPED]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[SKIPPED]   × lint-staged failed due to a git error.</span></span><br><span class="line"></span><br><span class="line"> × lint-staged failed due to a git error.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[STARTED] Cleaning up...</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">[SKIPPED]   × lint-staged failed due to a git error.</span></span><br><span class="line"> Any lost modifications can be restored from a git stash:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">pre-commit hook failed (add --no-verify to bypass)</span></span><br></pre></td></tr></table></figure><p>解决方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">执行npm run lint， 根据提示修改错误（推荐）</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">git commit -m <span class="string">&quot;&quot;</span> --no-verify 绕过了lint的检查</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="4、Git提交时出现-合并提示-Merge-branch-39-master-39-of-之解决方法"><a href="#4、Git提交时出现-合并提示-Merge-branch-39-master-39-of-之解决方法" class="headerlink" title="4、Git提交时出现(合并提示)Merge branch &#39;master&#39; of ...之解决方法"></a>4、Git提交时出现(<code>合并提示</code>)<code>Merge branch &#39;master&#39; of ...</code>之解决方法</h2><blockquote><p>多人协作开发项目，在上传代码时通常会先pull一下远程代码，使本地与远程同步更新，但是如果远程此时与自己代码存在冲突，在解决冲突后提交有时会出现“Merge branch ‘master’ of …”这条信息。这是因为pull其本质是fetch+Merge的结合。通常会分为以下两种情况：</p><p>1.如果远程分支超前于本地分支，并且本地也没有commit操作，此时pull会采用’fast-forward’模式，该模式不会产生合并节点，也即不产生”Merge branch ‘master’ of …”信息。</p><p>2.如果本地有commit提交，此时若存在冲突，pull拉取代码时远程和本地会出现分叉，会进行分支合并，就会产生”Merge branch ‘master’ of …”信息。</p><p><strong>解决方法</strong></p><blockquote><p>使用<code>git pull --rebase</code>命令，如果没有冲突,则会直接合并，如果存在冲突，手动解决冲突即可，不会再产生那条多余的信息。如果你不想每次都rebase，可以在git bash里执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;git config --global pull.rebase <span class="literal">true</span></span></span><br></pre></td></tr></table></figure><p>这个配置就是告诉git在每次pull前先进行rebase操作。</p></blockquote></blockquote><h3 id="①-可能出现的相关报错error-Cannot-pull-with-rebase"><a href="#①-可能出现的相关报错error-Cannot-pull-with-rebase" class="headerlink" title="① 可能出现的相关报错error:Cannot pull with rebase"></a>① 可能出现的相关报错<code>error:Cannot pull with rebase</code></h3><blockquote><ol><li>git 执行<code>git pull –rebase</code>后报错误如下：</li></ol>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: cannot pull with rebase: Your index contains uncommitted changes.</span><br><span class="line">error: please commit or stash them.</span><br></pre></td></tr></table></figure><ol start="2"><li><p>原因：如果有未提交的更改，是不能git pull的</p></li><li><p>解决：</p></li></ol><ul><li>先执行<code>git stash</code>    –&gt;#可用来暂存当前正在进行的工作</li><li>再执行<code>git pull –-rebase</code></li><li>最后再执行<code>git stash pop</code>  –&gt;#从Git栈中读取最近一次保存的内容</li></ul><ol start="4"><li>截图示例</li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210705115521085.png" alt="image-20210705115521085"></p></blockquote><h3 id="②-防止冲突的有效操作"><a href="#②-防止冲突的有效操作" class="headerlink" title="② 防止冲突的有效操作"></a>② <em>防止冲突的有效操作</em></h3><blockquote><p>不要直接用<code>git pull</code>拉取,而是分开操作,先拉取代码(拉取后可以先查看冲突部分取解决).随后再去合并</p><ol><li><code>git fetch 别名</code>(将修改同步到远程跟踪分支上)</li><li>git merge 远程跟踪分支</li></ol></blockquote><h2 id="5、Git删除误提交的大文件历史记录"><a href="#5、Git删除误提交的大文件历史记录" class="headerlink" title="5、Git删除误提交的大文件历史记录"></a>5、Git删除误提交的大文件历史记录</h2><blockquote><ol><li>应用场景:在我们日常使用Git的时候，一般比较小的项目，我们可能不会注意到.git 这个文件。其实.git文件主要用来记录每次提交的变动，当我们的项目越来越大的时候，我们发现.git文件越来越大。很大的可能是因为提交了大文件，如果你提交了大文件，那么即使你在之后的版本中将其删除，但是<code>实际上记录中的大文件仍然存在</code>。</li><li>原因分析:为什么呢？仔细想一想，虽然你在后面的版本中删除了大文件，但是Git是有版本倒退功能的吧，那么如果大文件不记录下来，git拿什么来给你回退呢？</li><li>导致的问题:.git文件越来越大导致的问题是–每次拉项目都要耗费大量的时间，并且每个人都要花费那么多的时间。</li><li>git给出了解决方案，使用git branch-filter来遍历git history tree, 可以永久删除history中的大文件，达到让.git文件瘦身的目的。</li></ol><p>下面给出步骤（以下步骤非常危险，<code>操作需谨慎!</code>,最好最好不要在公司项目中使用）</p></blockquote><h3 id="Ⅰ-列出仓库中最大的几个对象及其文件名"><a href="#Ⅰ-列出仓库中最大的几个对象及其文件名" class="headerlink" title="Ⅰ-列出仓库中最大的几个对象及其文件名"></a>Ⅰ-列出仓库中最大的几个对象及其文件名</h3><blockquote><p>列出所有仓库中的对象（包括SHA值、大小、路径等），并按照大小降序排列，列出TOP 5(本人示例,你也可多展示)</p><ol><li>命令示例</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --all --objects | grep <span class="string">&quot;<span class="subst">$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -n 5 | awk -F &#x27; &#x27;  &#x27;&#123;print $1&#125;&#x27;)</span>&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>图示</li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%88%97%E5%87%BA%E4%BB%93%E5%BA%93%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%87%E4%BB%B6%E5%90%8D.png" alt="image-20210508171542001"></p></blockquote><h3 id="Ⅱ-将某文件从历史记录中删除"><a href="#Ⅱ-将某文件从历史记录中删除" class="headerlink" title="Ⅱ-将某文件从历史记录中删除"></a>Ⅱ-将某文件从历史记录中删除</h3><blockquote><p>既然文件找到了(此处删除<code>杂记_其他(如破解与配置)的碎片化笔记/Typora笔记软件分享/tools/软件包/Typora.dmg</code>)，那么得将该文件从历史记录中删除，执行以下命令：</p><ol><li>命令示例:</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --branches -- <span class="string">&quot;杂记_其他(如破解与配置)的碎片化笔记/Typora笔记软件分享/tools/软件包/Typora.dmg&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>图示</li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210508171916951.png" alt="image-20210508171916951"></p></blockquote><h3 id="Ⅲ-重写所有-commit，将该文件从-Git-历史中完全删除"><a href="#Ⅲ-重写所有-commit，将该文件从-Git-历史中完全删除" class="headerlink" title="Ⅲ-重写所有 commit，将该文件从 Git 历史中完全删除"></a>Ⅲ-重写所有 commit，将该文件从 Git 历史中完全删除</h3><blockquote><p>上面的命令执行后只是从历史记录中移除，还没有完全删除它，我们需要重写所有 commit，将该文件从 Git 历史中完全删除：</p><ol><li>代码示例:</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch  &quot;杂记_其他(如破解与配置)的碎片化笔记/Typora笔记软件分享/tools/软件包/Typora.dmg&quot;&#x27;</span> -- --all</span><br></pre></td></tr></table></figure><ol start="2"><li>图示</li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%88%A0%E9%99%A4%E6%88%AA%E5%9B%BE.png"></p><ol start="3"><li>补充注意点:</li></ol><p>  如果你像我一样,工作区有新写的内容没有追踪与提交导致无法进行删除操作时,千万不要直接暂存<code>stash</code>,否则这些没有暂存的内容就没了,要记得先<code>git add .</code></p></blockquote><h3 id="Ⅳ-把该文件的引用完全删除"><a href="#Ⅳ-把该文件的引用完全删除" class="headerlink" title="Ⅳ-把该文件的引用完全删除"></a>Ⅳ-把该文件的引用完全删除</h3><blockquote><p>上面的命令执行后，此时历史记录中已经没有该文件了，此时是真正删除了它。 不过我们运行 filter-branch 产生的日志还是会对该文件有引用，所以我们还需要运行以下几条命令，把该文件的引用完全删除：</p><ol><li>命令示例:</li></ol> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .git/refs/original/</span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git gc --prune=now</span><br><span class="line">git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure><ol start="2"><li>图示</li></ol><p> <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510183253770.png" alt="image-20210510183253770"></p><ol start="3"><li>果真编程其实殊途同归,该学的都得学,这里就暴露的Linux没学好的弊端,所以暗下决心,争取今年内将linux系统学习一遍</li></ol></blockquote><h3 id="Ⅴ-强制提交"><a href="#Ⅴ-强制提交" class="headerlink" title="Ⅴ-强制提交"></a>Ⅴ-强制提交</h3><blockquote><p>现在我们再看 .git 文件的大小明显变小了，少了那个大文件，说明我们之前误提交的大文件已经删除了。 最后一步就是 push 代码了，不过就是需要强制 push</p><ol><li>命令示例</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force</span><br></pre></td></tr></table></figure><ol start="2"><li>图示</li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%BC%BA%E5%88%B6%E6%8F%90%E4%BA%A4.jpg"></p></blockquote><h3 id="Ⅵ-远程仓库GC"><a href="#Ⅵ-远程仓库GC" class="headerlink" title="Ⅵ-远程仓库GC"></a>Ⅵ-远程仓库GC</h3><blockquote><p>网上所能百度的方法中都没有说到要进行远程存储库GC,但是本人操作后发现,明明命令行中运行了<code>git gc</code>,但你的远程仓库仍然会非常庞大甚至更加庞大,也许你本地已经删减至几十兆,但是远程仓库已经”爆仓”达到<code>1300+兆</code>,详见<code>问题7</code></p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510180757993.png" alt="image-20210510180757993"></p></blockquote><h3 id="Ⅶ-删除前后-git大小对比"><a href="#Ⅶ-删除前后-git大小对比" class="headerlink" title="Ⅶ-删除前后.git大小对比"></a>Ⅶ-删除前后<code>.git</code>大小对比</h3><blockquote><p>本人此时测试删除的文件正好为10M,成功删除</p><ol><li>删除前截图</li></ol> <img src="A_Git详细学习笔记中的图片/删除大文件前大小.png" style="zoom:67%;" /><ol start="2"><li>删除后截图</li></ol> <img src="A_Git详细学习笔记中的图片/删除大文件后大小.png" style="zoom:67%;" /><ol start="3"><li>删除多个文件后</li></ol>  <img src="A_Git详细学习笔记中的图片/image-20210508182039450.png" alt="image-20210508182039450" style="zoom:67%;" /></blockquote><h2 id="6、git出现文件夹后面跟-数字问题"><a href="#6、git出现文件夹后面跟-数字问题" class="headerlink" title="6、git出现文件夹后面跟@+数字问题"></a>6、git出现文件夹后面跟<code>@+数字</code>问题</h2><blockquote><ol><li><p>问题出现场景:本人欲将两个仓库代码合到一个仓库中,但是原本文件夹内还有.git，导致这些文件夹push后变成了子模块</p></li><li><p>问题场景图例–&gt;具体出问题时并没有截图,此处截图提交时差别(原本应该是一大堆V1.0的文件,结果只有一个文件夹,后面跟着哈希值)</p></li></ol><p>  <img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510171915185.png" alt="image-20210510171915185"></p><ol start="3"><li>解决思路</li></ol><blockquote><p>删除原来的子文件夹的.git  –&gt;<code>rm -r .git</code>,当然也可以手动删除</p><p>删除本地git缓存  –&gt;<code>git rm -r --cached fileName</code></p><p>重新add，push </p></blockquote><ol start="4"><li>解决结果截图</li></ol>  <img src="A_Git详细学习笔记中的图片/image-20210510172159472.png" alt="image-20210510172159472" style="zoom:67%;" /></blockquote><h2 id="7、远程仓库过大导致无法push"><a href="#7、远程仓库过大导致无法push" class="headerlink" title="7、远程仓库过大导致无法push"></a>7、远程仓库过大导致无法push</h2><blockquote><p>问题出现场景:在前两天本人发现笔记仓库过大 已经达到600M的时候,本人花了一些时间将无用的大文件删除(详见<code>问题5</code>),并且减小到了100M+,然后推送上了gitee上,但是今天push的时候突然报错仓库过大无法推送</p><ol><li><p>问题报错截图<img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510180415796.png" alt="image-20210510180415796"></p></li><li><p>本人就产生很大的疑惑,明明我本地仓库才100+M,<code>.git</code>文件也才86M,但是远程仓库竟然达到了恐怖的1300M+(当时急于寻找解决方案,没有截图)</p></li></ol><p>  本人推测(不确定,也找不到人问,朋友都没经历过这个情况,所以引出记录待定,如果有小伙伴知道了希望可以发在评论区或者私信我)</p><ol><li><p>当时我是将多条命令一起复制进去运行,可能导致<code>git gc</code>命令没有运行到(可能性极小,但还是留下悔恨的泪水)</p></li><li><p>也许本地的gc命令只是清理了本地仓库的,远程也要清理,但这个并不重要,知道了这个点后我们能进行解决了</p><p> <img src="A_Git详细学习笔记中的图片/image-20210510180539437.png" alt="image-20210510180539437" style="zoom:50%;" /><img src="A_Git详细学习笔记中的图片/image-20210510181407805.png" alt="image-20210510181407805" style="zoom:67%;" /></p></li><li><p>问题解决:</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510180757993.png" alt="image-20210510180757993"></p><p>GC后内存<img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210510181329197.png" alt="image-20210510181329197"></p></li><li><p>GC详解</p></li></ol><blockquote><p>Git的底层并没有采用 CVS、SVN 底层所采用的那套增量式文件系统，而是采用一套自行维护的存储文件系统。当文件变动发生提交时，该文件系统存储的不是文件的差异信息，而是文件快照，即整个文件内容，并保存指向快照的索引。这种做法，提高 Git 分支的使用效率；但也容易导致代码仓库中内容重复程度过高，从而仓库体积过大。当遇到这种情况时，或者需要将仓库推送到远程主机时，就需要Git中的gc（garbage collect）功能，也就是<code>垃圾回收功能</code>。</p><p>大体来说，当运行 “git gc” 命令时，Git会收集所有松散对象并将它们存入 packfile，合并这些 packfile 进一个大的 packfile，然后将不被任何 commit 引用并且已存在一段时间 (数月) 的对象删除。 此外，Git还会将所有引用 (references) 并入一个单独文件。</p><p>就细节而言，Git做了这几件事：</p><p>pack_refs 过程<br>reflog expire 过程<br>repack 过程<br>prune 过程<br>rerere 过程</p><p>pack_refs 过程相当于执行”git pack-refs –all –prune”，它会将$GIT_DIR/refs目录下的所有heads和tags打包成一个文件并保存为$GIT_DIR/packed-refs下。</p><p>reflog expire 过程相当于执行”git reflog expire –all”，它会将删除所有超过期限而且没有被refs涉及的reflog条目。</p><p>repack 过程相当于执行”git repack -d -l”，一般情况下还会包括”-A”选项，它会将所有未被包含在一个pack的松散对象连结成一个pack，也会将现有的pack重新组织为一个新的更有效率的pack，并删除冗余的pack（如果她们中存在不可达的松散对象，会先把这些对象释放出来）。</p><p>prune 过程相当于执行”git prune –expire”，他会删除所有过期的、不可达的且未被打包的松散对象。</p><p>rerere 过程相当于执行”git rerere gc”，这种情形下似乎没什么用。</p><p>所以本人推测应该是进行了<code>问题5</code>操作后还需要<code>进行一次GC操作</code></p></blockquote></blockquote><h2 id="8、Git-GUI中文乱码问题解决方法"><a href="#8、Git-GUI中文乱码问题解决方法" class="headerlink" title="8、Git GUI中文乱码问题解决方法"></a>8、Git GUI中文乱码问题解决方法</h2><blockquote><p>当我们使用Git GUI的查看代码的时候，有时候会出现中文乱码：</p><ol><li>解决方案1:直接在<code>GIT GUI</code>中操作</li></ol><p>  **<img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210701180547401.png" alt="image-20210701180547401"> </p><ol start="2"><li>解决方案2:命令行</li></ol>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global gui.encoding utf-8</span><br></pre></td></tr></table></figure><ol start="3"><li>解决方案3:直接修改配置文件</li></ol><blockquote><p>在软件的安装目录下，在<code>Git\mingw32\etc\gitconfig</code>文件末尾添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;[gui]encoding=utf-8</span><br></pre></td></tr></table></figure></blockquote></blockquote><h2 id="9、Git-切换远程仓库地址"><a href="#9、Git-切换远程仓库地址" class="headerlink" title="9、Git 切换远程仓库地址"></a>9、Git 切换远程仓库地址</h2><blockquote><p>在公司开发中,也许会遇到公司项目地址迁移的问题(本人就遇到了) : 比如从码云gitee上将项目迁移到gitLab上,那么我们本地怎么切换远程仓库地址呢? 很简单!</p><ol><li>切换远程仓库地址</li></ol><ul><li><p><strong>方式一：修改远程仓库地址</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin URL <span class="comment">#更换远程仓库地址，URL为新地址。一步到胃</span></span><br></pre></td></tr></table></figure></li><li><p><strong>方式二：先删除远程仓库地址，然后再添加</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> origin <span class="comment">#删除现有远程仓库</span></span><br><span class="line">git remote add origin url <span class="comment">#添加新远程仓库</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>查看远程仓库地址</li></ol><blockquote><p>没错,改完了,很简单是吧,但是你怎么确定自己是否修改成功了呢?</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v  <span class="comment">#查看远程仓库的地址</span></span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>截图示例</li></ol><blockquote><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Git%E5%88%87%E6%8D%A2%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80.png" alt="Git 切换远程仓库地址"></p></blockquote></blockquote><h2 id="10、如何撤销-commit-提交"><a href="#10、如何撤销-commit-提交" class="headerlink" title="10、如何撤销 commit 提交"></a>10、如何撤销 commit 提交</h2><blockquote><ol><li>一般我们写完代码后,是这样提交的:</li></ol><ul><li>git add . //添加追踪所有文件</li><li>git commit -m “feat(前端-Git学习详细笔记):更新撤销commit操作” //添加commit提交信息</li></ul><ol start="2"><li>但是commit写完提交信息后,突然想到还有一个地方代码没改到/保存,如果放到下一个commit却不合适(同一个功能修改,分成两个commit),原因详见上方的 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E2%85%A3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">版本控制工具的使用基本原则</a> </li><li>执行此命令命令:<code>git reset --soft HEAD^</code></li></ol><ul><li>HEAD^的意思是上一个版本，也可以写成HEAD~1</li><li>如果你进行了2次commit，想都撤回，可以使用HEAD~2</li><li>详见 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#reset%E4%B8%89%E9%83%A8%E6%9B%B2">reset三部曲</a></li></ul><p>作用:将文件从<code>暂存区中撤回</code>到工作目录中(仅仅是撤回commit操作，你写的代码仍然保留)</p></blockquote><h2 id="11、错误的git-push提交成功后如何撤销回退"><a href="#11、错误的git-push提交成功后如何撤销回退" class="headerlink" title="11、错误的git push提交成功后如何撤销回退"></a>11、错误的git push提交成功后如何撤销回退</h2><blockquote><p>我们在使用Git进行版本控制时，有可能会出现这种情况。git push后发现提交的内容不是想要的，这时候我们怎么做呢，提交上去的内容是没有删除按钮的（比如github，或码云）。所以我们需要一些手段将提交上去内容撤销下来。</p><p>而要撤销,就要用到上面所学的 <code>git reset</code></p></blockquote><h3 id="1、错误场景示范-1"><a href="#1、错误场景示范-1" class="headerlink" title="1、错误场景示范"></a>1、错误场景示范</h3><blockquote><p>Ⅰ- 当我撰写 [ commit ] 信息没注意到,以为是对的时候直接提交 –&gt; 因为本人提交笔记时喜欢按 [ ↑ ] 找到之前的提交信息进行修改</p><img src="A_Git详细学习笔记中的图片/image-20210813153403664.png" alt="image-20210813153403664" style="zoom:67%;" /> <p>Ⅱ- 此时可以看到,错误的 [ commit ] 已经提交了 (当然,适用场景不只是commit ,也可错误代码之类的)</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155746112.png" alt="image-20210813155746112"> </p></blockquote><h3 id="2、回退操作-1"><a href="#2、回退操作-1" class="headerlink" title="2、回退操作"></a>2、回退操作</h3><blockquote><p>咱们操作稳重一点,使用git reset –soft HEAD~就好了(如果回退后代码也不想要,可以用<code>git stash</code>,暂存,达到代码也回退的效果)</p></blockquote><h4 id="①-git-reflog-1"><a href="#①-git-reflog-1" class="headerlink" title="① git reflog"></a>① git reflog</h4><blockquote><p>commits，它在git中扮演了一个重要角色，我们平常用的一些操作git clone ,git commit 都会产生commits，通俗的讲这个就是版本号，但是git reset并不会产生commits（不是不会产生，而是会产生 但是都是一样的），我们可以先看看自己项目中的commits，使用如下命令:<code>git reflog</code></p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154309057.png" alt="image-20210813154309057"> </p></blockquote><h4 id="②-git-reset-–soft-HEAD-1"><a href="#②-git-reset-–soft-HEAD-1" class="headerlink" title="②  git  reset –soft HEAD~"></a>②  git  reset –soft HEAD~</h4><blockquote><p>运行此代码后,我们的 [ HEAD ] 指向了上一个 [ commits ]</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154448889.png" alt="image-20210813154448889"> </p></blockquote><h4 id="③-查看缓存-1"><a href="#③-查看缓存-1" class="headerlink" title="③  查看缓存"></a>③  查看缓存</h4><blockquote><ul><li><p>此时你可以用<code>stash staus</code>查看,会发现,之前提交的代码已经放回缓存区了</p></li><li><p>如果你不想要此次提交所有代码,可以使用<code>git stash</code> ,然后再去清空即可(当然,本人此处还是需要的,所以要留下)</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154839981.png" alt="image-20210813154839981"> </p></li></ul></blockquote><h4 id="④-重新撰写-commit-信息-1"><a href="#④-重新撰写-commit-信息-1" class="headerlink" title="④ 重新撰写 [ commit ]信息"></a>④ 重新撰写 [ commit ]信息</h4><blockquote><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813154928064.png" alt="image-20210813154928064"> </p></blockquote><h4 id="⑤-强制提交-1"><a href="#⑤-强制提交-1" class="headerlink" title="⑤ 强制提交"></a>⑤ 强制提交</h4><blockquote><p>如果你重新撰写 [ commit ] 后马上重新push,你会发现无法提交: 因为我们当前落后远程一个版本!</p><p>所以此时直接强制提交即可,就能覆盖远程提交记录</p><blockquote><p><code>git push -f</code></p></blockquote><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155049169.png" alt="image-20210813155049169"> </p></blockquote><h3 id="3、成功展示-1"><a href="#3、成功展示-1" class="headerlink" title="3、成功展示"></a>3、成功展示</h3><blockquote><ul><li>在网站工作台首页能看到已经将更改后的 [ coommit ] 强制推送上来了</li></ul><p>也许你会奇怪:为啥工作台上还能看到? 其实已经删了!!!你看下方</p><p><img src="A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210813155614570.png" alt="image-20210813155614570"> </p><ul><li>但是你查看提交记录,会发现之前错误的commit已经被覆盖</li></ul><img src="A_Git详细学习笔记中的图片/image-20210813155339300.png" alt="image-20210813155339300" style="zoom:80%;" /></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

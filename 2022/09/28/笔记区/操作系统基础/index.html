<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统基础笔记 | 博客</title><meta name="author" content="Arche"><meta name="copyright" content="Arche"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统基础详细学习">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统基础笔记">
<meta property="og:url" content="https://guizhan.github.io/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="操作系统基础详细学习">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/10_1 (5).jpg">
<meta property="article:published_time" content="2022-09-28T14:12:51.000Z">
<meta property="article:modified_time" content="2022-10-01T07:56:51.229Z">
<meta property="article:author" content="Arche">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/10_1 (5).jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://guizhan.github.io/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Arche","link":"链接: ","source":"来源: 博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统基础笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-01 15:56:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/color.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标题</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/10_1 (5).jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标题</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统基础笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-28T14:12:51.000Z" title="发表于 2022-09-28 22:12:51">2022-09-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-01T07:56:51.229Z" title="更新于 2022-10-01 15:56:51">2022-10-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统基础笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="弱弱的问一问-要操作系统干嘛？"><a href="#弱弱的问一问-要操作系统干嘛？" class="headerlink" title="弱弱的问一问: 要操作系统干嘛？"></a>弱弱的问一问: 要操作系统干嘛？</h3><p>这里先不讲<code>操作系统</code>的概念了，因为文字太生硬了，我们只需要看一个简单的例子：</p>
<ul>
<li>在我们的JS代码里，只需要输入 <code>console.log(1+1)</code>; 就可以在浏览器面板中看到<code>2</code>，这其中发生了什么事情呢?(简单扫一眼)</li>
<li>首先键盘输入代码<code>1+1</code>到显示器输出<code>2</code>, 需要<code>CPU</code>控制键盘（输入设备） ，将获取的<code>1+1</code>指令放入内存</li>
<li>然后CPU的控制器从内存中取出指令，并分析出指令是让计算机做一个<code>1+1</code>的加法运算</li>
<li>此时CPU的控制将控制CPU的运算器做<code>1+1</code>的加法运算，并得出结果<code>2</code></li>
<li>最后CPU控制器控制运算器将结果返给内存，内存也在CPU控制器的控制下，将结果<code>2</code>返回给屏幕（输出设备）</li>
</ul>
<p>好了，这里问题是，如果没有操作系统，一个简单的1+1运算，你的js代码还需要考虑这些硬件的协调工作，比如你的代码要协调CPU资源什么时候读取你的代码，什么时候把进程切换到别的进程。。。这些脏活累活都是操作系统帮你屏蔽了，要不这代码可咋写啊。。。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/625bd319664a4c47ac3e09c42af27648~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="弱弱的问一问-前端学这个干嘛？"><a href="#弱弱的问一问-前端学这个干嘛？" class="headerlink" title="弱弱的问一问: 前端学这个干嘛？"></a>弱弱的问一问: 前端学这个干嘛？</h3><p>很早以前看朴零大神的《深入浅出NodeJS》的时候，讲到进程间通信，有一句大概说，windows平台进程间通信用的是管道，linux平台用的是domain socket，我一看就傻眼了，啥是进程间通信？啥是管道？啥是domain socket？😭 看不懂啊….  这些都是跟操作系统进程的知识相关）。</p>
<p>啥也了不说了，兄弟，学习的小车已经粗发了！</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bed1a16e29e94f2493459b2ac958daa1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="2、操作系统运行机制和体系结构"><a href="#2、操作系统运行机制和体系结构" class="headerlink" title="2、操作系统运行机制和体系结构"></a>2、操作系统运行机制和体系结构</h3><p>预备知识： 什么是指令（更详细内容请看我的计算机组成原理文章）</p>
<p>比如说，如下图（简单扫一下即可）：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7e94d10138444fca675d3e78771cd3d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>a+b是一段程序代码，a+b在CPU看来并不能一步完成，可以翻译成如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 意思是将内存的<span class="number">16</span>号单元数据，放到<span class="selector-tag">A</span>寄存器，</span><br><span class="line">LOAD <span class="selector-tag">A</span>, <span class="number">16</span></span><br><span class="line">// 意思是将内存的<span class="number">16</span>号单元数据，放到<span class="selector-tag">B</span>寄存器</span><br><span class="line">LOAD <span class="selector-tag">B</span>, <span class="number">17</span></span><br><span class="line">// 存器里的<span class="selector-tag">A</span>,<span class="selector-tag">B</span>数据相加，得到C</span><br><span class="line">ADD C, <span class="selector-tag">A</span>, <span class="selector-tag">B</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里就可以看得出来，指令是<code>CPU</code>能<code>识别</code>和<code>执行</code>的最基本命令。</p>
<h4 id="2-1-两种指令、两种处理器状态、两种程序"><a href="#2-1-两种指令、两种处理器状态、两种程序" class="headerlink" title="2.1 两种指令、两种处理器状态、两种程序"></a>2.1 两种指令、两种处理器状态、两种程序</h4><p>假如说一个用户可以随意把服务器上的所有文件删光，这是很危险的。所以有些指令普通用户是不能使用的，只能是<code>权限较高</code>的用户能使用。此时指令就分为了两种，如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c63454bc3f6d47ada18e16ac8b1448bb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>这就引出一个问题：CPU<code>如何判断</code>当前是否可以执行<code>特权指令</code>？ 如下图: <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ffec6ba8bb84fd3b671562ddaa4dd3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> CPU通常有两种工作模式即：<code>内核态</code>和<code>用户态</code>，而在PSW（这个不用管，就知道有一个寄存器的标志位0表示用户态，1表示核心态）中有一个二进制位控制这两种模式。</p>
<p>对于应用程序而言，有的程序能执行特权指令，有的程序只能执行非特权指令。所以操作系统里的程序又分为两种：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2b1d866079496989d6aa802976c718~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h4 id="2-2-操作系统内核简单介绍"><a href="#2-2-操作系统内核简单介绍" class="headerlink" title="2.2 操作系统内核简单介绍"></a>2.2 操作系统内核简单介绍</h4><p>从下图，我们先看看操作系统内核包含哪些</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7aad0ff1519c45e88923eac0ca186ff1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>操作系统内核中跟硬件紧密相关的部分有：</p>
<ul>
<li>时钟管理。操作系统的时钟管理是依靠<code>硬件定时器</code>的（具体硬件怎么实现我也不太清楚，好像是靠硬件周期性的产生一个脉冲信号实现的）。时钟管理相当重要，比如我们<code>获取时间信息</code>，<code>进程切换</code>等等都是要依靠时钟管理。</li>
<li>中断处理（下一小节会详细介绍）。</li>
<li>原语（后面会有案例提到）。现在可以简单理解为用来实现某个特定功能，在执行过程中<code>不可被中断</code>的指令集合。原语有一个非常重要的特性，就是原子性（其运行<code>一气呵成，不可中断</code>）。</li>
</ul>
<h4 id="2-3-中断"><a href="#2-3-中断" class="headerlink" title="2.3 中断"></a>2.3 中断</h4><ul>
<li>在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU<code>暂时中止程序的执行</code>转而<code>处理这个新的情况</code>的过程就叫做<code>中断</code>。 下面举一个例子：</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbb1d6ab19194af0990f24f1d4f3b54c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 第一个应用程序在用户态执行了一段时间后 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62afac3d324d4d4db8a4e6e594861cfd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 接着操作系统切换到核心态，处理中断信号 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff2fa4931c914df39b70b5165d50e5d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>操作系统发现<code>中断的信号</code>是第一个程序的时间片（每个程序不能一直执行，CPU会给每个程序一定的执行时间，这段时间就是时间片）用完了，应该换第二个应用程序执行了</li>
<li>切换到<code>第2个进程</code>后，操作系统会将<code>CPU</code>的<code>使用权</code>交换给第二个应用程序，接着第二个应用程序就在<code>用户态</code>下开始执行。</li>
<li><code>进程</code>2需要调用<code>打印机资源</code>，这时会执行一个<code>系统调用</code>（后面会讲系统调用，这里简单理解为需要操作系统进入核心态处理的函数），让操作系统进入核心态，去调用打印机资源</li>
<li>打印机开始工作，<code>此时进程2</code>因为要等待打印机启动，操作系统就不等待了（等到打印机准备好了，再回来执行程序2），直接切换到<code>第三个应用程序</code>执行</li>
<li>等到打印机准备好了，此时打印机通过I/O控制器会给操作系统发出一<code>个中断信号</code>，操作系统又进入到核心态，发现这个中断是因为<code>程序2</code>等待打印机资源，现在打印机准备好了，就切换到<code>程序2</code>，切换到<code>用户态</code>，把CPU给程序2继续执行。</li>
</ul>
<p>好了，现在可以给出一个结论，就是用户态、核心态之间的切换是怎么实现的?</p>
<ul>
<li>“用户态 —&gt; 核心态”是通过中断实现的。<code>并且中断时唯一途径</code>。</li>
<li>“核心态 —&gt; 用户态”的切换时通过执行一个特权指令，将程序状态的标志位设为用户态。</li>
</ul>
<h4 id="2-4-中断的分类"><a href="#2-4-中断的分类" class="headerlink" title="2.4 中断的分类"></a>2.4 中断的分类</h4><p>举一个例子，什么是内中断和外中断：</p>
<p>接着说之前的范桶同学，小时候不爱学习，每次学习着学习着突然异想天开，回过神来已经过好好长一段时间，这是<code>内部中断</code>。想着想着老师走过来，给了范捅一嘴巴，这是<code>外部中断</code>。</p>
<p>官方解释如下： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dcf78ddde4945f0b93f7d55952f64da~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>内中断常见的情况如<code>程序非法操作</code>(比如你要拿的的数据的内存地址不是内存地址，是系统无法识别的地址)，<code>地址越界</code>(比如系统给你的程序分配了一些内存，但是你访问的时候超出了你应该访问的内存范围)、<code>浮点溢出</code>(比如系统只能表示1.1到5.1的范围，你输入一个100, 超出了计算机能处理的范围)，或者<code>异常</code>，<code>陷入trap</code>（是指应用程序请求系统调用造成的，什么是系统调用，后面小节会举例讲）。</li>
<li>外中断常见的情况如<code>I/O中断</code>（由I/O控制器产生，用于发送信号通知操作完成等信号，比如进程需要请求打印机资源，打印机有一个启动准备的过程，准备好了就会给CPU一个I/O中断，告诉它已经准备好了）、<code>时钟中断</code>（由处理器内部的计时器产生，允许操作系统以一定规程执行函数，操作系统每过大约15ms会进行一次线程调度，就是利用时钟中断来实现的）。</li>
</ul>
<h4 id="2-5-系统调用"><a href="#2-5-系统调用" class="headerlink" title="2.5 系统调用"></a>2.5 系统调用</h4><blockquote>
<p>为什么需要系统调用？</p>
</blockquote>
<ul>
<li>比如你的程序需要<code>读取文件信息</code>，可读取文件属于<code>读取硬盘里的数</code>据，这个操作应该时CPU在<code>内核态</code>去完成的，我们的应用程序怎么让CPU去帮助我们切换到内核态完成这个工作呢，这里就需要<code>系统调用了</code>。</li>
<li>这里就引出系统调用的概念和作用。</li>
<li>应用程序<code>通过系统调用请求操作系统的服务</code>。系统中的各种共享资源都由操作系统统一管理，因此在用户程序中，凡是与<code>资源有关的操作</code>（如存储分配、I/O操作、文件管理等），都<code>必须</code>通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。</li>
</ul>
<p>以下内容简单看一下即可，系统调用的分类：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63e2b27cc0914088a2d0357ab332ade7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>需要注意的是，<code>库函数</code>和<code>系统调用</code>容易混淆。</p>
<ul>
<li>库是可重用的模块 <code>处于用户态</code></li>
<li>进程通过系统调用从用户态进入<code>内核态</code>， 库函数中有很大部分是对系统调用的封装</li>
</ul>
<p>举个例子：比如<code>windows</code>和<code>linux</code>中，创建进程的系统调用方法是不一样的。 但在node中的只需要调用相同函数方法就可以创建一个进程。例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入创建子进程的模块</span></span><br><span class="line"><span class="keyword">const</span> childProcess = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取cpu的数量</span></span><br><span class="line"><span class="keyword">const</span> cpuNum = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).<span class="title function_">cpus</span>().<span class="property">length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建与cpu数量一样的子进程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cpuNum; ++i) &#123;</span><br><span class="line">  childProcess.<span class="title function_">fork</span>(<span class="string">&#x27;./worker.js&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="2-6-进程的定义、组成、组织方式、状态与转换"><a href="#2-6-进程的定义、组成、组织方式、状态与转换" class="headerlink" title="2.6 进程的定义、组成、组织方式、状态与转换"></a>2.6 进程的定义、组成、组织方式、状态与转换</h4><h5 id="2-6-1-为什么要引入进程的概念呢？"><a href="#2-6-1-为什么要引入进程的概念呢？" class="headerlink" title="2.6.1 为什么要引入进程的概念呢？"></a>2.6.1 为什么要引入进程的概念呢？</h5><ul>
<li>早期的计算机只支持<code>单道程序</code>（是指所有进程一个一个排队执行，A进程执行时，CPU、内存、I/O设备全是A进程控制的，等A进程执行完了，才换B进程，然后对应的资源比如CPU、内存这些才能换B用）。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85d60c74edfc4e9485fba703f52dd97e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></li>
<li>现代计算机是<code>多道程序</code>执行，就是同时看起来有多个程序在一起执行，那每个程序执行都需要系统分配给它资源来执行，比如<code>CPU</code>、<code>内存</code>。</li>
<li>拿内存来说，操作系统要知道给A程序分配的内存有哪些，给B程序分配的内存有哪些，这些都要有小本本记录下来，这个小本本就是进程的一部分，进程的一大职责就是<code>记录目前程序运行的状态</code>。</li>
<li>系统为每个运行的程序配置一个数据结构，称为<code>进程控制块</code>（PCB），用来描述进程的各种信息（比如代码段放在哪）。</li>
</ul>
<h5 id="2-6-2-进程的定义？"><a href="#2-6-2-进程的定义？" class="headerlink" title="2.6.2 进程的定义？"></a>2.6.2 进程的定义？</h5><p>简要的说，进程就是具有<code>独立功能的程序</code>在数据集合上<code>运行的过程</code>。(强调动态性)</p>
<h5 id="2-6-3-PCB有哪些组成"><a href="#2-6-3-PCB有哪些组成" class="headerlink" title="2.6.3 PCB有哪些组成"></a>2.6.3 PCB有哪些组成</h5><p>如下图，分别说明一下 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fad302f1961248dc8489739fd8e28c46~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li><code>进程标识符PID</code>相当于身份证。是在进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，<code>用于区分不同的进程</code>。</li>
<li>用户标识符<code>UID</code>用来表示这个进程<code>所属的用户</code>是谁。</li>
<li>进程当前状态和优先级下一小节会详细介绍</li>
<li>程序段指针是指当前进程的程序在<code>内存的什么地方</code>。</li>
<li>数据段指针是指当前进程的数据在<code>内存的什么地方</code>。</li>
<li>键盘和鼠标是指进程被<code>分配得到的I/O设备</code>。</li>
<li>各种寄存器值是指比如把程序计数器的值，比如有些计算的结果算到一半，进程切换时需要把这些值保存下来。</li>
</ul>
<h5 id="2-6-4-进程的组织"><a href="#2-6-4-进程的组织" class="headerlink" title="2.6.4 进程的组织"></a>2.6.4 进程的组织</h5><p>在一个系统中，通常由数十、数百乃至数千个<code>PCB</code>。为了对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。这里介绍一种组织方式，类似数据结构里的链表。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80201fdf7ce242f18174dcb18ff4b833~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h5 id="2-6-5-进程的状态"><a href="#2-6-5-进程的状态" class="headerlink" title="2.6.5 进程的状态"></a>2.6.5 进程的状态</h5><p><code>进程是程序的一次执行。</code>在这个执行过程中，有时进程正在<code>被CPU处理</code>，有时又需要<code>等待CPU服务</code>，可见，进程的 状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p>
<p>进程的三种基本状态：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b732a28a9ad435f8f20b365edd08916~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>进程的另外两种状态：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cea105addf6473da486e64fe6b9be56~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h5 id="2-6-6-进程状态的转换"><a href="#2-6-6-进程状态的转换" class="headerlink" title="2.6.6 进程状态的转换"></a>2.6.6 进程状态的转换</h5><p>进程的状态并不是一成不变的，在一定情况下会动态转换。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ce930479dc4ba0a6fb021198de671d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>以上的这些进程状态的转换是如何实现的呢，这就要引出下一个角色了，叫`原语。</p>
<ul>
<li>原语是<code>不可被中断</code>的原子操作。我们举一个例子看看原语是怎么保证不可中断的。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca6a27dd09f14178870960ad305ae3ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 原语采用<code>关中断指令</code>和<code>开中断指令</code>实现。</p>
<ul>
<li>首先执行关中断指令</li>
<li>然后外部来了中断信号，不予以处理</li>
<li>等到开中断指令执行后，其他中断信号才有机会处理。</li>
</ul>
<h4 id="2-6-进程的通信"><a href="#2-6-进程的通信" class="headerlink" title="2.6 进程的通信"></a>2.6 进程的通信</h4><blockquote>
<p>为什么需要进程间通信呢？</p>
</blockquote>
<p>因为进程是<code>分配系统资源的单位</code>（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/763951d99b6a4ba3992415554d9fec2e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h5 id="2-6-1-进程通信方法—共享存储"><a href="#2-6-1-进程通信方法—共享存储" class="headerlink" title="2.6.1 进程通信方法—共享存储"></a>2.6.1 进程通信方法—共享存储</h5><p>因为两个进程的存储空间<code>不能相互访问</code>，所以操作系统就提供的一个内存空间让彼此都能访问，这就是共享存储的原理。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca7157b11dd74f8e90dd42f9b5dd9cf4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>其中，介绍一下基于存储区的共享。</p>
<ul>
<li>在内存中画出一块<code>共享存储区</code>，数据的形式、存放位置都是由进程控制，而不是操作系统。</li>
</ul>
<h5 id="2-6-2-进程通信方法—管道"><a href="#2-6-2-进程通信方法—管道" class="headerlink" title="2.6.2 进程通信方法—管道"></a>2.6.2 进程通信方法—管道</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36e3b665bee04bcfbb0a20c359f76c3c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>管道数据是以<code>字符流</code>（注意不是字节流）的形式写入管道，当管道写满时，写进程的<code>write()</code>系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的<code>read()</code>系统调用将被阻塞。</li>
<li>如果没写满就不允许读。如果都没空就不允许写。</li>
<li>数据一旦被读出，就从管道中被丢弃，这就意味着<code>读进程</code>最多只能有一个。</li>
</ul>
<h5 id="2-6-3-进程通信方法—消息传递"><a href="#2-6-3-进程通信方法—消息传递" class="headerlink" title="2.6.3 进程通信方法—消息传递"></a>2.6.3 进程通信方法—消息传递</h5><p>进程间的数据交换以<code>格式化的消息</code>为单位。进程通过操作系统提供的<code>&quot;发送消息/接收消息&quot;</code>两个原语进行数据交换。</p>
<p>其中消息是什么意思呢？就好像你发QQ消息，消息头的来源是你，消息体是你发的内容。如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66fee389dbd44c39b57d3883ec13f441~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>接下来我们介绍一种<code>间接通信</code>的方式（很像中介者模式或者发布订阅模式）, 如下图：中介者是信箱，进程通过它来收发消息。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c7ab1f18d704b9fbcebef25447cbc80~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h4 id="2-7-线程"><a href="#2-7-线程" class="headerlink" title="2.7 线程"></a>2.7 线程</h4><blockquote>
<p>为什么要引入线程呢？</p>
</blockquote>
<ul>
<li>比如你在玩QQ的时候，QQ是一个进程，如果QQ的进程里没有多线程并发，那么QQ进程就只能<code>同一时间做一件事情</code>（比如QQ打字聊天）</li>
<li>但是我们真实的场景是QQ聊天的同时，还可以发文件，还可以视频聊天，这说明如果QQ<code>没有多线程并发能力</code>，QQ能够的实用性就大大降低了。所以我们<code>需要线程</code>，也就是<code>需要进程拥有能够并发</code>多个事件的能力。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30a1f85b6c474ed794feaa05d758341a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>引入线程后带来的变化 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2eeee2b2646477ea6806ca40e8cb1f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h3 id="3-进程的同步和互斥"><a href="#3-进程的同步和互斥" class="headerlink" title="3 进程的同步和互斥"></a>3 进程的同步和互斥</h3><blockquote>
<p>同步。是指多个进程中发生的事件存在某种先后顺序。即某些进程的执行必须先于另一些进程。</p>
</blockquote>
<p>比如说<code>进程A</code>需要从缓冲区读取<code>进程B</code>产生的信息，当缓冲区为空时，<code>进程B</code>因为读取不到信息而被阻塞。而当<code>进程A</code>产生信息放入缓冲区时，<code>进程B</code>才会被唤醒。概念如图1所示。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43bc18cf5524f659a9ecfd8f8ccd5ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<blockquote>
<p>互斥。是指多个进程不允许同时使用同一资源。当某个进程使用某种资源的时候，其他进程必须等待。</p>
</blockquote>
<p>比如<code>进程B</code>需要访问打印机，但此时<code>进程A</code>占有了打印机，<code>进程B</code>会被阻塞，直到<code>进程A</code>释放了打印机资源,进程B才可以继续执行。概念如图3所示。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f49d7a510234059a036db17621e6611~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h4 id="3-1-信号量（了解概念即可）"><a href="#3-1-信号量（了解概念即可）" class="headerlink" title="3.1 信号量（了解概念即可）"></a>3.1 信号量（了解概念即可）</h4><p><code>信号量</code>主要是来解决进程的<code>同步</code>和<code>互斥</code>的，我们前端需要了解，如果涉及到同步和互斥的关系（我们编程大多数关于流程的逻辑问题，本质不就是同步和互斥吗？）</p>
<p>在操作系统中，常用<code>P、V信号量</code>来实现进程间的<code>同步</code>和<code>互斥</code>，我们简单了解一下一种常用的信号量，<code>记录型信号量</code>来简单了解一下信号量本质是怎样的。（c语言来表示，会有备注）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 剩余资源</span></span><br><span class="line">    Struct process *L <span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>意思是信号量的结构有两部分组成，<code>一部分是剩余资源value</code>，比如目前有两台打印机空闲，那么剩余资源就是2，谁正在使用打印机，剩余资源就减1。</p>
<p><code>Struct process *L </code>意思是，比如2台打印机都有人在用，这时候你的要用打印机，此时会把这个打印机资源的请求放入阻塞队列，L就是阻塞队列的地址。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*P 操作，也就是记录型信号量的请求资源操作*/</span></span><br><span class="line">void wait (semaphore S) &#123;</span><br><span class="line">    S<span class="selector-class">.value--</span>;</span><br><span class="line">    if (S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        block (S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列中。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*V 操作，也就是记录型信号量的释放资源操作*/</span></span><br><span class="line">void singal (semaphore S) &#123;</span><br><span class="line">    S<span class="selector-class">.value</span>++;</span><br><span class="line">    if (S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        wakeup (S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>释放资源后，若还有别的进程在等待这个资源，比如打印机资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为继续态。</p>
<h4 id="3-2-生产者消费者问题（了解概念即可）"><a href="#3-2-生产者消费者问题（了解概念即可）" class="headerlink" title="3.2 生产者消费者问题（了解概念即可）"></a>3.2 生产者消费者问题（了解概念即可）</h4><p>为什么要讲这个呢，主要是node的流的机制，本质就是生产者消费者问题，可以简单的看看这个问题如何解决。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1e2c682268d41ca8c83534fa084a99c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 如上图，<code>生产者</code>的主要作用是生成<code>一定量的数据放到缓冲区中</code>，然后<code>重复此过程</code>。与此同时，消费者也在<code>缓冲区消耗这些数据</code>。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
<p>这里我们需要两个同步信号量和一个互斥信号量</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 互斥信号量，实现对缓冲区的互斥访问</span><br><span class="line">semaphore <span class="attr">mutex</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">// 同步信号量，表示目前还可以生产几个产品</span><br><span class="line">semaphore <span class="attr">empty</span> = n<span class="comment">;</span></span><br><span class="line">// 同步信号量，表示目前可以消耗几个产品</span><br><span class="line">semaphore <span class="attr">full</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>生产者代码如下</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">producer () &#123;</span><br><span class="line">    <span class="built_in">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 生产一个产品</span></span><br><span class="line">        <span class="selector-tag">P</span>(empty);</span><br><span class="line">        <span class="comment">// 对缓冲区加锁</span></span><br><span class="line">        <span class="selector-tag">P</span>(mutex);</span><br><span class="line">        这里的代码是生产一个产品</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="comment">// 产出一个产品</span></span><br><span class="line">        <span class="built_in">V</span>(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>消费者代码如下</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">producer () &#123;</span><br><span class="line">    <span class="built_in">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 消费一个产品</span></span><br><span class="line">        <span class="selector-tag">P</span>(full);</span><br><span class="line">        <span class="comment">// 对缓冲区加锁</span></span><br><span class="line">        <span class="selector-tag">P</span>(mutex);</span><br><span class="line">        这里的代码是消费一个产品</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="comment">// 消费一个产品</span></span><br><span class="line">        <span class="built_in">V</span>(empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="4-内存的基础知识和概念"><a href="#4-内存的基础知识和概念" class="headerlink" title="4 内存的基础知识和概念"></a>4 内存的基础知识和概念</h3><blockquote>
<p>为什么需要内存</p>
</blockquote>
<p>内存是计算机<code>其它硬件设备</code>与<code>CPU沟通</code>的桥梁、中转站。程序执行前需要先放到内存中才能被CPU处理。</p>
<h4 id="4-1-cpu如何区分执行程序的数据在内存的什么地方"><a href="#4-1-cpu如何区分执行程序的数据在内存的什么地方" class="headerlink" title="4.1 cpu如何区分执行程序的数据在内存的什么地方"></a>4.1 cpu如何区分执行程序的数据在内存的什么地方</h4><ul>
<li>是通过给<code>内存的存储单元编址</code>实现的。（存储单元一般是以字节为单位）</li>
<li>如下图，内存的存储单元，就像一个酒店的房间，都有编号，比如程序一的数据都在1楼，1楼1号存储着程序里<code>let a = 1</code>这段代码。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a38ed59e7b0490d8cf33f1918aad2b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h4 id="4-2-内存管理-内存空间的分配与回收"><a href="#4-2-内存管理-内存空间的分配与回收" class="headerlink" title="4.2 内存管理-内存空间的分配与回收"></a>4.2 内存管理-内存空间的分配与回收</h4><ul>
<li>内存分配分为<code>连续分配</code>和<code>非连续分配</code>，连续分配是指用户进程分配的必须是<code>一个连续的内存空间</code>。</li>
<li>这里我们只讲连续分配中的<code>动态分区分配</code>。</li>
<li>什么是动态分区分配呢，这种分配方式<code>不会预先划分内存分区</code>，而是在进程装入内存时，根据进程的大小<code>动态地</code>建立分区，并使分区的大小<code>正好适合</code>进程的需要。（比如，某计算机内存大小64MB，系统区8MB，用户区56MB…，现在我们有几个进程要装入内存，如下图）</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffd33160b37145b1b88cac9291623cac~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>随之而来的问题就是，如果此时进程1使用完了，相应在内存上的数据也被删除了，那么<code>空闲的区域</code>，后面该怎么分配（也就是说随着进程退出，会有很多空闲的内存区域出现）</li>
</ul>
<p>我们讲一种较为简单的处理方法叫<code>空闲分区表</code>法来解决这个问题。如下图，右侧的表格就是一个空闲分区表。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a68dfb01459c42c6903079072272157d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配呢，例如下图，分别有<code>20MB</code>，<code>10MB</code>，<code>4MB</code>三个空闲分区块，现在<code>进程5</code>需要<code>4MB</code>空闲分区，改怎么分配呢？</p>
<p>我们需要按照一定的动态分区分配算法，比如有<code>首次适应算法</code>，指的是每次都从低地址开始查找，找到第一个能满足大小的空闲分区。还有比如<code>最佳适应算法</code>，指的是从空闲分区表中找到最小的适合分配的分区块来满足需求。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b26aa3c975264ceea6d3ed652d1c6614~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p><code>连续分配缺点很明显</code>，大多数情况，需要分配的进程大小，不能跟空闲分区剩下的大小完全一样，这样就产生很多很难利用的<code>内存碎片</code>。</p>
<p>这里我们介绍一种更好的空闲分区的分配方法，<code>基本分页存储</code>。如下图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd268e0a431a4b15ae4296bfca89694a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"> 将内存空间分为<code>一个个大小相等</code>的分区（比如：每个分区<code>4KB</code>）.每个分区就是一个<code>“页框”</code>。页框号从<code>0</code>开始。</p>
<p>将用户进程的地址空间分为与页框大小相等的一个个区域，称为<code>“页”</code>。每个页也是从<code>0</code>开始。</p>
<h3 id="5-文件管理"><a href="#5-文件管理" class="headerlink" title="5 文件管理"></a>5 文件管理</h3><blockquote>
<p>文件是什么？</p>
</blockquote>
<p>文件就是一组有意义的<code>信息/数据</code>集合。</p>
<p>计算机中存放了各种各样的文件，一个文件有哪些属性呢？文件内部的数据应该怎样组织起来？文件之间又该怎么组织起来？</p>
<h4 id="5-1-文件的属性"><a href="#5-1-文件的属性" class="headerlink" title="5.1 文件的属性"></a>5.1 文件的属性</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6421765e1ce4a9cb65e43d141024eb7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>文件名。即文件的名字，需要注意的是，同一目录下<code>不允许</code>有重名的文件。</li>
<li>标识符。操作系统用于区分各个文件的一种<code>内部的名称</code>。</li>
<li>类型。文件的类型。</li>
<li>位置。文件<code>存放的路径</code>，同时也是在硬盘里的位置（需要转换成物理硬盘上的地址）</li>
<li>创建时间、上次修改时间、文件所有者就是字面意思。</li>
<li>保护信息。比如对这个文件的<code>执行权限</code>，是否有删除文件权限，修改文件权限等等。</li>
</ul>
<h4 id="5-2-文件内部数据如何组织在一起"><a href="#5-2-文件内部数据如何组织在一起" class="headerlink" title="5.2 文件内部数据如何组织在一起"></a>5.2 文件内部数据如何组织在一起</h4><p>如下图，文件主要分为<code>有结构文件</code>和<code>无结构文件</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f1af8437fa94756b1b43fd6bf33b192~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h4 id="5-3-文件之间如何组织起来"><a href="#5-3-文件之间如何组织起来" class="headerlink" title="5.3 文件之间如何组织起来"></a>5.3 文件之间如何组织起来</h4><p>通过<code>树状结构</code>组织的。例如<code>windows</code>的文件间的组织关系如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/432b2dcbf38c4a8980f4870e1d6b4c9c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>接下来我们详细的了解一下<code>文件的逻辑结构</code></p>
<h4 id="5-4-文件的逻辑结构"><a href="#5-4-文件的逻辑结构" class="headerlink" title="5.4 文件的逻辑结构"></a>5.4 文件的逻辑结构</h4><p>逻辑结构是指，在用户看来，文件内部的数据是如何组织起来的，而<code>“物理结构”</code>是在操作系统看来，文件是如何保存在外存，比如<code>硬盘</code>中的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70dc16b172314e5db51fc5d04d8a064e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>比如，<code>“线性表”</code>就是一种逻辑结构，在用户看来，线性表就是一组有先后关系的元素序列，如：<code>a,b,c,d,e....</code></p>
<ul>
<li><code>“线性表”</code>这种逻辑结构可以用不同的物理结构实现，比如：<code>顺序表/链表</code>。<code>顺序表</code>的各个元素在逻辑上相邻，在物理上也相邻：而<code>链表</code>的各个元素在物理上可以是不相邻的。</li>
<li>因此，顺序表可以实现<code>“随机访问”</code>，而<code>“链表”</code>无法实现随机访问。</li>
</ul>
<p>接下来我了解一下有结构文件的三种逻辑结构</p>
<h5 id="5-4-1-顺序文件"><a href="#5-4-1-顺序文件" class="headerlink" title="5.4.1 顺序文件"></a>5.4.1 顺序文件</h5><blockquote>
<p>什么是顺序文件</p>
</blockquote>
<p>指的是文件中的记录一个接一个地在逻辑上是<code>顺序排列</code>，记录可以是<code>定长</code>或<code>变长</code>，各个记录在物理上可以<code>顺序存储</code>或<code>链式存储</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5a6f71703a849c3a2a3b3d10f521481~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>顺序文件按结构来划分，可以分为<code>串结构</code>和<code>顺序结构</code>。</li>
<li>串结构是指记录之间的顺序与<code>关键字无关</code>，通常都是按照记录的时间决定记录的顺序。</li>
<li>顺序结构就必须保证记录之间的先后顺序按<code>关键字排列</code>。</li>
</ul>
<p>这里需要注意的知识点是，顺序文件的存储方式和是否<code>按关键字排列</code>，会影响数据<code>是否支持随机存取</code>和<code>是否可以快速按关键字找到对应记录</code>的功能。</p>
<p>可以看到，顺序文件按顺序存放对于查找是非常有帮助的，我们在记录文件的时候也可以注意利用这一点。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d09c18951374a87b2add0bd911adb45~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h5 id="5-4-2-索引文件"><a href="#5-4-2-索引文件" class="headerlink" title="5.4.2 索引文件"></a>5.4.2 索引文件</h5><p>对于<code>可变长记录文件</code>，要找到<code>第i</code>个记录，必须先顺序查找<code>前i-1</code>个记录（也就是需要遍历一遍），但是很多场景中又必须使用可变长记录，如何解决这个问题呢？这就引出来马上讲的<code>索引文件</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63a6c065b6404ad7a095d76fa7427be5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>给这些变长的记录都用一张索引表来记录，一个索引表项包括了<code>索引号</code>，<code>长度</code>和<code>指针</code>。</li>
<li>其中，可以将关键字作为索引号的内容，如果关键字本身的排列是有序的，那么还可以按照关键字进行折半查找。这里是关键，因为我们平时用mysql数据库对某个字段假如索引，就是这个道理。</li>
<li>但是建立索引表的问题也很明显，首先若要<code>删除/增加</code>一个记录，同时也要对<code>索引表</code>操作，其次，如果<code>增加一条记录才1KB</code>，但是索引表<code>增加i一条记录可能有8KB</code>，以至于索引表的体积大大多于记录。存储空间的利用率就比较低。</li>
</ul>
<h5 id="5-4-3-索引顺序文件"><a href="#5-4-3-索引顺序文件" class="headerlink" title="5.4.3 索引顺序文件"></a>5.4.3 索引顺序文件</h5><p>索引顺序文件是<code>索引文件</code>和<code>顺序文件</code>思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是，并不是每个记录对应一个<code>索引表项</code>，而是一组记录对应一个索引表项。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a70b298461f4e84970428384a9d3e45~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>如上图，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不需要按关键字排序</p>
<h4 id="5-5-文件目录"><a href="#5-5-文件目录" class="headerlink" title="5.5 文件目录"></a>5.5 文件目录</h4><p>首先，我们需要了解一下<code>文件控制</code>块是什么。我们假设目前在<code>windows的D盘</code>，如下图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae80fe1578784a6abf0649f7e404d215~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>可以看到，目录本身就是一种<code>有结构的文件</code>，记录了目录里的<code>文件</code>和<code>目录</code>的信息，比如名称和类型。而这些一条条的记录就是一个个的<code>“文件控制块”（FCB）</code>。</p>
<p>文件目录的结构通常是<code>树状的</code>，例如linux里<code>/</code>是指根路径，<code>/home</code>是根路径下的二级目录</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f8e8b78cf9a43bd8ec0e3913eb69d53~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>需要注意的是，树状目录<code>不容易实现文件共享</code>，所以在树形目录结构的基础上，增加了一些指向同一节点的有向边（可以简单理解为引用关系，就跟js里的对象一样）</li>
<li>也就是说需要为<code>每个共享节点</code>设置一个<code>共享计数器</code>，用于记录此时有多少个地方在共享该结点。只有<code>共享计数器减为0</code>，才删除该节点。</li>
</ul>
<h4 id="文件分配方式（物理分配）"><a href="#文件分配方式（物理分配）" class="headerlink" title="文件分配方式（物理分配）"></a>文件分配方式（物理分配）</h4><p>我们这里介绍一种索引分配的方式：</p>
<p>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表记录了文件各个逻辑块对应的物理块。索引表存放的磁盘块称为索引快。文件数据存放的磁盘块称为数据块。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc8174ebcc114535bba6c176aa994c2e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="截屏2021-07-30 上午8.48.45.png"></p>
<p>如上图，假设某个新创建的文件’aaa’的数据依次存放磁盘块2-&gt;5-&gt;13&gt;9。7号磁盘块作为’aaa‘的索引块，索引块保存了索引表的内容</p>
<h4 id="文件的逻辑分配和物理分配"><a href="#文件的逻辑分配和物理分配" class="headerlink" title="文件的逻辑分配和物理分配"></a>文件的逻辑分配和物理分配</h4><p>上面我们讲到了文件的逻辑分配，是站在用户视角的分配，物理分配是站在操作系统的角度的分配，分配的是实际的物理磁盘里的空间。</p>
<p>举个例子，我们用户看到的文件，意识里都是顺序排列的，比如说，excel表有100行数据，用户看来这100行数据就是连续的。</p>
<p>在操作系统的视角，它可以把这100行数据分为一个个的数据块，比如跟磁盘块（假设磁盘块是1kb大小）一样都是1kb，拆分后的数据可以使用索引表的形式分配（也就是我们上面才讲了的，索引分配的方式，打散分配在实际的物理磁盘里）</p>
<h4 id="5-6-文件存储空间管理"><a href="#5-6-文件存储空间管理" class="headerlink" title="5.6 文件存储空间管理"></a>5.6 文件存储空间管理</h4><p>首先，我们了解一下磁盘分为<code>目录区</code>和<code>文件区</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52b8b0a5f7a3429086355bc4d270f413~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>接着，我们了解一下常见的两种<code>文件存储空间的管理算法</code>，如下图，假如硬盘上<code>空闲的数据块</code>是蓝色，<code>非空闲的数据</code>块是橙色。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cd7a2957b11495c9cdb1f36fe8a6da0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>对分配连续的存储空间，可以采用<code>空闲表法</code>（只讲这种较简单的方法）来<code>分配</code>和<code>回收</code>磁盘块。对于分配，可以采用首次适应，最佳适应等算法来决定要为文件分配哪个区间。（空闲表表示如下）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efaf172946114c8eb87b30a2ea169879~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li><code>首次适应</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>第一个满足条件</code>的空闲区间。</li>
<li><code>最佳适应算法</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>满足条件而且空闲块最小的空闲区间</code>。</li>
</ul>
<p>再讲一种位示图法</p>
<p>如下图：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bb290ae36894a6f9c1403c4957b7bc3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>每一个二进制位对应一个磁盘块，比如上面0表示空闲块，1表示已分配的块。而且我们可以通过一定的公式，可以从示图表的横纵坐标推断出物理块的实际地址，也可以从物理块的实际地址推断出在表里的横纵坐标。</p>
<h4 id="5-7-文件共享"><a href="#5-7-文件共享" class="headerlink" title="5.7 文件共享"></a>5.7 文件共享</h4><p>文件共享分为两种</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/678a819dc59c46cba3266249aa5ba27e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>注意，多个用户<code>共享同一个文件</code>，意味着系统只有<code>“一份”</code>文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到<code>文件的变化</code>。</li>
<li>软连接可以理解为<code>windows</code>里的<code>快捷方式</code>。</li>
<li>硬链接可以理解为js里的<code>引用计数</code>，只有引用为<code>0</code>的时候，才会真正删除这个文件。</li>
</ul>
<h4 id="5-8-文件保护"><a href="#5-8-文件保护" class="headerlink" title="5.8 文件保护"></a>5.8 文件保护</h4><p>操作系统需要保护文件的安全，一般有如下3种方式：</p>
<ul>
<li>口令保护。是指为文件设置一个<code>“口令”</code>（比如123），用户请求访问该文件时必须提供对应的口令。口令一般放在文件对应的<code>FCB或者索引结点</code>上。</li>
<li>加密保护。使用某个<code>&quot;密码&quot;</code>对文件进行加密，在访问文件时需要提供<code>正确的“密码”</code>才能对文件进行正确的解密。</li>
<li>访问控制。在每个文件的FCB或者索引节点种增加一个<code>访问控制列表</code>，该表中记录了各个用户可以对该文件执行哪些操作。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b30ba5541246ad90018aedce215a26~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h2 id="总结文件系统这块的内容"><a href="#总结文件系统这块的内容" class="headerlink" title="总结文件系统这块的内容"></a>总结文件系统这块的内容</h2><p>我们举一个实际案例，把上面的内容总结一下。</p>
<p>假如我们当前的操作系统采用如下的文件系统管理方式：</p>
<ul>
<li>文件的物理结构 — 索引分配（混合索引）</li>
<li>文件目录的实现 — inode结点</li>
<li>空闲分区管理 — 位示图法</li>
</ul>
<p>那么我们假设0号磁盘块就是装载位示图的磁盘块，用来管理哪些磁盘是空闲的哪些是正在使用的。 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5129b71fdcb34e3ab49b2de7469215ba~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>因为这里我们已经使用了0号块，位示图的第一项就是1</p>
<p>接着我们把磁盘块第二块用来放inode节点，也就是文件目录索引节点，意思是文件目录下存放的只有文件名和索引节点的位置，要知道文件的详细信息，就要靠着</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68935b04dd884171a13dd36c3584b73a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>假设2号磁盘块存放了我们根目录信息，而本身目录其实也是一种特殊的文件，也在inode节点表里有自己的信息，1号磁盘块增加类似如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型：目录</span><br><span class="line">存放在：2号磁盘块</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>2号磁盘块里面存放了一个<code>你好.txt</code>文件，那么2号磁盘块会增加一行信息，类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件名：你好.txt</span><br><span class="line">inode结点：2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这就意味着，2号inode节点存放了你好.txt文件的具体磁盘块在哪，所以在1号磁盘块的2号inode节点增加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型：txt</span><br><span class="line">存放在：3、4号磁盘块</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>为什么要放到3、4号磁盘块呢，因为我们有位示图，知道哪些磁盘块是空闲的就分配给它，一扫描发现3、4正空闲而且满足存放这个文件的条件，就分配出去了。</p>
<p>我们在细分一下这里的3、4号磁盘块是什么意思，因为我们物理磁盘块分配的方法是混合索引，其实3、4号磁盘块表示的形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接索引：3号磁盘块</span><br><span class="line">直接索引：4号磁盘块</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面只涉及到直接索引，我们其实还可以有1级索引，2级索引，这些索引指向的是一个索引表，我们这里就不详细叙述了（之前交过索引块和索引表）。</p>
<p>到这里我们们就基本明白了一个文件系统的基本运行原理。</p>
<h3 id="6-I-O设备"><a href="#6-I-O设备" class="headerlink" title="6 I/O设备"></a>6 I/O设备</h3><blockquote>
<p>什么是I/O设备</p>
</blockquote>
<p>I/O就是<code>输入输出</code>(Input/Output)的意思，I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/536eb5ac39434f8b8af6854229cca78a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<h4 id="6-1-I-O设备分类–按使用特性"><a href="#6-1-I-O设备分类–按使用特性" class="headerlink" title="6.1 I/O设备分类–按使用特性"></a>6.1 I/O设备分类–按使用特性</h4><ul>
<li>人机交互类设备，这类设备传输数据的速度慢</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcdfaebb040f4233be5f864b00905eae~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>存储设备，这类设备传输数据的速度较快</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89c845739cd242ea867cdc3a519fa784~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>网络通信设备，这类设备的传输速度介于人机交互设备和存储设备之间</li>
</ul>
<h4 id="6-2-I-O控制器"><a href="#6-2-I-O控制器" class="headerlink" title="6.2 I/O控制器"></a>6.2 I/O控制器</h4><p>CPU无法直接控制<code>I/O设备的机械部件</code>，因此I/O设备还要有一个电子部件作为<code>CPU</code>和<code>I/O设备</code>机械部件之间的<code>“中介”</code>，用于实现CPU对设备的控制。这个电子部件就是<code>I/O控制器</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c4431903aa8475688e9b181938a4e85~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<ul>
<li>接收和识别CPU发出的指令是指，比如CPU发来读取文件的命令，I/O控制器中会有相应的<code>控制寄存器</code>来存放命令和参数</li>
<li>向cpu报告设备的状态是指，I/O控制器会有相应的<code>状态寄存器</code>，用来记录I/O设备<code>是否空闲</code>或者<code>忙碌</code></li>
<li>数据交换是指I/O控制器会设置相应的<code>数据寄存器</code>。输出时，数据寄存器用于<code>暂存CPU发来的数据</code>，之后再由控制器传送给设备。</li>
<li>地址识别是指，为了区分设备控制器中的各个寄存器中的各个寄存器，也需要给各个寄存器设置一个特性的<code>“地址”</code>。I/O控制器通过CPU提供的“地址”来判断CPU要读写的是哪个寄存器</li>
</ul>
<h4 id="6-3-I-O控制方式"><a href="#6-3-I-O控制方式" class="headerlink" title="6.3 I/O控制方式"></a>6.3 I/O控制方式</h4><ul>
<li>这里我们指讲一下目前比较先进的方式，通道控制方式。</li>
<li>通道可以理解为一种<code>“弱鸡版CPU”</code>。通道可以识别并执行一系列通道指令。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1321294866e34aa99674e26e8780d7e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></li>
</ul>
<p>通道最大的优点是极大的<code>减少了CPU的干预频率</code>，<code>I/O设备</code>完成任务，通道会向CPU发出<code>中断</code>，不需要轮询来问I/O设备是否完成CPU下达的任务。</p>
<p>本文完结。</p>
<p>作者：孟祥_成都<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904112803282957">https://juejin.cn/post/6844904112803282957</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://guizhan.github.io">Arche</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://guizhan.github.io/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/">https://guizhan.github.io/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://guizhan.github.io" target="_blank">博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/10_1 (5).jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/TCP/"><img class="prev-cover" src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/10_1 (4).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TCP笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/28/%E7%AC%94%E8%AE%B0%E5%8C%BA/A_Git%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/10_1 (1).png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Git笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Arche</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fa-brands fa-tiktok"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Arche的个人博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%B1%E7%9A%84%E9%97%AE%E4%B8%80%E9%97%AE-%E8%A6%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B9%B2%E5%98%9B%EF%BC%9F"><span class="toc-text">弱弱的问一问: 要操作系统干嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%B1%E7%9A%84%E9%97%AE%E4%B8%80%E9%97%AE-%E5%89%8D%E7%AB%AF%E5%AD%A6%E8%BF%99%E4%B8%AA%E5%B9%B2%E5%98%9B%EF%BC%9F"><span class="toc-text">弱弱的问一问: 前端学这个干嘛？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">2、操作系统运行机制和体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%B8%A4%E7%A7%8D%E6%8C%87%E4%BB%A4%E3%80%81%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%E5%99%A8%E7%8A%B6%E6%80%81%E3%80%81%E4%B8%A4%E7%A7%8D%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.1 两种指令、两种处理器状态、两种程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.2 操作系统内核简单介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E4%B8%AD%E6%96%AD"><span class="toc-text">2.3 中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2.4 中断的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">2.5 系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E3%80%81%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.6 进程的定义、组成、组织方式、状态与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%91%A2%EF%BC%9F"><span class="toc-text">2.6.1 为什么要引入进程的概念呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-text">2.6.2 进程的定义？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-PCB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E6%88%90"><span class="toc-text">2.6.3 PCB有哪些组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">2.6.4 进程的组织</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">2.6.5 进程的状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-6-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.6.6 进程状态的转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">2.6 进程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%E2%80%94%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-text">2.6.1 进程通信方法—共享存储</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%E2%80%94%E7%AE%A1%E9%81%93"><span class="toc-text">2.6.2 进程通信方法—管道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%E2%80%94%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">2.6.3 进程通信方法—消息传递</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.7 线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="toc-text">3 进程的同步和互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E4%BA%86%E8%A7%A3%E6%A6%82%E5%BF%B5%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-text">3.1 信号量（了解概念即可）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%86%E8%A7%A3%E6%A6%82%E5%BF%B5%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-text">3.2 生产者消费者问题（了解概念即可）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A6%82%E5%BF%B5"><span class="toc-text">4 内存的基础知识和概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-cpu%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9"><span class="toc-text">4.1 cpu如何区分执行程序的数据在内存的什么地方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-text">4.2 内存管理-内存空间的分配与回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">5 文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">5.1 文件的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">5.2 文件内部数据如何组织在一起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E8%B5%B7%E6%9D%A5"><span class="toc-text">5.3 文件之间如何组织起来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">5.4 文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-text">5.4.1 顺序文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-text">5.4.2 索引文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-text">5.4.3 索引顺序文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">5.5 文件目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E7%89%A9%E7%90%86%E5%88%86%E9%85%8D%EF%BC%89"><span class="toc-text">文件分配方式（物理分配）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E5%88%86%E9%85%8D%E5%92%8C%E7%89%A9%E7%90%86%E5%88%86%E9%85%8D"><span class="toc-text">文件的逻辑分配和物理分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">5.6 文件存储空间管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-text">5.7 文件共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-text">5.8 文件保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BF%99%E5%9D%97%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">总结文件系统这块的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-I-O%E8%AE%BE%E5%A4%87"><span class="toc-text">6 I&#x2F;O设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-I-O%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB%E2%80%93%E6%8C%89%E4%BD%BF%E7%94%A8%E7%89%B9%E6%80%A7"><span class="toc-text">6.1 I&#x2F;O设备分类–按使用特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-I-O%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">6.2 I&#x2F;O控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">6.3 I&#x2F;O控制方式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/20/web%E5%89%8D%E7%AB%AF/Typescript/TypeScript%20%E7%AC%94%E8%AE%B0/" title="无题"><img src="http://0kv.cn/6opD1x" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/12/20/web%E5%89%8D%E7%AB%AF/Typescript/TypeScript%20%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2022-12-20T03:20:40.537Z" title="发表于 2022-12-20 11:20:40">2022-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/20/web%E5%89%8D%E7%AB%AF/Typescript/Typescript/" title="无题"><img src="http://0kv.cn/6opD1x" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/12/20/web%E5%89%8D%E7%AB%AF/Typescript/Typescript/" title="无题">无题</a><time datetime="2022-12-19T16:13:18.907Z" title="发表于 2022-12-20 00:13:18">2022-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/16/web%E5%89%8D%E7%AB%AF/2_CSS/%E5%AD%97%E4%BD%93/" title="字体"><img src="http://g0p.cc/6mQ7qj" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="字体"/></a><div class="content"><a class="title" href="/2022/12/16/web%E5%89%8D%E7%AB%AF/2_CSS/%E5%AD%97%E4%BD%93/" title="字体">字体</a><time datetime="2022-12-16T14:12:51.000Z" title="发表于 2022-12-16 22:12:51">2022-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/14/web%E5%89%8D%E7%AB%AF/2_CSS/%E5%AE%9A%E4%BD%8D%E7%9A%84%E7%AE%80%E4%BB%8B/" title="定位的简介"><img src="http://g0p.cc/6mQ7qj" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="定位的简介"/></a><div class="content"><a class="title" href="/2022/12/14/web%E5%89%8D%E7%AB%AF/2_CSS/%E5%AE%9A%E4%BD%8D%E7%9A%84%E7%AE%80%E4%BB%8B/" title="定位的简介">定位的简介</a><time datetime="2022-12-14T14:12:51.000Z" title="发表于 2022-12-14 22:12:51">2022-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/13/%E7%AC%94%E8%AE%B0%E5%8C%BA/Hexo/" title="Hexo上传失败问题"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/9009/10_1 (2).jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo上传失败问题"/></a><div class="content"><a class="title" href="/2022/12/13/%E7%AC%94%E8%AE%B0%E5%8C%BA/Hexo/" title="Hexo上传失败问题">Hexo上传失败问题</a><time datetime="2022-12-13T14:12:51.000Z" title="发表于 2022-12-13 22:12:51">2022-12-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Arche</div><div class="footer_custom_text">很高兴认识你</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>